<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced CPU Model Detection</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #0d1117;
            color: #c9d1d9;
        }
        .detection-section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #30363d;
            border-radius: 8px;
            background: #161b22;
        }
        .status {
            padding: 8px;
            margin: 3px 0;
            border-radius: 4px;
            font-size: 13px;
        }
        .cpu-info { background: #0d5016; border-left: 4px solid #56d364; }
        .limitation { background: #5d1a1a; border-left: 4px solid #f85149; }
        .enhancement { background: #1a3d5d; border-left: 4px solid #58a6ff; }
        .model-guess { background: #5d4b1a; border-left: 4px solid #f0d000; }
        button {
            background: #238636;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            margin: 5px;
            font-family: inherit;
        }
        button:hover { background: #2ea043; }
        .results { max-height: 600px; overflow-y: auto; }
        .highlight { color: #58a6ff; font-weight: bold; }
        .signature-table {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 8px;
            margin: 10px 0;
            font-size: 12px;
        }
        .signature-table > div {
            padding: 6px;
            background: #21262d;
            border-radius: 4px;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>ğŸ” å¢å¼ºå‹è®¾å¤‡æŒ‡çº¹è¯†åˆ«ç³»ç»Ÿ</h1>

    <div class="detection-section">
        <h2>æ£€æµ‹æ–¹æ³•å¯¹æ¯”</h2>
        <button onclick="runCPUDetection()">ğŸ¯ WASM CPUæ£€æµ‹</button>
        <button onclick="runWASMDetail()">ğŸ§  WASM ç»†åˆ†è¯†åˆ«</button>
        <button onclick="runBasicDetection()">ğŸ”§ WASMè¯¦ç»†åˆ†æ</button>
        <button onclick="runWebGLDetection()">ğŸ¨ WebGL GPUæ£€æµ‹</button>
        <button onclick="runWebGPUDetection()">âš¡ WebGPUé«˜çº§æ£€æµ‹</button>
        <button onclick="runTripleDetection()">ğŸš€ ä¸‰é‡æ£€æµ‹ (ç»ˆæç²¾åº¦)</button>
        <button onclick="analyzeSignatures()">ğŸ§¬ å®Œæ•´ç‰¹å¾åˆ†æ</button>
        <button onclick="showDatabaseStats()">ğŸ“Š è®¾å¤‡æ•°æ®åº“ç»Ÿè®¡</button>
        <button onclick="clearResults()">æ¸…é™¤ç»“æœ</button>
    </div>

    <div class="detection-section">
        <h2>æµ‹è¯•å’Œè¯Šæ–­å·¥å…·</h2>
        <button onclick="runValidationTests()">ğŸ§ª WASMéªŒè¯æµ‹è¯•</button>
        <button onclick="runDiagnostics()">ğŸ” ç³»ç»Ÿè¯Šæ–­</button>
    </div>

    <div id="output" class="results"></div>

    <script src="./build/wasm-fingerprint.js"></script>
    <script src="./src/common.js"></script>
    <script src="./src/webgl-detection.js"></script>
    <script src="./src/webgpu-detection.js"></script>
    <script src="./src/device-database.js"></script>
    <script>
        const output = document.getElementById('output');
        let wasmModule = null;
        let deviceDatabase = null;

        function addResult(message, type = 'cpu-info') {
            const div = document.createElement('div');
            div.className = `status ${type}`;
            div.innerHTML = `[${new Date().toLocaleTimeString()}] ${message}`;
            output.appendChild(div);
            output.scrollTop = output.scrollHeight;
        }

        function clearResults() {
            output.innerHTML = '';
        }

        // WASM ç»†åˆ†è¯†åˆ«ï¼ˆä»…WASMï¼Œä½¿ç”¨å¯é€‰æ ¡å‡†ï¼‰
        async function runWASMDetail() {
            try {
                addResult('=== ğŸ§  WASM ç»†åˆ†è¯†åˆ«ï¼ˆç‹¬ç«‹ï¼‰ ===', 'enhancement');
                const fp = await window.wasmFingerprint.generateFingerprint();
                const detail = await window.wasmFingerprint.classifyWASM(fp);

                addResult('ğŸ¯ WASM ç»†åˆ†ç»“è®º:', 'model-guess');
                addResult(`   å®¶æ—: <span class="highlight">${detail.family || 'Unknown'}</span>`, 'model-guess');
                if (detail.generation) addResult(`   ä»£é™…: <span class="highlight">${detail.generation}</span>`, 'model-guess');
                if (detail.tier) addResult(`   æ¡£ä½: <span class="highlight">${detail.tier}</span>`, 'model-guess');
                addResult(`   ç½®ä¿¡åº¦: <span class="highlight">${detail.confidence}%</span>`, 'model-guess');

                // å…³é”®è¯æ®
                const ev = detail.evidence || [];
                if (ev.length) {
                    addResult('ğŸ“‹ å…³é”®è¯æ®:', 'cpu-info');
                    ev.slice(0, 6).forEach(e => addResult(`   â€¢ ${e}`, 'cpu-info'));
                }

                // ç»“æ„ä¸æ¯”ä¾‹
                if (detail.l1kb || detail.l2kb || detail.l3mb) {
                    addResult(`ğŸ§¬ ç»“æ„: L1=${detail.l1kb || '-'}KB, L2=${detail.l2kb || '-'}KB, L3=${detail.l3mb || '-'}MB`, 'cpu-info');
                }
                if (typeof detail.l1Band === 'number' || typeof detail.deepBand === 'number') {
                    addResult(`ğŸ“Š æ¯”ä¾‹: L1æ®µ=${(detail.l1Band??NaN).toFixed ? detail.l1Band.toFixed(3) : detail.l1Band}, æ·±å±‚=${(detail.deepBand??NaN).toFixed ? detail.deepBand.toFixed(3) : detail.deepBand}`, 'cpu-info');
                }

            } catch (e) {
                console.error(e);
                addResult(`âŒ WASM ç»†åˆ†è¯†åˆ«å¤±è´¥: ${e.message}`, 'limitation');
            }
        }

        

        async function initWASM() {
            if (wasmModule && wasmModule.runtimeInitialized) {
                return wasmModule;
            }

            // æ¸…ç†ä¹‹å‰çš„æ¨¡å—å®ä¾‹
            wasmModule = null;

            try {
                const timestamp = Date.now();

                // ä½¿ç”¨æ›´å¯é çš„åˆå§‹åŒ–æ–¹å¼
                wasmModule = await new Promise((resolve, reject) => {
                    let resolved = false;

                    const moduleConfig = {
                        locateFile: (path, scriptDirectory) => {
                            if (path.endsWith('.wasm')) {
                                return scriptDirectory + path + '?v=' + timestamp;
                            }
                            return scriptDirectory + path;
                        },
                        onRuntimeInitialized: function() {
                            if (resolved) return; // é˜²æ­¢é‡å¤å›è°ƒ
                            resolved = true;

                            // å¼ºåˆ¶è®¾ç½®æ­£ç¡®çš„çŠ¶æ€æ ‡å¿—
                            this.runtimeInitialized = true;

                            console.log('âœ… WASMè¿è¡Œæ—¶æ­£å¼åˆå§‹åŒ–å®Œæˆ:', {
                                runtimeInitialized: this.runtimeInitialized,
                                calledRun: this.calledRun,
                                hasHEAP8: !!this.HEAP8,
                                hasMalloc: typeof this._malloc === 'function',
                                hasSequentialTest: typeof this._sequential_access_test === 'function'
                            });

                            // ç«‹å³éªŒè¯å…³é”®åŠŸèƒ½
                            if (this._sequential_access_test && this.HEAP8 && this._malloc) {
                                resolve(this);
                            } else {
                                reject(new Error('WASMæ¨¡å—åˆå§‹åŒ–åç¼ºå°‘å…³é”®åŠŸèƒ½'));
                            }
                        },
                        onAbort: function(what) {
                            if (resolved) return;
                            resolved = true;
                            reject(new Error('WASMåˆå§‹åŒ–ä¸­æ­¢: ' + what));
                        }
                    };

                    // å¯åŠ¨WASMæ¨¡å—
                    try {
                        WASMModule(moduleConfig);
                    } catch (e) {
                        if (!resolved) {
                            resolved = true;
                            reject(e);
                        }
                    }

                    // è¶…æ—¶ä¿æŠ¤
                    setTimeout(() => {
                        if (!resolved) {
                            resolved = true;
                            reject(new Error('WASMåˆå§‹åŒ–è¶…æ—¶ (5ç§’)'));
                        }
                    }, 5000);
                });

                // æœ€ç»ˆéªŒè¯å’ŒçŠ¶æ€ç¡®è®¤
                if (!wasmModule.runtimeInitialized) {
                    throw new Error('è¿è¡Œæ—¶åˆå§‹åŒ–æ ‡å¿—ä»ç„¶ä¸ºfalse');
                }

                // åŠŸèƒ½éªŒè¯æµ‹è¯•
                try {
                    const testPtr = wasmModule._malloc(1024);
                    if (testPtr) {
                        wasmModule._free(testPtr);
                        console.log('âœ… å†…å­˜åˆ†é…æµ‹è¯•é€šè¿‡');
                    } else {
                        console.warn('âš ï¸ å†…å­˜åˆ†é…æµ‹è¯•å¤±è´¥ï¼Œä½†ç»§ç»­æ‰§è¡Œ');
                    }

                    const testResult = wasmModule._sequential_access_test(32, 10);
                    console.log('âœ… åºåˆ—è®¿é—®æµ‹è¯•é€šè¿‡:', testResult);
                } catch (e) {
                    console.warn('âš ï¸ åŠŸèƒ½éªŒè¯æµ‹è¯•å¤±è´¥:', e.message);
                }

                return wasmModule;
            } catch (error) {
                wasmModule = null;
                console.error('âŒ WASMåˆå§‹åŒ–å½»åº•å¤±è´¥:', error);
                addResult(`âŒ WASMåŠ è½½å¤±è´¥: ${error.message}`, 'limitation');
                throw error;
            }
        }

        // ç»“æœæœ‰æ•ˆæ€§éªŒè¯å‡½æ•°
        function validateTestResults(features) {
            const issues = [];
            const warnings = [];

            // 1. æ£€æŸ¥é¢„å–å™¨æ•ˆç‡
            if (features.prefetch_efficiency !== null && features.prefetch_efficiency !== undefined) {
                if (!isFinite(features.prefetch_efficiency) || features.prefetch_efficiency <= 0) {
                    issues.push("é¢„å–å™¨æµ‹è¯•æ— æ•ˆ (Infinityæˆ–è´Ÿå€¼)");
                } else if (features.prefetch_efficiency > 1000) {
                    warnings.push("é¢„å–å™¨æ•ˆç‡å¼‚å¸¸é«˜ (å¯èƒ½æµ‹è¯•å¤±æ•ˆ)");
                }
            }

            // 2. æ£€æŸ¥é™¤æ³•æ•ˆç‡
            if (features.division_efficiency !== undefined) {
                if (features.division_efficiency === 0) {
                    issues.push("é™¤æ³•æµ‹è¯•å¤±è´¥ (è¿”å›0)");
                } else if (!isFinite(features.division_efficiency)) {
                    issues.push("é™¤æ³•æµ‹è¯•æ— æ•ˆ (éæœ‰é™å€¼)");
                }
            }

            // 3. æ£€æŸ¥æ­¥é•¿æµ‹è¯•çš„ä¸€è‡´æ€§
            const strides = [64, 128, 256, 512, 4096];
            const strideValues = strides.map(s => features[`stride_${s}`]).filter(v => v > 0);

            if (strideValues.length < 3) {
                issues.push("æ­¥é•¿æµ‹è¯•å¤±æ•ˆè¿‡å¤š (æœ‰æ•ˆæµ‹è¯•å°‘äº3ä¸ª)");
            } else {
                // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å€¼éƒ½å®Œå…¨ç›¸åŒï¼ˆä¸å¤ªå¯èƒ½ï¼‰
                const uniqueValues = new Set(strideValues.map(v => Math.round(v * 1000)));
                if (uniqueValues.size === 1) {
                    warnings.push("æ­¥é•¿æµ‹è¯•ç»“æœå®Œå…¨ç›¸åŒ (å¯èƒ½æµ‹è¯•ç²¾åº¦ä¸è¶³)");
                }
            }

            // 4. æ£€æŸ¥ç¼“å­˜å†²çªæµ‹è¯•
            const conflicts = [4096, 8192, 16384, 32768].map(s => features[`conflict_${s}`]).filter(v => v !== undefined && v > 0);
            if (conflicts.length > 1) {
                const uniqueConflicts = new Set(conflicts.map(v => Math.round(v * 1000))); // é™ä½ç²¾åº¦è¦æ±‚
                if (uniqueConflicts.size === 1) {
                    warnings.push("ç¼“å­˜å†²çªæµ‹è¯•ç»“æœå®Œå…¨ç›¸åŒ");
                } else if (conflicts.filter(v => v < 0.1).length === conflicts.length) {
                    issues.push("ç¼“å­˜å†²çªæµ‹è¯•ç²¾åº¦è¿‡ä½ (æ‰€æœ‰ç»“æœ<0.1ms)");
                }
            } else {
                warnings.push("ç¼“å­˜å†²çªæœ‰æ•ˆæµ‹è¯•è¿‡å°‘");
            }

            // 5. æ£€æŸ¥è®¡ç®—æµ‹è¯•çš„åˆç†æ€§
            if (features.float_precision !== undefined && features.float_precision === 0) {
                issues.push("æµ®ç‚¹è®¡ç®—æµ‹è¯•å¤±è´¥");
            }

            if (features.integer_opt !== undefined && features.integer_opt === 0) {
                warnings.push("æ•´æ•°ä¼˜åŒ–æµ‹è¯•å¯èƒ½æ— æ•ˆ");
            }

            return { issues, warnings };
        }

        // æ ¸å¿ƒCPUæ£€æµ‹å‡½æ•°
        async function runCPUDetection() {
            try {
                addResult('=== ğŸ¯ CPUå‹å·æ£€æµ‹å¯åŠ¨ ===', 'enhancement');
                const Module = await initWASM();

                // æ ¸å¿ƒæ£€æµ‹: å†…å­˜è®¿é—®æ¨¡å¼
                addResult('ğŸ§  å†…å­˜è®¿é—®æ¨¡å¼åˆ†æ:', 'cpu-info');

                // è¿è¡Œå¤šæ¬¡æµ‹è¯•è·å¾—å‡†ç¡®æ¯”ä¾‹
                let ratios = [];
                const testParams = [
                    { size: 32, iter: 200 },  // åŸºç¡€æµ‹è¯• - å¢åŠ è¿­ä»£æ¬¡æ•°ä»¥è·å¾—å¯æµ‹é‡æ—¶é—´
                    { size: 64, iter: 150 },  // ç¼“å­˜è¾¹ç•Œæµ‹è¯•
                    { size: 32, iter: 200 }   // é‡å¤éªŒè¯
                ];

                for (let i = 0; i < testParams.length; i++) {
                    const { size, iter } = testParams[i];

                    // æµ‹é‡æ‰§è¡Œæ—¶é—´è€Œä¸æ˜¯è¿”å›å€¼
                    const seqStart = performance.now();
                    Module._sequential_access_test(size, iter);
                    const seqTime = performance.now() - seqStart;

                    const randStart = performance.now();
                    Module._random_access_test(size, iter);
                    const randTime = performance.now() - randStart;

                    if (seqTime > 0.1 && randTime > 0.1) {  // è‡³å°‘0.1msç¡®ä¿æœ‰æ„ä¹‰
                        const ratio = randTime / seqTime;
                        ratios.push(ratio);
                        addResult(`   æµ‹è¯• ${i+1}(${size}KB/${iter}æ¬¡): é¡ºåº=${seqTime.toFixed(2)}ms, éšæœº=${randTime.toFixed(2)}ms, æ¯”ä¾‹=${ratio.toFixed(3)}`, 'cpu-info');
                    }
                }

                const avgRatio = ratios.reduce((a, b) => a + b) / ratios.length;
                addResult(`   å¹³å‡æ¯”ä¾‹: ${avgRatio.toFixed(3)}`, 'cpu-info');

                // ç¼“å­˜ç‰¹å¾åˆ†æ
                addResult('ğŸ“Š ç¼“å­˜æ¶æ„åˆ†æ:', 'cpu-info');
                const l1Size = Module._l1_cache_size_detection(320);
                const cacheLineSize = Module._cache_line_size_detection();
                let l2Size = null;
                let l3Size = null;
                try { if (Module._l2_cache_size_detection) l2Size = Module._l2_cache_size_detection(20480); } catch(_e) {}
                try { if (Module._l3_cache_size_detection) l3Size = Module._l3_cache_size_detection(64); } catch(_e) {}

                addResult(`   L1ç¼“å­˜å¤§å°: ${l1Size}KB`, 'cpu-info');
                addResult(`   ç¼“å­˜è¡Œå¤§å°: ${cacheLineSize}å­—èŠ‚`, 'cpu-info');
                if (typeof l2Size === 'number' && l2Size > 0) {
                    addResult(`   L2ç¼“å­˜å¤§å°(ä¼°è®¡): ${l2Size}KB`, 'cpu-info');
                }
                if (typeof l3Size === 'number' && l3Size > 0) {
                    addResult(`   L3ç¼“å­˜å¤§å°(ä¼°è®¡): ${l3Size}MB`, 'cpu-info');
                }

                // CPUå‹å·æ¨æ–­ - ç»Ÿä¸€ç®—æ³•ä¸å…¶ä»–æ£€æµ‹ä¿æŒä¸€è‡´
                let cpuModel = "æœªçŸ¥CPU";
                let confidence = 0;
                let evidence = [];

                // ä¸æ‰€æœ‰å…¶ä»–æ£€æµ‹ä½¿ç”¨å®Œå…¨ç›¸åŒçš„é˜ˆå€¼ï¼Œç¡®ä¿ç»“æœä¸€è‡´
                if (avgRatio >= 0.5 && avgRatio < 1.6) {  // ç»Ÿä¸€Apple SiliconèŒƒå›´
                    cpuModel = "Apple Silicon (M1/M2/M3/M4)";
                    confidence = 90;
                    evidence.push(`å†…å­˜è®¿é—®æ¯”ä¾‹ ${avgRatio.toFixed(3)} æ˜¾ç¤ºç»Ÿä¸€å†…å­˜æ¶æ„ç‰¹å¾`);

                    if (avgRatio <= 0.8) {
                        confidence = 95;
                        evidence.push("æä½çš„éšæœºè®¿é—®æƒ©ç½šï¼Œå…¸å‹çš„Apple Siliconç‰¹å¾");
                    }
                } else if (avgRatio >= 1.6 && avgRatio <= 2.5) {  // ç»Ÿä¸€IntelèŒƒå›´
                    cpuModel = "Intelé«˜æ€§èƒ½CPU";
                    confidence = 85;
                    evidence.push(`å†…å­˜è®¿é—®æ¯”ä¾‹ ${avgRatio.toFixed(3)} ç¬¦åˆIntelç¼“å­˜æ¶æ„`);
                } else if (avgRatio > 2.5 && avgRatio <= 4.0) {  // ç»Ÿä¸€AMDèŒƒå›´
                    cpuModel = "AMD Ryzen/ä¸»æµCPU";
                    confidence = 80;
                    evidence.push(`å†…å­˜è®¿é—®æ¯”ä¾‹ ${avgRatio.toFixed(3)} æ˜¾ç¤ºAMDå…¸å‹ç‰¹å¾`);
                } else if (avgRatio > 4.0) {
                    cpuModel = "ä½ç«¯CPUæˆ–è™šæ‹Ÿç¯å¢ƒ";
                    confidence = 70;
                    evidence.push(`å†…å­˜è®¿é—®æ¯”ä¾‹ ${avgRatio.toFixed(3)} æ˜¾ç¤ºæ€§èƒ½å—é™ç‰¹å¾`);
                } else {
                    cpuModel = "å¼‚å¸¸ç»“æœ";
                    confidence = 30;
                    evidence.push(`å†…å­˜è®¿é—®æ¯”ä¾‹ ${avgRatio.toFixed(3)} å¼‚å¸¸ï¼Œå¯èƒ½æ˜¯æµ‹è¯•ç¯å¢ƒé—®é¢˜`);
                }

                // ç¼“å­˜ç‰¹å¾éªŒè¯
                if (l1Size === 32 && cacheLineSize === 64) {
                    confidence += 5;
                    evidence.push("æ ‡å‡†L1ç¼“å­˜é…ç½®(32KB/64B)");
                } else if (l1Size === 32 && cacheLineSize === 128) {
                    if (cpuModel.includes("Apple")) {
                        confidence += 10;
                        evidence.push("Appleç‰¹æœ‰çš„128å­—èŠ‚ç¼“å­˜è¡Œ");
                    }
                }

                addResult('ğŸ¯ æ£€æµ‹ç»“æœ:', 'model-guess');
                addResult(`   CPUå‹å·: ${cpuModel}`, 'model-guess');
                addResult(`   ç½®ä¿¡åº¦: ${confidence}%`, 'model-guess');
                addResult('ğŸ“‹ æ¨æ–­ä¾æ®:', 'model-guess');
                evidence.forEach(e => addResult(`   â€¢ ${e}`, 'model-guess'));

            } catch (error) {
                addResult(`âŒ CPUæ£€æµ‹å¤±è´¥: ${error.message}`, 'limitation');
            }
        }

        async function runBasicDetection() {
            try {
                addResult('=== ğŸ“Š WASM CPUå¾®æ¶æ„æ·±åº¦åˆ†æ ===', 'cpu-info');
                const Module = await initWASM();

                // åŸºç¡€æ€§èƒ½ç‰¹å¾ - ä½¿ç”¨ä¿®å¤ç‰ˆæ—¶é—´æµ‹é‡
                function timedTest(testFunc, ...args) {
                    const startTime = performance.now();
                    const result = testFunc(...args);
                    const endTime = performance.now();
                    return { result, time: endTime - startTime };
                }

                const seqTest = timedTest(Module._sequential_access_test.bind(Module), 16, 1000);
                const randTest = timedTest(Module._random_access_test.bind(Module), 16, 1000);
                const float_test = timedTest(Module._float_precision_test.bind(Module), 10000);
                const int_test = timedTest(Module._integer_optimization_test.bind(Module), 10000);
                const vector_test = timedTest(Module._vector_computation_test.bind(Module), 1000);

                // Apple Siliconç‰¹æ®Šæ¶æ„å¤„ç†ï¼šç»Ÿä¸€å†…å­˜å¯èƒ½å¯¼è‡´ç‰¹æ®Šçš„è®¿é—®æ¨¡å¼
                let memRatio;
                let isAppleMemoryPattern = false;

                if (randTest.time > 0.001 && seqTest.time > 0.001) {
                    if (randTest.time < seqTest.time) {
                        // é¡ºåºè®¿é—®æ¯”éšæœºè®¿é—®æ…¢ - è¿™åœ¨Apple Siliconä¸Šå¯èƒ½æ˜¯æ­£å¸¸çš„
                        const reverseRatio = seqTest.time / randTest.time;

                        if (reverseRatio < 1.5) {
                            // å·®å¼‚ä¸å¤§ï¼Œå¯èƒ½æ˜¯Appleç»Ÿä¸€å†…å­˜æ¶æ„çš„ç‰¹å¾
                            memRatio = reverseRatio;
                            isAppleMemoryPattern = true;
                            addResult(`ğŸ æ£€æµ‹åˆ°Apple Siliconå†…å­˜æ¨¡å¼ï¼šé¡ºåºè®¿é—®ç•¥æ…¢äºéšæœºè®¿é—®`, 'enhancement');
                        } else {
                            // å·®å¼‚å¾ˆå¤§ï¼Œå¯èƒ½ç¡®å®æ˜¯å¼‚å¸¸
                            memRatio = reverseRatio;
                            addResult(`âš ï¸ æ£€æµ‹åˆ°å¼‚å¸¸ï¼šé¡ºåºè®¿é—®æ˜æ˜¾æ…¢äºéšæœºè®¿é—®(${reverseRatio.toFixed(2)}x)`, 'limitation');
                        }
                    } else {
                        memRatio = randTest.time / seqTest.time;
                    }
                } else {
                    memRatio = 'Too Fast';
                }

                // æ˜¾ç¤ºåŸºç¡€ç»“æœ
                addResult('ğŸ”§ åŸºç¡€æ€§èƒ½æµ‹è¯•ç»“æœ:', 'cpu-info');
                if (typeof memRatio === 'number') {
                    let description;
                    if (isAppleMemoryPattern) {
                        description = `Apple Siliconæ¨¡å¼ - é¡ºåº${seqTest.time.toFixed(2)}ms / éšæœº${randTest.time.toFixed(2)}ms`;
                    } else {
                        const slowerAccess = randTest.time > seqTest.time ? 'éšæœº' : 'é¡ºåº';
                        const fasterAccess = randTest.time > seqTest.time ? 'é¡ºåº' : 'éšæœº';
                        description = `${slowerAccess}${Math.max(randTest.time, seqTest.time).toFixed(2)}ms / ${fasterAccess}${Math.min(randTest.time, seqTest.time).toFixed(2)}ms`;
                    }
                    addResult(`   å†…å­˜è®¿é—®æ—¶é—´æ¯”ä¾‹: <span class="highlight">${memRatio.toFixed(3)}</span> (${description})`, 'cpu-info');
                } else {
                    addResult(`   å†…å­˜è®¿é—®æ—¶é—´æ¯”ä¾‹: <span class="highlight">${memRatio}</span>`, 'limitation');
                }
                addResult(`   æµ®ç‚¹è®¡ç®—: <span class="highlight">${float_test.result.toFixed(6)}</span> (${float_test.time.toFixed(2)}ms)`, 'cpu-info');
                addResult(`   æ•´æ•°ä¼˜åŒ–: <span class="highlight">${int_test.result}</span> (${int_test.time.toFixed(2)}ms)`, 'cpu-info');
                addResult(`   å‘é‡è®¡ç®—: <span class="highlight">${vector_test.result.toFixed(6)}</span> (${vector_test.time.toFixed(2)}ms)`, 'cpu-info');

                // æ‰§è¡ŒWASMè¯¦ç»†ç¼“å­˜åˆ†æ
                addResult('ğŸ§¬ WASMç¼“å­˜å±‚æ¬¡åˆ†æ:', 'enhancement');

                const features = {};
                const testSizes = [
                    { size: 32, label: '32KB(L1è¾¹ç•Œ)', iterations: 300 },
                    { size: 64, label: '64KB', iterations: 300 },
                    { size: 256, label: '256KB(L2è¾¹ç•Œ)', iterations: 200 },
                    { size: 512, label: '512KB', iterations: 200 },
                    { size: 2048, label: '2MB(L3è¾¹ç•Œ)', iterations: 100 },
                    { size: 4096, label: '4MB', iterations: 50 }
                ];

                addResult('   æ­£åœ¨åˆ†æç¼“å­˜ç‰¹å¾...', 'enhancement');

                const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));

                for (let testCase of testSizes) {
                    let seqTimes = [];
                    let randTimes = [];

                    for (let run = 0; run < 2; run++) {
                        Module._sequential_access_test(8192, 3);

                        const seqStart = performance.now();
                        Module._sequential_access_test(testCase.size, testCase.iterations);
                        const seqTime = performance.now() - seqStart;
                        seqTimes.push(seqTime);

                        Module._random_access_test(8192, 3);

                        const randStart = performance.now();
                        Module._random_access_test(testCase.size, testCase.iterations);
                        const randTime = performance.now() - randStart;
                        randTimes.push(randTime);
                    }

                    const avgSeqTime = seqTimes.reduce((a, b) => a + b) / seqTimes.length;
                    const avgRandTime = randTimes.reduce((a, b) => a + b) / randTimes.length;

                    if (avgSeqTime > 1.0 && avgRandTime > 1.0) {
                        const ratio = avgRandTime / avgSeqTime;
                        features[`mem_ratio_${testCase.size}KB`] = ratio;

                        const isSignificant = ratio > 1.6 ? 'âš ï¸ ç¼“å­˜è¾¹ç•Œ' : '';
                        addResult(`   ${testCase.label}: æ¯”ä¾‹=${ratio.toFixed(3)} ${isSignificant}`, 'enhancement');
                    }
                }

                // WASMå¾®æ¶æ„ç‰¹å¾åˆ†æ
                addResult('ğŸ¯ WASMå¾®æ¶æ„ç‰¹å¾åˆ†æ:', 'model-guess');

                // æ­¥é•¿æ•æ„Ÿæ€§æµ‹è¯•
                const strideTests = [
                    { stride: 64, label: '1ç¼“å­˜è¡Œ(64B)' },
                    { stride: 128, label: '2ç¼“å­˜è¡Œ(128B)' },
                    { stride: 512, label: '8ç¼“å­˜è¡Œ(512B)' },
                    { stride: 4096, label: '1å†…å­˜é¡µ(4KB)' }
                ];

                addResult('   é¢„å–å™¨è¡Œä¸ºåˆ†æ:', 'model-guess');
                for (const test of strideTests) {
                    const start = performance.now();
                    Module._stride_access_test(512, test.stride, 200);
                    const time = performance.now() - start;
                    features[`stride_${test.stride}`] = time;
                    addResult(`     ${test.label}: ${time.toFixed(1)}ms`, 'model-guess');
                }

                // é¢„å–å™¨æ•ˆç‡ - ç¨³å®šè®¡ç®—æ–¹æ³•
                let prefetchEfficiency = null;
                const strides = [64, 128, 512, 4096];
                const validStrides = strides.filter(s => features[`stride_${s}`] > 0.001);

                if (validStrides.length >= 2) {
                    const smallStride = validStrides[0];
                    const largeStride = validStrides[validStrides.length - 1];
                    const smallTime = features[`stride_${smallStride}`];
                    const largeTime = features[`stride_${largeStride}`];

                    prefetchEfficiency = smallTime / largeTime;

                    // åˆç†æ€§æ£€æŸ¥
                    if (prefetchEfficiency > 0.1 && prefetchEfficiency < 50) {
                        let desc = "";
                        if (prefetchEfficiency < 0.5) desc = " (è¶…å¼ºé¢„å–å™¨)";
                        else if (prefetchEfficiency < 1.0) desc = " (å¼ºé¢„å–å™¨)";
                        else if (prefetchEfficiency < 3.0) desc = " (ä¸­ç­‰é¢„å–å™¨)";
                        else desc = " (é¢„å–å™¨ä¸€èˆ¬)";

                        addResult(`   ğŸ”® é¢„å–å™¨æ•ˆç‡: ${prefetchEfficiency.toFixed(1)}${desc}`, 'model-guess');
                    } else {
                        addResult(`   âš ï¸ é¢„å–å™¨åˆ†æ: æ•°æ®å¼‚å¸¸ (æ•ˆç‡=${prefetchEfficiency.toFixed(2)})`, 'limitation');

                        // é‡æ–°åˆ†ææ—¶é—´è¶‹åŠ¿
                        addResult('   ğŸ” è¯¦ç»†æ—¶é—´åˆ†æ:', 'model-guess');
                        for (let i = 1; i < validStrides.length; i++) {
                            const prev = validStrides[i-1];
                            const curr = validStrides[i];
                            const ratio = features[`stride_${curr}`] / features[`stride_${prev}`];
                            const trend = ratio > 1 ? "å¢åŠ " : "å‡å°‘";
                            addResult(`     ${prev}Bâ†’${curr}B: æ—¶é—´${trend} ${(Math.abs(ratio-1)*100).toFixed(1)}%`, 'model-guess');
                        }

                        prefetchEfficiency = null;
                    }
                } else {
                    addResult(`   âš ï¸ é¢„å–å™¨åˆ†æ: æœ‰æ•ˆæµ‹è¯•æ•°æ®ä¸è¶³ (${validStrides.length}ä¸ªæœ‰æ•ˆæ­¥é•¿)`, 'limitation');
                }

                // WASMä¸“ç”¨CPUè¯†åˆ«ç®—æ³•
                const memoryTests = Object.entries(features)
                    .filter(([k, v]) => k.startsWith('mem_ratio'))
                    .map(([k, v]) => v);

                const avgMemRatio = memoryTests.length > 0 ?
                    memoryTests.reduce((a, b) => a + b) / memoryTests.length : memRatio;

                let wasmCpuType = "æœªçŸ¥æ¶æ„";
                let confidence = 30;
                let evidence = [];

                if (typeof avgMemRatio === 'number') {
                    // ä¼˜å…ˆåŸºäºé¢„å–å™¨ç‰¹å¾è¯†åˆ«Apple Silicon
                    const isApplePrefetcher = prefetchEfficiency > 10 && prefetchEfficiency < 30;
                    const cacheJumps = memoryTests.filter(ratio => ratio > 1.4).length;
                    const hasAppleCachePattern = cacheJumps >= 3;

                    // Apple Siliconå¼ºç‰¹å¾æ£€æµ‹
                    if (isApplePrefetcher && hasAppleCachePattern) {
                        wasmCpuType = "Apple Silicon";
                        confidence = 90;
                        evidence.push("Apple Siliconé¢„å–å™¨ç‰¹å¾ç¡®è®¤");
                        evidence.push("Appleç»Ÿä¸€å†…å­˜ç¼“å­˜æ¨¡å¼");

                        if (avgMemRatio < 1.2) {
                            wasmCpuType = "Apple Silicon (M4ç³»åˆ—å¯èƒ½æ€§é«˜)";
                            confidence = 95;
                        }

                    } else if (avgMemRatio >= 0.5 && avgMemRatio < 1.6) {  // ä¸å¿«é€Ÿæ£€æµ‹å®Œå…¨ä¸€è‡´
                        wasmCpuType = "Apple Silicon";
                        confidence = 85;
                        evidence.push("ä½å†…å­˜è®¿é—®æ¯”ä¾‹ï¼Œå…¸å‹ç»Ÿä¸€å†…å­˜æ¶æ„");

                        if (isApplePrefetcher) {
                            confidence += 10;
                            evidence.push("Apple Siliconé¢„å–å™¨ç‰¹å¾");
                        }

                        if (hasAppleCachePattern) {
                            confidence += 5;
                            evidence.push("Appleç»Ÿä¸€å†…å­˜ç¼“å­˜æ¨¡å¼");
                        }

                    } else if (avgMemRatio >= 1.6 && avgMemRatio <= 2.5 && !isApplePrefetcher) {  // ç»Ÿä¸€é˜ˆå€¼è‡³1.6
                        wasmCpuType = "Intelé«˜æ€§èƒ½CPU";
                        confidence = 75;
                        evidence.push("ä¸­ç­‰å†…å­˜è®¿é—®æ¯”ä¾‹ï¼Œåˆ†å±‚ç¼“å­˜æ¶æ„");

                        if (prefetchEfficiency < 10) {
                            confidence += 5;
                            evidence.push("Intelå¼ºé¢„å–å™¨ç‰¹å¾");
                        }

                    } else if (avgMemRatio > 2.5 && !isApplePrefetcher) {
                        wasmCpuType = "AMD Ryzenæˆ–ä¸»æµCPU";
                        confidence = 70;
                        evidence.push("é«˜å†…å­˜è®¿é—®æ¯”ä¾‹");
                    } else {
                        // é¢„å–å™¨ç‰¹å¾å¼ºçƒˆæŒ‡å‘Appleï¼Œå³ä½¿å†…å­˜æ¯”ä¾‹å¼‚å¸¸
                        if (isApplePrefetcher) {
                            wasmCpuType = "Apple Silicon (å¼‚å¸¸å†…å­˜æ¯”ä¾‹)";
                            confidence = 80;
                            evidence.push("é¢„å–å™¨ç‰¹å¾å¼ºçƒˆæŒ‡å‘Apple Silicon");
                            evidence.push("å†…å­˜æ¯”ä¾‹å¼‚å¸¸ï¼Œå¯èƒ½å—æµ‹è¯•ç¯å¢ƒå½±å“");
                        }
                    }
                }

                addResult('ğŸ¯ WASMä¸“ä¸šåˆ†æç»“æœ:', 'model-guess');
                addResult(`   CPUæ¶æ„: <span class="highlight">${wasmCpuType}</span>`, 'model-guess');
                addResult(`   WASMæ£€æµ‹ç½®ä¿¡åº¦: <span class="highlight">${confidence}%</span>`, 'model-guess');

                if (evidence.length > 0) {
                    addResult('   WASMåˆ†æä¾æ®:', 'model-guess');
                    evidence.forEach(ev => addResult(`     â€¢ ${ev}`, 'model-guess'));
                }

                addResult('ğŸ’¡ WASMç‹¬ç‰¹ä¼˜åŠ¿:', 'cpu-info');
                addResult('   â€¢ ç›´æ¥è®¿é—®CPUå¾®æ¶æ„ç‰¹å¾', 'cpu-info');
                addResult('   â€¢ ç»•è¿‡æ“ä½œç³»ç»ŸæŠ½è±¡å±‚', 'cpu-info');
                addResult('   â€¢ ç²¾ç¡®çš„ç¼“å­˜å±‚æ¬¡åˆ†æ', 'cpu-info');
                addResult('   â€¢ é¢„å–å™¨è¡Œä¸ºæ£€æµ‹', 'cpu-info');
                addResult('   â€¢ è·¨å¹³å°ä¸€è‡´æ€§æ£€æµ‹', 'cpu-info');

                addResult('âš ï¸ WASMæ£€æµ‹é™åˆ¶:', 'limitation');
                addResult('   â€¢ å—æµè§ˆå™¨å®‰å…¨ç­–ç•¥å½±å“', 'limitation');
                addResult('   â€¢ æ— æ³•è·å–å…·ä½“å‹å·ä¿¡æ¯', 'limitation');
                addResult('   â€¢ ç²¾åº¦å—æ‰§è¡Œç¯å¢ƒæ ‡å‡†åŒ–å½±å“', 'limitation');

            } catch (error) {
                addResult(`âŒ WASMåŸºç¡€æ£€æµ‹å¤±è´¥: ${error.message}`, 'limitation');
            }
        }

        async function runEnhancedDetection() {
            try {
                addResult('=== ğŸš€ ç†è®ºå¢å¼ºæ£€æµ‹æ–¹æ¡ˆ ===', 'enhancement');

                addResult('ğŸ”¬ å¢å¼ºæ£€æµ‹éœ€è¦çš„æŠ€æœ¯:', 'enhancement');
                addResult('   1. <span class="highlight">æ›´å¤šå¾®åŸºå‡†æµ‹è¯•</span> - ç¼“å­˜å¤§å°ã€TLBç‰¹æ€§ã€é¢„å–è¡Œä¸º', 'enhancement');
                addResult('   2. <span class="highlight">æŒ‡ä»¤çº§æµ‹è¯•</span> - ç‰¹å®šæŒ‡ä»¤å»¶è¿Ÿã€ååé‡å·®å¼‚', 'enhancement');
                addResult('   3. <span class="highlight">æ—¶åºä¾§ä¿¡é“</span> - æ›´ç²¾ç¡®çš„æ€§èƒ½è®¡æ—¶å™¨', 'enhancement');
                addResult('   4. <span class="highlight">æœºå™¨å­¦ä¹ åˆ†ç±»</span> - è®­ç»ƒæ¨¡å‹è¯†åˆ«ç‰¹å¾æ¨¡å¼', 'enhancement');

                addResult('ğŸ“‹ å¯æ£€æµ‹çš„å…·ä½“ç‰¹å¾:', 'enhancement');
                const signatures = [
                    'L1ç¼“å­˜å¤§å°å’Œå»¶è¿Ÿ',
                    'L2/L3ç¼“å­˜å±‚æ¬¡ç»“æ„',
                    'TLBå¤§å°å’Œåˆ†ç»„æ–¹å¼',
                    'åˆ†æ”¯é¢„æµ‹å™¨ç®—æ³•å·®å¼‚',
                    'ä¹±åºæ‰§è¡Œçª—å£å¤§å°',
                    'SIMDæŒ‡ä»¤é›†æ”¯æŒ',
                    'å†…å­˜é¢„å–ç­–ç•¥',
                    'æµ®ç‚¹å•å…ƒç²¾åº¦ç‰¹å¾'
                ];

                for (const sig of signatures) {
                    addResult(`   â€¢ ${sig}`, 'enhancement');
                }

                addResult('ğŸ¯ ç†è®ºå¯è¯†åˆ«çš„CPUå‹å·:', 'model-guess');
                const cpuModels = [
                    { family: 'Intel', models: ['i5-8250U', 'i7-10700K', 'i9-11900K'], signature: 'ä½å†…å­˜æ¯”ä¾‹ + é«˜æµ®ç‚¹æ€§èƒ½' },
                    { family: 'AMD', models: ['Ryzen 5 3600', 'Ryzen 7 5800X'], signature: 'ä¸­ç­‰å†…å­˜æ¯”ä¾‹ + ä¼˜ç§€æ•´æ•°æ€§èƒ½' },
                    { family: 'ARM', models: ['A14 Bionic', 'Snapdragon 888'], signature: 'é«˜å†…å­˜æ¯”ä¾‹ + ç§»åŠ¨ä¼˜åŒ–' },
                    { family: 'Apple', models: ['M1', 'M2'], signature: 'ç‹¬ç‰¹ç¼“å­˜è¡Œä¸º + ç»Ÿä¸€å†…å­˜' }
                ];

                const signatureDiv = document.createElement('div');
                signatureDiv.className = 'signature-table';
                signatureDiv.innerHTML = `
                    <div><strong>å‚å•†</strong></div>
                    <div><strong>ä»£è¡¨å‹å·</strong></div>
                    <div><strong>ç‰¹å¾ç­¾å</strong></div>
                    <div><strong>æ£€æµ‹éš¾åº¦</strong></div>
                `;

                for (const cpu of cpuModels) {
                    signatureDiv.innerHTML += `
                        <div>${cpu.family}</div>
                        <div>${cpu.models.join(', ')}</div>
                        <div>${cpu.signature}</div>
                        <div>${cpu.family === 'ARM' ? 'å®¹æ˜“' : 'å›°éš¾'}</div>
                    `;
                }

                output.appendChild(signatureDiv);

                addResult('âš ï¸ å®ç°æŒ‘æˆ˜:', 'limitation');
                addResult('   â€¢ æµè§ˆå™¨å®‰å…¨ç­–ç•¥é™åˆ¶é«˜ç²¾åº¦è®¡æ—¶', 'limitation');
                addResult('   â€¢ WASMæ‰§è¡Œç¯å¢ƒæ ‡å‡†åŒ–é™ä½ç¡¬ä»¶å·®å¼‚', 'limitation');
                addResult('   â€¢ éœ€è¦å¤§é‡çœŸå®è®¾å¤‡æ•°æ®è®­ç»ƒæ¨¡å‹', 'limitation');

            } catch (error) {
                addResult(`âŒ å¢å¼ºæ£€æµ‹åˆ†æå¤±è´¥: ${error.message}`, 'limitation');
            }
        }

        async function analyzeSignatures() {
            try {
                addResult('=== ğŸ§¬ å½“å‰è®¾å¤‡ç‰¹å¾ç­¾ååˆ†æ ===', 'enhancement');
                const Module = await initWASM();

                // å¤šç»´åº¦ç‰¹å¾æå–
                addResult('æ­£åœ¨æå–å¤šç»´åº¦ç‰¹å¾...', 'enhancement');

                const features = {};

                // å†…å­˜è®¿é—®æ¨¡å¼ - å¹³è¡¡çš„ç¼“å­˜å±‚çº§æµ‹è¯•
                const testSizes = [
                    // L1ç¼“å­˜æµ‹è¯•
                    { size: 32, label: '32KB(L1è¾¹ç•Œ)', iterations: 500 },
                    { size: 64, label: '64KB', iterations: 500 },

                    // L2ç¼“å­˜æµ‹è¯•
                    { size: 256, label: '256KB(L2è¾¹ç•Œ)', iterations: 300 },
                    { size: 512, label: '512KB', iterations: 300 },

                    // L3ç¼“å­˜æµ‹è¯•
                    { size: 2048, label: '2MB(L3è¾¹ç•Œ)', iterations: 200 },
                    { size: 4096, label: '4MB', iterations: 100 },

                    // ä¸»å†…å­˜æµ‹è¯•ï¼ˆå‡å°‘åˆ°åˆç†èŒƒå›´ï¼‰
                    { size: 8192, label: '8MB(ä¸»å†…å­˜)', iterations: 50 }
                ];

                addResult('ğŸ”§ å¼€å§‹ç¼“å­˜é©±é€æµ‹è¯•...', 'enhancement');

                for (let testCase of testSizes) {
                    // ç¼“å­˜é©±é€ï¼šå…ˆè®¿é—®å¤§é‡æ— å…³æ•°æ®æ¸…ç©ºç¼“å­˜
                    addResult(`æµ‹è¯• ${testCase.label} (${testCase.iterations}æ¬¡è¿­ä»£)...`, 'enhancement');

                    // å¤šæ¬¡æµ‹è¯•æé«˜ç²¾åº¦å’Œç¨³å®šæ€§
                    let seqTimes = [];
                    let randTimes = [];

                    for (let run = 0; run < 3; run++) {  // å‡å°‘åˆ°3æ¬¡é‡å¤æµ‹è¯•
                        // è½»é‡ç¼“å­˜é©±é€ï¼šè®¿é—®è¾ƒå°æ•°æ®æ¸…ç©ºç¼“å­˜
                        Module._sequential_access_test(8192, 5);  // 8MBæ¸…ç©ºç¼“å­˜

                        // æµ‹è¯•é¡ºåºè®¿é—®
                        const seqStart = performance.now();
                        Module._sequential_access_test(testCase.size, testCase.iterations);
                        const seqTime = performance.now() - seqStart;
                        seqTimes.push(seqTime);

                        // å†æ¬¡ç¼“å­˜é©±é€
                        Module._random_access_test(8192, 5);  // 8MBæ¸…ç©ºç¼“å­˜

                        // æµ‹è¯•éšæœºè®¿é—®
                        const randStart = performance.now();
                        Module._random_access_test(testCase.size, testCase.iterations);
                        const randTime = performance.now() - randStart;
                        randTimes.push(randTime);
                        // è®©æ­¥ç»™UIï¼Œé¿å…é•¿æ—¶é—´é˜»å¡
                        await sleep(0);
                    }

                    // è®¡ç®—å¹³å‡æ—¶é—´å’Œæ ‡å‡†å·®
                    const avgSeqTime = seqTimes.reduce((a, b) => a + b) / seqTimes.length;
                    const avgRandTime = randTimes.reduce((a, b) => a + b) / randTimes.length;

                    const seqStdDev = Math.sqrt(seqTimes.reduce((sum, time) => sum + Math.pow(time - avgSeqTime, 2), 0) / seqTimes.length);
                    const randStdDev = Math.sqrt(randTimes.reduce((sum, time) => sum + Math.pow(time - avgRandTime, 2), 0) / randTimes.length);

                    // è®¡ç®—æ—¶é—´æ¯”ä¾‹ï¼ˆç°åœ¨åº”è¯¥æœ‰æ˜æ˜¾å·®å¼‚ï¼‰
                    if (avgSeqTime > 1.0 && avgRandTime > 1.0) {  // 1msæœ€å°é˜ˆå€¼
                        const ratio = avgRandTime / avgSeqTime;
                        features[`mem_ratio_${testCase.size}KB`] = ratio;

                        // åŒæ—¶è®°å½•ç¨³å®šæ€§æŒ‡æ ‡
                        features[`mem_stability_${testCase.size}KB`] = (seqStdDev + randStdDev) / (avgSeqTime + avgRandTime);

                        addResult(`   ${testCase.label}: æ¯”ä¾‹=${ratio.toFixed(3)}, é¡ºåº=${avgSeqTime.toFixed(1)}msÂ±${seqStdDev.toFixed(1)}, éšæœº=${avgRandTime.toFixed(1)}msÂ±${randStdDev.toFixed(1)}`, 'enhancement');
                    } else {
                        features[`mem_ratio_${testCase.size}KB`] = 1.0;
                        addResult(`   ${testCase.label}: æ‰§è¡Œæ—¶é—´è¿‡çŸ­ï¼Œæ— æ³•æµ‹é‡`, 'enhancement');
                    }
                }

                // è®¡ç®—ç‰¹å¾ - å¹³è¡¡çš„è¿­ä»£æ¬¡æ•°
                addResult('âš¡ è®¡ç®—æ€§èƒ½æµ‹è¯•...', 'enhancement');
                features.float_precision = Module._float_precision_test(2000);
                features.integer_opt = Module._integer_optimization_test(2000);
                features.branch_pred = Module._branch_prediction_test(3000);
                features.vector_comp = Module._vector_computation_test(500);

                // æ­¥é•¿æ•æ„Ÿæ€§æµ‹è¯• - ä¸åŒCPUçš„é¢„å–å™¨ååº”ä¸åŒ
                addResult('ğŸƒ æ­¥é•¿æ•æ„Ÿæ€§æµ‹è¯•...', 'enhancement');
                const strideTests = [
                    { stride: 64, label: '1ç¼“å­˜è¡Œ(64B)' },
                    { stride: 128, label: '2ç¼“å­˜è¡Œ(128B)' },
                    { stride: 256, label: '4ç¼“å­˜è¡Œ(256B)' },
                    { stride: 512, label: '8ç¼“å­˜è¡Œ(512B)' },
                    { stride: 4096, label: '1å†…å­˜é¡µ(4KB)' }
                ];

                const strideResults = {};
                for (const test of strideTests) {
                    const start = performance.now();
                    const result = Module._stride_access_test(512, test.stride, 500); // 512KBæ•°æ®ï¼Œå‡å°‘è¿­ä»£
                    const time = performance.now() - start;

                    strideResults[test.stride] = { result, time };
                    features[`stride_${test.stride}`] = time;

                    if (time > 0) {
                        addResult(`   ${test.label}: ${time.toFixed(1)}ms`, 'enhancement');
                    } else {
                        addResult(`   ${test.label}: æµ‹è¯•å¤±æ•ˆ (æ—¶é—´å¤ªçŸ­)`, 'limitation');
                    }
                }

                // é¢„å–å™¨æ•ˆç‡åˆ†æ - ä½¿ç”¨å¤šæ­¥é•¿ç¨³å®šè®¡ç®—
                let prefetchEfficiency;
                let strongPrefetcher = false; // ç§»åˆ°å¤–å±‚ä½œç”¨åŸŸ
                const validStrides = [];

                // æ”¶é›†æ‰€æœ‰æœ‰æ•ˆçš„æ­¥é•¿æµ‹è¯•ç»“æœ
                [64, 128, 256, 512, 4096].forEach(stride => {
                    if (strideResults[stride] && strideResults[stride].time > 0.001) {
                        validStrides.push({
                            stride: stride,
                            time: strideResults[stride].time,
                            label: stride < 1024 ? `${stride}B` : `${stride/1024}KB`
                        });
                    }
                });

                if (validStrides.length >= 3) {
                    // ä½¿ç”¨æœ€å°æ­¥é•¿vsæœ€å¤§æ­¥é•¿çš„æ¯”è¾ƒï¼Œæ›´ç¨³å®š
                    const smallStride = validStrides[0]; // æœ€å°çš„
                    const largeStride = validStrides[validStrides.length - 1]; // æœ€å¤§çš„

                    // å¦‚æœå¤§æ­¥é•¿æ˜æ˜¾æ¯”å°æ­¥é•¿æ…¢ï¼Œè¯´æ˜é¢„å–å™¨æœ‰æ•ˆ
                    prefetchEfficiency = smallStride.time / largeStride.time;

                    // æ”¹è¿›çš„è¶‹åŠ¿éªŒè¯ï¼šåŒºåˆ†å¼ºé¢„å–å™¨å’Œå¼‚å¸¸æƒ…å†µ
                    let trendConsistent = true;

                    // æ£€æŸ¥æ˜¯å¦ä¸ºå¼ºé¢„å–å™¨æ¨¡å¼ï¼ˆæ­¥é•¿è¶Šå¤§æ—¶é—´è¶ŠçŸ­ï¼‰
                    let descendingCount = 0;
                    for (let i = 1; i < validStrides.length; i++) {
                        if (validStrides[i].time < validStrides[i-1].time) {
                            descendingCount++;
                        }

                        // åªæœ‰æ—¶é—´çªç„¶å˜æˆåŸæ¥1/10æ‰è®¤ä¸ºæ˜¯çœŸæ­£å¼‚å¸¸
                        if (validStrides[i].time < validStrides[i-1].time * 0.1) {
                            trendConsistent = false;
                            break;
                        }
                    }

                    // å¦‚æœå¤§éƒ¨åˆ†æµ‹è¯•éƒ½æ˜¯é€’å‡çš„ï¼Œè¿™å¯èƒ½æ˜¯å¼ºé¢„å–å™¨ç‰¹å¾
                    if (descendingCount >= validStrides.length * 0.6) {
                        strongPrefetcher = true;
                    }

                    if (!trendConsistent) {
                        addResult(`âš ï¸ æ­¥é•¿æµ‹è¯•æ•°æ®å¼‚å¸¸ï¼ˆå­˜åœ¨10å€ä»¥ä¸Šçš„çªå˜ï¼‰`, 'limitation');
                        prefetchEfficiency = null;
                    } else {
                        const trendDesc = strongPrefetcher ? "å¼ºé¢„å–å™¨ç‰¹å¾" : "æ ‡å‡†ç¼“å­˜ç‰¹å¾";
                        addResult(`ğŸ“Š ${trendDesc}: ${smallStride.label}(${smallStride.time.toFixed(1)}ms) vs ${largeStride.label}(${largeStride.time.toFixed(1)}ms)`, 'enhancement');

                        // å¯¹äºå¼ºé¢„å–å™¨ï¼Œè°ƒæ•´æ•ˆç‡è®¡ç®—æ–¹æ³•
                        if (strongPrefetcher) {
                            // å¼ºé¢„å–å™¨çš„æ•ˆç‡ä½¿ç”¨å€’æ•°å…³ç³»æ›´åˆç†
                            prefetchEfficiency = largeStride.time / smallStride.time;
                            addResult(`ğŸ” æ£€æµ‹åˆ°å¼ºé¢„å–å™¨æ¨¡å¼ï¼Œä½¿ç”¨è°ƒæ•´åçš„è®¡ç®—æ–¹æ³•`, 'enhancement');
                        }
                    }
                } else if (validStrides.length >= 2) {
                    // è‡³å°‘æœ‰2ä¸ªæœ‰æ•ˆæµ‹è¯•ï¼Œä½¿ç”¨å¤‡ç”¨è®¡ç®—
                    const first = validStrides[0];
                    const last = validStrides[validStrides.length - 1];
                    prefetchEfficiency = first.time / last.time;
                    addResult(`âš ï¸ æ­¥é•¿æµ‹è¯•æ•°æ®æœ‰é™ï¼Œä½¿ç”¨${first.label}vs${last.label}è®¡ç®—`, 'limitation');
                } else {
                    // æµ‹è¯•æ•°æ®å¤ªå°‘
                    prefetchEfficiency = null;
                    addResult(`âŒ é¢„å–å™¨æµ‹è¯•å¤±æ•ˆ - æœ‰æ•ˆæ­¥é•¿æµ‹è¯•å°‘äº2ä¸ª`, 'limitation');
                }

                features.prefetch_efficiency = prefetchEfficiency;

                // ä¿å­˜Apple Siliconç‰¹æ®Šæ¶æ„ç‰¹å¾ï¼Œä¾›åç»­åˆ†æä½¿ç”¨
                // åœ¨è¿™ä¸ªé˜¶æ®µæš‚æ—¶è®¾ä¸ºfalseï¼Œä¼šåœ¨åŸºç¡€æ£€æµ‹ä¸­æ›´æ–°
                features.apple_memory_pattern = false;

                if (prefetchEfficiency && isFinite(prefetchEfficiency) && prefetchEfficiency > 0) {
                    // æ ¹æ®é¢„å–å™¨æ•ˆç‡ç»™å‡ºæ›´æœ‰æ„ä¹‰çš„è§£é‡Šï¼Œè€ƒè™‘å¼ºé¢„å–å™¨æ¨¡å¼
                    let interpretation = "";
                    let prefetchStrength = "";

                    if (strongPrefetcher) {
                        // å¼ºé¢„å–å™¨æ¨¡å¼ï¼šæ¯”å€¼è¶Šå°è¡¨ç¤ºé¢„å–å™¨è¶Šå¼º
                        if (prefetchEfficiency < 0.3) {
                            interpretation = " - è¶…å¼ºé¢„å–å™¨ï¼ˆApple Siliconçº§åˆ«ï¼‰";
                            prefetchStrength = "è¶…å¼º";
                        } else if (prefetchEfficiency < 0.6) {
                            interpretation = " - å¼ºé¢„å–å™¨ï¼ˆé«˜ç«¯CPUï¼‰";
                            prefetchStrength = "å¼º";
                        } else if (prefetchEfficiency < 1.0) {
                            interpretation = " - ä¸­ç­‰é¢„å–å™¨";
                            prefetchStrength = "ä¸­ç­‰";
                        } else {
                            interpretation = " - é¢„å–å™¨ä¸€èˆ¬";
                            prefetchStrength = "ä¸€èˆ¬";
                        }
                    } else {
                        // æ ‡å‡†æ¨¡å¼ï¼šä¼ ç»Ÿçš„è§£é‡Š
                        if (prefetchEfficiency < 0.5) {
                            interpretation = " - è¶…å¼ºé¢„å–å™¨";
                            prefetchStrength = "è¶…å¼º";
                        } else if (prefetchEfficiency < 1.0) {
                            interpretation = " - å¼ºé¢„å–å™¨";
                            prefetchStrength = "å¼º";
                        } else if (prefetchEfficiency < 3.0) {
                            interpretation = " - ä¸­ç­‰é¢„å–å™¨";
                            prefetchStrength = "ä¸­ç­‰";
                        } else if (prefetchEfficiency < 10.0) {
                            interpretation = " - é¢„å–å™¨æ•ˆæœä¸€èˆ¬";
                            prefetchStrength = "ä¸€èˆ¬";
                        } else {
                            interpretation = " - é¢„å–å™¨è¾ƒå¼±";
                            prefetchStrength = "å¼±";
                        }
                    }

                    features.prefetch_strength = prefetchStrength; // ä¿å­˜é¢„å–å™¨å¼ºåº¦
                    addResult(`ğŸ”® é¢„å–å™¨æ•ˆç‡: ${prefetchEfficiency.toFixed(2)}${interpretation}`, 'enhancement');
                } else {
                    addResult(`ğŸ”® é¢„å–å™¨æ•ˆç‡: æµ‹è¯•æ— æ•ˆ`, 'limitation');
                }

                // CPUå‹åŠ›ç‰¹å¾æµ‹è¯• - æµ‹è¯•å¤šæ ¸æ€§èƒ½é€€åŒ–æ›²çº¿
                addResult('ğŸ’ª CPUå‹åŠ›ç‰¹å¾æµ‹è¯•...', 'enhancement');
                const pressureTests = [];

                // åŸºå‡†æ€§èƒ½ï¼ˆæ— å‹åŠ›ï¼‰
                const baselineStart = performance.now();
                Module._integer_optimization_test(1000);
                const baselineTime = performance.now() - baselineStart;

                // è½»å‹åŠ›æµ‹è¯•ï¼ˆèƒŒæ™¯è®¡ç®—ï¼‰
                const lightPressureStart = performance.now();
                Module._float_precision_test(500); // èƒŒæ™¯æµ®ç‚¹è®¡ç®—
                Module._integer_optimization_test(1000);
                const lightPressureTime = performance.now() - lightPressureStart;

                // è®¡ç®—æ€§èƒ½é€€åŒ–ç‡
                const performanceDrop = baselineTime > 0 ? (lightPressureTime - baselineTime) / baselineTime : 0;
                features.pressure_resistance = Math.max(0, performanceDrop); // ç¡®ä¿éè´Ÿå€¼
                const dropPercent = isFinite(performanceDrop) ? (performanceDrop * 100).toFixed(1) : '0.0';
                addResult(`ğŸ“‰ å‹åŠ›ä¸‹æ€§èƒ½é€€åŒ–: ${dropPercent}% (å€¼è¶Šå°æŠ—å‹èƒ½åŠ›è¶Šå¼º)`, 'enhancement');

                // ç¼“å­˜å…³è”æ€§æµ‹è¯• - é’ˆå¯¹Apple Siliconä¼˜åŒ–ç²¾åº¦
                addResult('ğŸ”„ ç¼“å­˜å…³è”æ€§æµ‹è¯•...', 'enhancement');
                const conflictTests = [
                    { offset: 4096, label: '4KBé—´éš”', iterations: 8000, size: 256 },
                    { offset: 8192, label: '8KBé—´éš”', iterations: 6000, size: 512 },
                    { offset: 16384, label: '16KBé—´éš”', iterations: 4000, size: 512 },
                    { offset: 32768, label: '32KBé—´éš”', iterations: 3000, size: 1024 }
                ];

                let worstConflict = 0;
                let validConflictTests = 0;

                for (const test of conflictTests) {
                    // æ›´æ¿€è¿›çš„å¤šæ¬¡è¿è¡Œä»¥å…‹æœApple Siliconçš„ä¼˜åŒ–
                    const times = [];
                    for (let run = 0; run < 5; run++) {
                        // é¢„çƒ­è¿è¡Œé¿å…å†·å¯åŠ¨å½±å“
                        if (run === 0) {
                            Module._alignment_sensitivity_test(test.size, test.offset, test.iterations / 4);
                        }

                        const start = performance.now();
                        Module._alignment_sensitivity_test(test.size, test.offset, test.iterations);
                        const time = performance.now() - start;

                        // é™ä½ç²¾åº¦è¦æ±‚ï¼Œé€‚åº”Apple Siliconçš„é«˜æ•ˆç¼“å­˜
                        if (time > 0.05) times.push(time);
                    }

                    let finalTime = 0;
                    if (times.length >= 2) {
                        times.sort((a, b) => a - b);
                        finalTime = times[Math.floor(times.length / 2)]; // ä¸­ä½æ•°
                        validConflictTests++;
                    } else if (times.length === 1) {
                        finalTime = times[0];
                        validConflictTests++;
                    }

                    features[`conflict_${test.offset}`] = finalTime;

                    if (finalTime > 0.05 && baselineTime > 0.05) {
                        const conflictRatio = finalTime / baselineTime;
                        if (conflictRatio > worstConflict) worstConflict = conflictRatio;
                        addResult(`   ${test.label}: ${finalTime.toFixed(1)}ms (æ¯”ä¾‹${conflictRatio.toFixed(2)})`, 'enhancement');
                    } else {
                        addResult(`   ${test.label}: æµ‹è¯•ç²¾åº¦ä¸è¶³ (${finalTime.toFixed(3)}ms) - Apple Siliconç¼“å­˜å¯èƒ½è¿‡äºé«˜æ•ˆ`, 'limitation');
                    }
                }

                // éªŒè¯ç¼“å­˜å†²çªæµ‹è¯•çš„æœ‰æ•ˆæ€§
                if (validConflictTests >= 2 && worstConflict > 0.1) {
                    features.cache_conflict_sensitivity = worstConflict;
                    addResult(`âš¡ ç¼“å­˜å†²çªæ•æ„Ÿåº¦: ${worstConflict.toFixed(3)} (Intelé€šå¸¸<1.5, AMDå¯èƒ½>1.5)`, 'enhancement');
                } else {
                    features.cache_conflict_sensitivity = 1.0; // é»˜è®¤å€¼
                    addResult(`âš ï¸ ç¼“å­˜å†²çªæµ‹è¯•ç²¾åº¦ä¸è¶³ (æœ‰æ•ˆæµ‹è¯•${validConflictTests}ä¸ª)`, 'limitation');
                }

                // ç‰¹æ®Šè¿ç®—æŒ‡çº¹æµ‹è¯•
                addResult('ğŸ§® ç‰¹æ®Šè¿ç®—æŒ‡çº¹...', 'enhancement');

                // é™¤æ³•vsä¹˜æ³•æ€§èƒ½æ¯”
                const divStart = performance.now();
                for (let i = 0; i < 10000; i++) {
                    const result = (i * 12345) / 67890; // å¼ºåˆ¶é™¤æ³•è¿ç®—
                }
                const divTime = performance.now() - divStart;

                const mulStart = performance.now();
                for (let i = 0; i < 10000; i++) {
                    const result = i * 12345 * 67890; // çº¯ä¹˜æ³•è¿ç®—
                }
                const mulTime = performance.now() - mulStart;

                const divMulRatio = mulTime > 0.001 ? divTime / mulTime : 1.0;
                features.division_efficiency = isFinite(divMulRatio) ? divMulRatio : 1.0;
                const divDisplay = isFinite(divMulRatio) ? divMulRatio.toFixed(2) : '1.00';
                addResult(`â— é™¤æ³•æ•ˆç‡: ${divDisplay} (Intelé€šå¸¸<5, AMDå¯èƒ½>5)`, 'enhancement');

                addResult('ğŸ“Š è®¾å¤‡ç‰¹å¾ç­¾å:', 'cpu-info');

                // åˆ†ç»„æ˜¾ç¤ºå†…å­˜æµ‹è¯•ç»“æœï¼Œä¾¿äºè§‚å¯Ÿç¼“å­˜è¾¹ç•Œ
                addResult('ğŸ§  å†…å­˜è®¿é—®æ¨¡å¼ (å¯»æ‰¾ç¼“å­˜è¾¹ç•Œ):', 'cpu-info');
                const memoryTests = Object.entries(features)
                    .filter(([k, v]) => k.startsWith('mem_ratio'))
                    .sort((a, b) => {
                        const sizeA = parseInt(a[0].replace('mem_ratio_', '').replace('KB', ''));
                        const sizeB = parseInt(b[0].replace('mem_ratio_', '').replace('KB', ''));
                        return sizeA - sizeB;
                    });

                for (const [key, value] of memoryTests) {
                    const size = key.replace('mem_ratio_', '').replace('KB', '');
                    const color = value > 1.6 ? 'style="color: #f85149; font-weight: bold;"' :
                                  value > 1.4 ? 'style="color: #f0d000; font-weight: bold;"' :
                                  'style="color: #56d364;"';
                    addResult(`   ${size}KB: <span class="highlight" ${color}>${value.toFixed(4)}</span> ${value > 1.6 ? 'âš ï¸ ç¡®å®šçš„ç¼“å­˜è¾¹ç•Œ' : value > 1.4 ? 'ğŸ”¶ å¯èƒ½çš„è¾¹ç•Œ' : ''}`, 'cpu-info');
                }

                addResult('âš¡ è®¡ç®—æ€§èƒ½ç‰¹å¾:', 'cpu-info');
                const computeTests = Object.entries(features)
                    .filter(([k, v]) => !k.startsWith('mem_ratio'));

                for (const [key, value] of computeTests) {
                    if (typeof value === 'number' && isFinite(value)) {
                        addResult(`   ${key}: <span class="highlight">${value.toFixed(4)}</span>`, 'cpu-info');
                    }
                }

                // ç‰¹å¾å‘é‡åˆ†æ
                const signature = Object.values(features).filter(v => typeof v === 'number' && isFinite(v));
                let hash = 0;
                for (let i = 0; i < signature.length; i++) {
                    hash = ((hash << 5) - hash + signature[i] * 1000) & 0xffffffff;
                }

                addResult(`ğŸ”‘ è®¾å¤‡ç‰¹å¾å“ˆå¸Œ: <span class="highlight">${hash.toString(16)}</span>`, 'model-guess');

                // ç¼“å­˜è¾¹ç•Œåˆ†æç®—æ³•
                const memRatioEntries = Object.entries(features)
                    .filter(([k, v]) => k.startsWith('mem_ratio') && typeof v === 'number' && v > 0.5 && v < 20)
                    .map(([k, v]) => ({ size: parseInt(k.replace('mem_ratio_', '').replace('KB', '')), ratio: v }))
                    .sort((a, b) => a.size - b.size);

                // æ™ºèƒ½ç¼“å­˜è¾¹ç•Œæ£€æµ‹ç®—æ³•
                let cacheTransitions = [];
                let l1Boundary = null;
                let l2Boundary = null;
                let l3Boundary = null;

                for (let i = 1; i < memRatioEntries.length; i++) {
                    const prev = memRatioEntries[i-1];
                    const curr = memRatioEntries[i];
                    const jump = curr.ratio / prev.ratio;

                    // æ£€æµ‹æ˜¾è‘—çš„æ€§èƒ½è·³è·ƒ
                    if (jump > 1.5) {  // 50%ä»¥ä¸Šçš„æ€§èƒ½è·³è·ƒæ‰è®¤ä¸ºæ˜¯çœŸæ­£çš„ç¼“å­˜è¾¹ç•Œ
                        let boundaryType = "ç¼“å­˜è¾¹ç•Œ";

                        if (prev.size <= 128 && !l1Boundary) {
                            boundaryType = "L1ç¼“å­˜è¾¹ç•Œ";
                            l1Boundary = `${prev.size}KB`;
                        } else if (prev.size <= 1024 && !l2Boundary) {
                            boundaryType = "L2ç¼“å­˜è¾¹ç•Œ";
                            l2Boundary = `${prev.size}KB`;
                        } else if (prev.size <= 8192 && !l3Boundary) {
                            boundaryType = "L3ç¼“å­˜è¾¹ç•Œ";
                            l3Boundary = `${prev.size}KB`;
                        }

                        cacheTransitions.push({
                            from: prev.size,
                            to: curr.size,
                            jump: jump,
                            boundary: `${boundaryType}: ${prev.size}KB â†’ ${curr.size}KB`,
                            type: boundaryType
                        });
                    }
                }

                // è¡¥å……ï¼šå³ä½¿æ²¡æœ‰è·³è·ƒï¼Œä¹Ÿæ ¹æ®ç»éªŒé˜ˆå€¼åˆ¤æ–­
                const heavyRatios = memRatioEntries.filter(entry => entry.ratio > 2.0);
                if (heavyRatios.length > 0 && cacheTransitions.length === 0) {
                    const firstHeavy = heavyRatios[0];
                    cacheTransitions.push({
                        boundary: `ç–‘ä¼¼ç¼“å­˜è¾¹ç•Œ: ${firstHeavy.size}KB (æ¯”ä¾‹${firstHeavy.ratio.toFixed(2)})`,
                        type: "æ¨æµ‹è¾¹ç•Œ"
                    });
                }

                addResult('ğŸ” ç¼“å­˜è¾¹ç•Œåˆ†æ:', 'model-guess');
                if (cacheTransitions.length > 0) {
                    for (const transition of cacheTransitions) {
                        addResult(`   ${transition.boundary} (æ€§èƒ½è·³è·ƒ${transition.jump.toFixed(2)}x)`, 'model-guess');
                    }
                } else {
                    addResult('   æœªå‘ç°æ˜æ˜¾çš„ç¼“å­˜æ€§èƒ½è¾¹ç•Œ', 'model-guess');
                }

                const validMemRatios = memRatioEntries.map(entry => entry.ratio);
                const memAvg = validMemRatios.length > 0 ?
                    validMemRatios.reduce((sum, v) => sum + v, 0) / validMemRatios.length : 1.0;

                // åŸºäºçœŸå®ç¼“å­˜æµ‹è¯•çš„CPUè¯†åˆ«ç®—æ³•
                let modelGuess = "æœªçŸ¥å‹å·";
                let confidence = "ä½";
                let evidencePoints = [];

                if (validMemRatios.length >= 5) {
                    // åˆ†æL1ç¼“å­˜å¤§å°
                    const l1Ratios = memRatioEntries.filter(e => e.size <= 128).map(e => e.ratio);
                    const l2Ratios = memRatioEntries.filter(e => e.size >= 256 && e.size <= 1024).map(e => e.ratio);
                    const l3Ratios = memRatioEntries.filter(e => e.size >= 2048).map(e => e.ratio);

                    const avgL1 = l1Ratios.length > 0 ? l1Ratios.reduce((a, b) => a + b) / l1Ratios.length : 1.0;
                    const avgL2 = l2Ratios.length > 0 ? l2Ratios.reduce((a, b) => a + b) / l2Ratios.length : 1.0;
                    const avgL3 = l3Ratios.length > 0 ? l3Ratios.reduce((a, b) => a + b) / l3Ratios.length : 1.0;

                    addResult(`ğŸ“Š ç¼“å­˜å±‚çº§åˆ†æ: L1å¹³å‡=${avgL1.toFixed(3)}, L2å¹³å‡=${avgL2.toFixed(3)}, L3å¹³å‡=${avgL3.toFixed(3)}`, 'model-guess');

                    // æ¸…ç†ç‰ˆCPUç‰¹å¾æ£€æµ‹ç®—æ³•
                    let score = { apple: 0, intel: 0, amd: 0 };
                    let featureLog = []; // è®°å½•æ‰€æœ‰ç‰¹å¾åˆ†æ

                    // Apple Siliconç‰¹å¾è¯„åˆ† (é’ˆå¯¹M4 Proä¼˜åŒ–)
                    const hasLargeL1 = (avgL1 < 1.2 && l1Ratios.some((_, i, arr) => i < arr.length - 1 && arr[i + 1] / arr[i] > 1.4));
                    const hasReversedStride = features.prefetch_efficiency && (features.prefetch_efficiency > 15 && features.prefetch_efficiency < 25);
                    const hasUnifiedMemory = avgL3 > 1.7 && avgL3 < 1.9;
                    const hasLowPressureDrop = features.pressure_resistance < 0.3;
                    const hasAppleCache = avgL1 < 1.2 && avgL2 > 1.7; // Appleç‹¬ç‰¹ç¼“å­˜ç‰¹å¾

                    if (hasLargeL1) {
                        score.apple += 2;
                        featureLog.push("âœ“ å¤§L1ç¼“å­˜ç‰¹å¾ (+2 Apple)");
                    }
                    if (hasReversedStride) {
                        score.apple += 3;
                        featureLog.push("âœ“ é¢„å–å™¨åå‘ç‰¹å¾ (+3 Apple)");
                    }
                    if (hasUnifiedMemory) {
                        score.apple += 2;
                        featureLog.push("âœ“ ç»Ÿä¸€å†…å­˜æ¶æ„ (+2 Apple)");
                    }
                    if (hasLowPressureDrop) {
                        score.apple += 1;
                        featureLog.push("âœ“ æŠ—å‹èƒ½åŠ›å¼º (+1 Apple)");
                    }
                    if (hasAppleCache) {
                        score.apple += 3;
                        featureLog.push("âœ“ Appleç‹¬ç‰¹ç¼“å­˜æ¶æ„ (+3 Apple)");
                    }

                    // Intelç‰¹å¾è¯„åˆ† (é™ä½æƒé‡é¿å…ä¸Appleæ··æ·†)
                    const hasTypicalL2 = avgL2 > 1.5 && avgL2 < 1.9 && avgL1 > 1.3; // å¿…é¡»L1ä¹Ÿç¬¦åˆIntelç‰¹å¾
                    const hasGoodDivision = features.division_efficiency && features.division_efficiency < 4 && avgL1 > 1.3;
                    const hasLowConflict = features.cache_conflict_sensitivity < 1.5;
                    const hasPositiveInt = features.integer_opt > 0;

                    // åªæœ‰åœ¨éAppleç‰¹å¾æ—¶æ‰ç»™IntelåŠ åˆ†
                    const isNotApple = !hasAppleCache && avgL1 > 1.3;

                    if (hasTypicalL2 && isNotApple) {
                        score.intel += 2;
                        featureLog.push("âœ“ å…¸å‹L2ç¼“å­˜ç‰¹å¾ (+2 Intel)");
                    }
                    if (hasGoodDivision && isNotApple) {
                        score.intel += 2;
                        featureLog.push("âœ“ é™¤æ³•å•å…ƒé«˜æ•ˆ (+2 Intel)");
                    }
                    if (hasLowConflict && isNotApple) {
                        score.intel += 1;
                        featureLog.push("âœ“ ä½ç¼“å­˜å†²çª (+1 Intel)");
                    }
                    if (hasPositiveInt && isNotApple) {
                        score.intel += 1;
                        featureLog.push("âœ“ æ•´æ•°ä¼˜åŒ–æ­£å‘ (+1 Intel)");
                    }

                    // AMDç‰¹å¾è¯„åˆ†
                    const hasStrongL3 = avgL3 > 1.8;
                    const hasPoorDivision = features.division_efficiency && features.division_efficiency > 5;
                    const hasHighConflict = features.cache_conflict_sensitivity > 1.5;
                    const hasNegativeInt = features.integer_opt < 0;

                    if (hasStrongL3) {
                        score.amd += 2;
                        featureLog.push("âœ“ å¼ºL3ç¼“å­˜ç‰¹å¾ (+2 AMD)");
                    }
                    if (hasPoorDivision) {
                        score.amd += 2;
                        featureLog.push("âœ“ é™¤æ³•ç›¸å¯¹è¾ƒæ…¢ (+2 AMD)");
                    }
                    if (hasHighConflict) {
                        score.amd += 1;
                        featureLog.push("âœ“ ç¼“å­˜å†²çªæ•æ„Ÿ (+1 AMD)");
                    }
                    if (hasNegativeInt) {
                        score.amd += 1;
                        featureLog.push("âœ“ ç‰¹æ®Šæ•´æ•°ç‰¹å¾ (+1 AMD)");
                    }

                    // æ ¹æ®å¾—åˆ†ç¡®å®šç»“æœ
                    const maxScore = Math.max(score.apple, score.intel, score.amd);

                    if (maxScore >= 5) {
                        confidence = "é«˜";
                    } else if (maxScore >= 3) {
                        confidence = "ä¸­";
                    } else {
                        confidence = "ä½";
                    }

                    // æ¸…ç†evidencePointsï¼Œåªæ˜¾ç¤ºè·èƒœæ–¹çš„ç‰¹å¾
                    evidencePoints = [];

                    if (score.apple === maxScore && maxScore >= 3) {
                        modelGuess = "Apple Silicon (M1/M2/M3ç³»åˆ—)";
                        evidencePoints.push(`Appleç‰¹å¾å¾—åˆ†: ${score.apple}åˆ†`);
                        evidencePoints.push(...featureLog.filter(log => log.includes("Apple")));
                    } else if (score.intel === maxScore && maxScore >= 3) {
                        modelGuess = "Intelé«˜æ€§èƒ½CPU (Core i5/i7/i9)";
                        evidencePoints.push(`Intelç‰¹å¾å¾—åˆ†: ${score.intel}åˆ†`);
                        evidencePoints.push(...featureLog.filter(log => log.includes("Intel")));
                    } else if (score.amd === maxScore && maxScore >= 3) {
                        modelGuess = "AMD Ryzenç³»åˆ—";
                        evidencePoints.push(`AMDç‰¹å¾å¾—åˆ†: ${score.amd}åˆ†`);
                        evidencePoints.push(...featureLog.filter(log => log.includes("AMD")));
                    } else {
                        modelGuess = "ç°ä»£é«˜æ€§èƒ½CPU (ç±»å‹ä¸ç¡®å®š)";
                        evidencePoints.push(`å¾—åˆ†è¾ƒä½: Apple=${score.apple}, Intel=${score.intel}, AMD=${score.amd}`);
                        evidencePoints.push(...featureLog.slice(0, 3)); // åªæ˜¾ç¤ºå‰3ä¸ªç‰¹å¾
                    }

                    // é¢„å–å™¨åˆ†æå¢å¼ºç½®ä¿¡åº¦
                    if (features.prefetch_efficiency) {
                        if (features.prefetch_efficiency < 1.0) {
                            evidencePoints.push("è¶…å¼ºé¢„å–å™¨ (å¯èƒ½æ˜¯Apple/é«˜ç«¯Intel)");
                            if (confidence === "ä¸­") confidence = "é«˜";
                        } else if (features.prefetch_efficiency > 10) {
                            evidencePoints.push("é¢„å–å™¨æ•ˆæœä¸€èˆ¬ (å¯èƒ½æ˜¯AMD/ä¸»æµCPU)");
                        }
                    }

                } else {
                    modelGuess = "æµ‹è¯•æ•°æ®ä¸è¶³ï¼Œæ— æ³•å‡†ç¡®åˆ†æ";
                    confidence = "å¾ˆä½";
                }

                addResult(`ğŸ¯ å‹å·æ¨æµ‹: <span class="highlight">${modelGuess}</span>`, 'model-guess');
                addResult(`ğŸ“Š ç½®ä¿¡åº¦: <span class="highlight">${confidence}</span> (åŸºäº${validMemRatios.length}ä¸ªæœ‰æ•ˆç‰¹å¾)`, 'model-guess');

                // æ˜¾ç¤ºè¯æ®ç‚¹
                if (evidencePoints.length > 0) {
                    addResult('ğŸ” è¯†åˆ«ä¾æ®:', 'model-guess');
                    for (const evidence of evidencePoints) {
                        addResult(`   â€¢ ${evidence}`, 'model-guess');
                    }
                }

                addResult('âš ï¸ æ³¨æ„: è¿™åªæ˜¯åŸºäºæœ‰é™ç‰¹å¾çš„æ¨æµ‹ï¼Œå®é™…å‡†ç¡®æ€§å—å¤šç§å› ç´ å½±å“', 'limitation');

                // æ‰§è¡Œç»“æœéªŒè¯
                const validation = validateTestResults(features);
                if (validation.issues.length > 0 || validation.warnings.length > 0) {
                    addResult('ğŸ” æµ‹è¯•è´¨é‡è¯„ä¼°:', 'enhancement');

                    if (validation.issues.length > 0) {
                        addResult('âŒ å‘ç°çš„é—®é¢˜:', 'limitation');
                        validation.issues.forEach(issue => {
                            addResult(`   â€¢ ${issue}`, 'limitation');
                        });
                    }

                    if (validation.warnings.length > 0) {
                        addResult('âš ï¸ è­¦å‘Š:', 'limitation');
                        validation.warnings.forEach(warning => {
                            addResult(`   â€¢ ${warning}`, 'limitation');
                        });
                    }

                    // è®¡ç®—æµ‹è¯•è´¨é‡åˆ†æ•°
                    const qualityScore = Math.max(0, 100 - validation.issues.length * 20 - validation.warnings.length * 10);
                    let qualityLevel;
                    if (qualityScore >= 80) qualityLevel = "ä¼˜ç§€";
                    else if (qualityScore >= 60) qualityLevel = "è‰¯å¥½";
                    else if (qualityScore >= 40) qualityLevel = "ä¸€èˆ¬";
                    else qualityLevel = "è¾ƒå·®";

                    addResult(`ğŸ“Š æµ‹è¯•è´¨é‡è¯„åˆ†: ${qualityScore}/100 (${qualityLevel})`, 'enhancement');
                } else {
                    addResult('âœ… æµ‹è¯•è´¨é‡: ä¼˜ç§€ (æœªå‘ç°æ˜æ˜¾é—®é¢˜)', 'enhancement');
                }

            } catch (error) {
                addResult(`âŒ ç‰¹å¾åˆ†æå¤±è´¥: ${error.message}`, 'limitation');
            }
        }

        // WebGLæ£€æµ‹å‡½æ•°
        async function runWebGLDetection() {
            try {
                addResult('=== ğŸ¨ WebGL GPUæ£€æµ‹ ===', 'enhancement');

                const webglFP = new WebGLFingerprinter();
                const fingerprint = await webglFP.generateFingerprint();

                if (!fingerprint) {
                    addResult('â„¹ï¸ WebGLä¸å¯ç”¨: æµè§ˆå™¨ä¸æ”¯æŒæˆ–å·²ç¦ç”¨', 'model-guess');
                    return;
                }

                addResult('ğŸ” GPUåŸºç¡€ä¿¡æ¯:', 'cpu-info');
                addResult(`   å‚å•†: ${fingerprint.basic.vendor}`, 'cpu-info');
                addResult(`   æ¸²æŸ“å™¨: ${fingerprint.basic.renderer}`, 'cpu-info');
                addResult(`   ç‰ˆæœ¬: ${fingerprint.basic.version}`, 'cpu-info');

                addResult('ğŸ“Š æ‰©å±•æ”¯æŒ:', 'cpu-info');
                addResult(`   æ€»æ‰©å±•æ•°: ${fingerprint.extensions.count}`, 'cpu-info');
                addResult(`   é‡è¦æ‰©å±•: ${fingerprint.extensions.important.length}`, 'cpu-info');

                addResult('ğŸ¯ CanvasæŒ‡çº¹:', 'cpu-info');
                addResult(`   å“ˆå¸Œå€¼: ${fingerprint.canvasHash}`, 'cpu-info');

                if (fingerprint.performance) {
                    addResult('âš¡ æ¸²æŸ“æ€§èƒ½:', 'cpu-info');
                    addResult(`   ç®€å•æ¸²æŸ“: ${fingerprint.performance.simpleRender?.toFixed(2)}ms`, 'cpu-info');
                    addResult(`   å¤æ‚æ¸²æŸ“: ${fingerprint.performance.complexRender?.toFixed(2)}ms`, 'cpu-info');
                    addResult(`   çº¹ç†æ“ä½œ: ${fingerprint.performance.textureOps?.toFixed(2)}ms`, 'cpu-info');
                }

                // GPUå‹å·åˆ†æ
                const analysis = webglFP.analyzeGPUModel(fingerprint);
                addResult('ğŸ¯ WebGL GPUå‹å·æ¨æµ‹:', 'model-guess');
                addResult(`   å‹å·: ${analysis.model}`, 'model-guess');
                addResult(`   ç½®ä¿¡åº¦: ${analysis.confidence}%`, 'model-guess');
                if (analysis.evidence.length > 0) {
                    addResult('   æ¨æµ‹ä¾æ®:', 'model-guess');
                    analysis.evidence.forEach(evidence => {
                        addResult(`     â€¢ ${evidence}`, 'model-guess');
                    });
                }

                webglFP.cleanup();

            } catch (error) {
                addResult(`âš ï¸ WebGLæ£€æµ‹å¼‚å¸¸: ${error.message}`, 'limitation');
            }
        }

        // WebGPUæ£€æµ‹å‡½æ•°
        async function runWebGPUDetection() {
            try {
                addResult('=== âš¡ WebGPU GPUæ£€æµ‹ ===', 'enhancement');

                const webgpuFP = new WebGPUFingerprinter();
                const fingerprint = await webgpuFP.generateFingerprint();

                if (!fingerprint) {
                    addResult('â„¹ï¸ WebGPUä¸å¯ç”¨: æµè§ˆå™¨ä¸æ”¯æŒæˆ–å·²ç¦ç”¨', 'model-guess');
                    return;
                }

                addResult('ğŸ” GPUé€‚é…å™¨ä¿¡æ¯:', 'cpu-info');
                const adapter = fingerprint.adapter;
                addResult(`   å‚å•†: ${adapter.vendor || 'æœªçŸ¥'}`, 'cpu-info');
                addResult(`   æ¶æ„: ${adapter.architecture || 'æœªçŸ¥'}`, 'cpu-info');
                addResult(`   è®¾å¤‡: ${adapter.device || 'æœªçŸ¥'}`, 'cpu-info');
                addResult(`   æè¿°: ${adapter.description || 'æœªçŸ¥'}`, 'cpu-info');
                if (adapter.subgroupMaxSize) {
                    addResult(`   å­ç»„å¤§å°: ${adapter.subgroupMinSize}-${adapter.subgroupMaxSize}`, 'cpu-info');
                }

                addResult('ğŸ’ª GPUèƒ½åŠ›:', 'cpu-info');
                const caps = fingerprint.capabilities;
                addResult(`   æ”¯æŒç‰¹æ€§: ${caps.features?.length || 0}ä¸ª`, 'cpu-info');
                if (caps.limits) {
                    addResult(`   æœ€å¤§çº¹ç†å°ºå¯¸: ${caps.limits.maxTextureSize}`, 'cpu-info');
                    addResult(`   æœ€å¤§ç¼“å†²åŒº: ${caps.limits.maxBufferSize}å­—èŠ‚`, 'cpu-info');
                    addResult(`   æœ€å¤§å·¥ä½œç»„: ${caps.limits.maxComputeWorkgroupSizeX}`, 'cpu-info');
                }

                if (fingerprint.timing) {
                    addResult('â±ï¸ GPUæ€§èƒ½åˆ†æ:', 'cpu-info');

                    if (fingerprint.timing.timerResolution) {
                        const timer = fingerprint.timing.timerResolution;
                        addResult(`   è®¡æ—¶å™¨åˆ†è¾¨ç‡: ${timer.average?.toFixed(3)}ms (Â±${timer.standardDeviation?.toFixed(3)})`, 'cpu-info');
                    }

                    if (fingerprint.timing.memoryBandwidth) {
                        const mem = fingerprint.timing.memoryBandwidth;
                        addResult(`   å†…å­˜å¸¦å®½: ${mem.bandwidth?.toFixed(2)} GB/s`, 'cpu-info');
                    }

                    if (fingerprint.timing.computeLatency) {
                        const compute = fingerprint.timing.computeLatency;
                        addResult(`   ç®€å•è®¡ç®—: ${compute.simple?.toFixed(2)}ms`, 'cpu-info');
                        addResult(`   æ•°å­¦å¯†é›†: ${compute.math_intensive?.toFixed(2)}ms`, 'cpu-info');
                        addResult(`   å†…å­˜å¯†é›†: ${compute.memory_intensive?.toFixed(2)}ms`, 'cpu-info');
                    }

                    if (fingerprint.timing.cacheProfile) {
                        const cache = fingerprint.timing.cacheProfile;
                        addResult(`   ç¼“å­˜æ•ˆç‡: ${cache.cacheEfficiency?.toFixed(2)}`, 'cpu-info');
                    }
                }

                // GPUå‹å·åˆ†æ
                const analysis = webgpuFP.analyzeGPUModel(fingerprint);
                addResult('ğŸ¯ WebGPU GPUå‹å·æ¨æµ‹:', 'model-guess');
                addResult(`   å‹å·: ${analysis.model}`, 'model-guess');
                addResult(`   ç½®ä¿¡åº¦: ${analysis.confidence}%`, 'model-guess');
                if (analysis.evidence.length > 0) {
                    addResult('   æ¨æµ‹ä¾æ®:', 'model-guess');
                    analysis.evidence.forEach(evidence => {
                        addResult(`     â€¢ ${evidence}`, 'model-guess');
                    });
                }

                webgpuFP.cleanup();

            } catch (error) {
                addResult(`âš ï¸ WebGPUæ£€æµ‹å¼‚å¸¸: ${error.message}`, 'limitation');
            }
        }

        // ä¸‰é‡æ£€æµ‹å‡½æ•° - æ ¸å¿ƒåŠŸèƒ½
        async function runTripleDetection() {
            try {
                addResult('=== ğŸš€ ä¸‰é‡æ£€æµ‹ç³»ç»Ÿå¯åŠ¨ ===', 'enhancement');
                addResult('æ­£åœ¨æ‰§è¡Œ WASM + WebGL + WebGPU ç»¼åˆæ£€æµ‹...', 'enhancement');

                // 1. WASM CPUæ£€æµ‹
                addResult('ğŸ”§ ç¬¬ä¸€é˜¶æ®µ: WASM CPUå¾®æ¶æ„æ£€æµ‹', 'cpu-info');
                const Module = await initWASM();

                // ç®€åŒ–çš„CPUç‰¹å¾æå–ï¼ˆå¤ç”¨ç°æœ‰ä»£ç ï¼‰
                const cpuFeatures = await extractCPUFeatures(Module);
                addResult(`âœ“ CPUç‰¹å¾: ${cpuFeatures.model} (ç½®ä¿¡åº¦: ${cpuFeatures.confidence}%)`, 'cpu-info');

                // 2. WebGL GPUæ£€æµ‹
                addResult('ğŸ¨ ç¬¬äºŒé˜¶æ®µ: WebGL GPUæ£€æµ‹', 'enhancement');
                const webglFP = new WebGLFingerprinter();
                const webglFingerprint = await webglFP.generateFingerprint();
                const webglAnalysis = webglFingerprint ? webglFP.analyzeGPUModel(webglFingerprint) : null;

                if (webglAnalysis) {
                    addResult(`âœ“ WebGL GPU: ${webglAnalysis.model} (ç½®ä¿¡åº¦: ${webglAnalysis.confidence}%)`, 'enhancement');
                } else {
                    addResult('âœ— WebGLæ£€æµ‹å¤±è´¥', 'limitation');
                }

                // 3. WebGPUæ£€æµ‹
                addResult('âš¡ ç¬¬ä¸‰é˜¶æ®µ: WebGPUé«˜çº§æ£€æµ‹', 'enhancement');
                const webgpuFP = new WebGPUFingerprinter();
                const webgpuFingerprint = await webgpuFP.generateFingerprint();
                const webgpuAnalysis = webgpuFingerprint ? webgpuFP.analyzeGPUModel(webgpuFingerprint) : null;

                if (webgpuAnalysis) {
                    addResult(`âœ“ WebGPU GPU: ${webgpuAnalysis.model} (ç½®ä¿¡åº¦: ${webgpuAnalysis.confidence}%)`, 'enhancement');
                } else {
                    addResult('âœ— WebGPUæ£€æµ‹å¤±è´¥', 'limitation');
                }

                // 4. ç»¼åˆåˆ†æå’Œè®¾å¤‡è¯†åˆ«
                addResult('ğŸ§  ç¬¬å››é˜¶æ®µ: ç»¼åˆåˆ†æä¸è®¾å¤‡è¯†åˆ«', 'model-guess');

                // åˆå§‹åŒ–è®¾å¤‡æ•°æ®åº“
                if (!deviceDatabase) {
                    deviceDatabase = new DeviceSignatureDatabase();
                }

                // ä½¿ç”¨æ•°æ®åº“è¿›è¡Œç²¾ç¡®è¯†åˆ«
                const databaseResult = deviceDatabase.identifyDevice(cpuFeatures, webglAnalysis, webgpuAnalysis);
                const deviceIdentification = enhanceWithDatabase(cpuFeatures, webglAnalysis, webgpuAnalysis, databaseResult);

                addResult('ğŸ¯ æœ€ç»ˆè®¾å¤‡è¯†åˆ«ç»“æœ:', 'model-guess');
                addResult(`   è®¾å¤‡å‹å·: ${deviceIdentification.deviceModel}`, 'model-guess');
                addResult(`   CPUå‹å·: ${deviceIdentification.cpuModel}`, 'model-guess');
                addResult(`   GPUå‹å·: ${deviceIdentification.gpuModel}`, 'model-guess');
                addResult(`   ç»¼åˆç½®ä¿¡åº¦: ${deviceIdentification.confidence}%`, 'model-guess');

                addResult('ğŸ” è¯†åˆ«ä¾æ®:', 'model-guess');
                deviceIdentification.evidence.forEach(evidence => {
                    addResult(`   â€¢ ${evidence}`, 'model-guess');
                });

                // æ¸…ç†
                if (webglFP) webglFP.cleanup();
                if (webgpuFP) webgpuFP.cleanup();

            } catch (error) {
                addResult(`âŒ ä¸‰é‡æ£€æµ‹å¤±è´¥: ${error.message}`, 'limitation');
            }
        }

        // æå–CPUç‰¹å¾ï¼ˆç®€åŒ–ç‰ˆï¼‰
        async function extractCPUFeatures(Module) {
            try {
                // å¤ç”¨ç°æœ‰çš„åˆ†æé€»è¾‘ï¼Œä½†ç®€åŒ–è¾“å‡º
                const seqTest = timedTest(Module._sequential_access_test.bind(Module), 16, 1000);
                const randTest = timedTest(Module._random_access_test.bind(Module), 16, 1000);

                const memRatio = randTest.time > 0.001 && seqTest.time > 0.001 ?
                    randTest.time / seqTest.time : 1.0;

                let cpuClass = "æœªçŸ¥æ¶æ„";
                let confidence = 50;

                if (typeof memRatio === 'number') {
                    // ç»Ÿä¸€ä½¿ç”¨ä¸å¿«é€Ÿæ£€æµ‹å®Œå…¨ç›¸åŒçš„é˜ˆå€¼ï¼Œç¡®ä¿ä¸€è‡´æ€§
                    if (memRatio >= 0.5 && memRatio < 1.6) {  // ä¸runCPUDetectionå®Œå…¨ä¸€è‡´
                        cpuClass = "Apple Silicon";
                        confidence = 85;
                    } else if (memRatio >= 1.6 && memRatio <= 2.5) {
                        cpuClass = "Intelé«˜æ€§èƒ½CPU";
                        confidence = 80;
                    } else if (memRatio > 2.5 && memRatio <= 4.0) {
                        cpuClass = "AMD Ryzenæˆ–ä¸»æµCPU";
                        confidence = 75;
                    }
                }

                return { model: cpuClass, confidence, memRatio };

            } catch (error) {
                return { model: "æ£€æµ‹å¤±è´¥", confidence: 0, memRatio: 0 };
            }
        }

        // æ—¶é—´æµ‹è¯•å‡½æ•°
        function timedTest(testFunc, ...args) {
            const startTime = performance.now();
            const result = testFunc(...args);
            const endTime = performance.now();
            return { result, time: endTime - startTime };
        }

        // ç»¼åˆè®¾å¤‡è¯†åˆ«åˆ†æ
        function analyzeDeviceIdentity(cpuFeatures, webglAnalysis, webgpuAnalysis) {
            const evidence = [];
            let deviceModel = "æœªçŸ¥è®¾å¤‡";
            let cpuModel = cpuFeatures.model;
            let gpuModel = "æœªçŸ¥GPU";
            let confidence = 0;

            // ç¡®å®šGPUå‹å·
            if (webgpuAnalysis && webgpuAnalysis.confidence > 70) {
                gpuModel = webgpuAnalysis.model;
                evidence.push(`WebGPUé«˜ç½®ä¿¡åº¦è¯†åˆ«: ${gpuModel}`);
            } else if (webglAnalysis && webglAnalysis.confidence > 60) {
                gpuModel = webglAnalysis.model;
                evidence.push(`WebGLè¯†åˆ«: ${gpuModel}`);
            }

            // åŸºäºCPU+GPUç»„åˆè¯†åˆ«å…·ä½“è®¾å¤‡
            if (cpuFeatures.model.includes("Apple Silicon")) {
                if (gpuModel.includes("Apple") || gpuModel.includes("M1") || gpuModel.includes("M2") || gpuModel.includes("M3")) {
                    // Appleè®¾å¤‡ç²¾ç¡®è¯†åˆ«
                    if (gpuModel.includes("M1 Pro") || gpuModel.includes("M1 Max")) {
                        deviceModel = "MacBook Pro (M1 Pro/Max)";
                        confidence = 95;
                    } else if (gpuModel.includes("M2")) {
                        deviceModel = "MacBook (M2 ç³»åˆ—)";
                        confidence = 92;
                    } else if (gpuModel.includes("M1")) {
                        deviceModel = "MacBook/iMac (M1)";
                        confidence = 90;
                    } else {
                        deviceModel = "Apple Silicon è®¾å¤‡";
                        confidence = 85;
                    }
                    evidence.push("CPUå’ŒGPUç‰¹å¾å®Œå…¨åŒ¹é…Appleç”Ÿæ€");
                } else {
                    deviceModel = "Appleè®¾å¤‡ (GPUè¯†åˆ«å¼‚å¸¸)";
                    confidence = 70;
                    evidence.push("CPUæ˜¯Apple Siliconä½†GPUè¯†åˆ«ä¸åŒ¹é…");
                }
            }
            else if (cpuFeatures.model.includes("Intel")) {
                if (gpuModel.includes("Intel")) {
                    deviceModel = "Intelå¹³å° (é›†æˆæ˜¾å¡)";
                    confidence = 85;
                    evidence.push("Intel CPU + Intel GPUç»„åˆ");
                } else if (gpuModel.includes("NVIDIA") || gpuModel.includes("RTX") || gpuModel.includes("GTX")) {
                    deviceModel = "Intelå¹³å° + NVIDIAç‹¬æ˜¾";
                    confidence = 90;
                    evidence.push("Intel CPU + NVIDIA GPUç»„åˆ");
                } else if (gpuModel.includes("AMD") || gpuModel.includes("Radeon")) {
                    deviceModel = "Intelå¹³å° + AMDç‹¬æ˜¾";
                    confidence = 88;
                    evidence.push("Intel CPU + AMD GPUç»„åˆ");
                } else {
                    deviceModel = "Intelå¹³å°";
                    confidence = 75;
                }
            }
            else if (cpuFeatures.model.includes("AMD")) {
                if (gpuModel.includes("AMD") || gpuModel.includes("Radeon")) {
                    deviceModel = "AMDå…¨å®¶æ¡¶å¹³å°";
                    confidence = 90;
                    evidence.push("AMD CPU + AMD GPUç»„åˆ");
                } else if (gpuModel.includes("NVIDIA")) {
                    deviceModel = "AMD CPU + NVIDIA GPU";
                    confidence = 88;
                    evidence.push("AMD CPU + NVIDIA GPUç»„åˆ");
                } else {
                    deviceModel = "AMDå¹³å°";
                    confidence = 75;
                }
            }
            else {
                deviceModel = "æ— æ³•ç¡®å®šè®¾å¤‡å‹å·";
                confidence = 30;
                evidence.push("CPUå’ŒGPUè¯†åˆ«ç½®ä¿¡åº¦éƒ½è¾ƒä½");
            }

            // æ·»åŠ æ£€æµ‹æ–¹æ³•è¯´æ˜
            evidence.push(`CPUå†…å­˜æ¯”ä¾‹: ${cpuFeatures.memRatio?.toFixed(3) || 'æœªçŸ¥'}`);

            if (webglAnalysis) {
                evidence.push(`WebGL renderer: ${webglAnalysis.rawRenderer || 'æœªçŸ¥'}`);
            }

            if (webgpuAnalysis) {
                evidence.push(`WebGPU vendor: ${webgpuAnalysis.rawAdapter?.vendor || 'æœªçŸ¥'}`);
            }

            return {
                deviceModel,
                cpuModel,
                gpuModel,
                confidence,
                evidence
            };
        }

        // ä¼˜åŒ–çš„è®¾å¤‡è¯†åˆ«åˆ†æ
        function analyzeDeviceIdentity(cpuFeatures, webglAnalysis, webgpuAnalysis) {
            let deviceModel = "æœªçŸ¥è®¾å¤‡";
            let cpuModel = cpuFeatures.model;
            let gpuModel = "æœªçŸ¥GPU";
            let confidence = 30;
            const evidence = [];

            // 1. GPUæ£€æµ‹ä¼˜å…ˆçº§æœ€é«˜ï¼ˆApple Siliconå¯ä»¥æ˜ç¡®è¯†åˆ«GPUå‹å·ï¼‰
            if (webgpuAnalysis && webgpuAnalysis.confidence >= 90) {
                if (webgpuAnalysis.model.includes("M4 Pro")) {
                    deviceModel = "Apple Silicon è®¾å¤‡";
                    cpuModel = "Apple M4 Pro";
                    gpuModel = webgpuAnalysis.model;
                    confidence = Math.max(90, webgpuAnalysis.confidence);
                    evidence.push(`WebGPUé«˜ç½®ä¿¡åº¦è¯†åˆ«: ${webgpuAnalysis.model}`);
                    evidence.push("CPUå’ŒGPUç‰¹å¾å®Œå…¨åŒ¹é…Appleç”Ÿæ€");
                } else if (webgpuAnalysis.model.includes("Apple")) {
                    deviceModel = "Apple Silicon è®¾å¤‡";
                    cpuModel = "Apple Silicon";
                    gpuModel = webgpuAnalysis.model;
                    confidence = Math.max(85, webgpuAnalysis.confidence);
                    evidence.push(`WebGPUè¯†åˆ«Apple GPU: ${webgpuAnalysis.model}`);
                }
            }

            // 2. WebGLä½œä¸ºè¡¥å……éªŒè¯
            if (webglAnalysis && webglAnalysis.confidence >= 85) {
                if (webglAnalysis.model.includes("Apple") || webglAnalysis.model.includes("Metal")) {
                    if (confidence < 80) {
                        deviceModel = "Apple Silicon è®¾å¤‡";
                        cpuModel = "Apple Silicon";
                        confidence = Math.max(confidence, 80);
                    }
                    evidence.push(`WebGLè¯†åˆ«: ${webglAnalysis.model}`);
                }
            }

            // 3. CPUç‰¹å¾ä½œä¸ºæœ€ç»ˆéªŒè¯ï¼ˆé™ä½æƒé‡é¿å…å¹²æ‰°ï¼‰
            if (cpuFeatures.model && cpuFeatures.confidence >= 70) {
                if (cpuFeatures.model.includes("Apple")) {
                    // å¦‚æœGPUå·²ç»è¯†åˆ«ä¸ºAppleï¼Œå¢å¼ºç½®ä¿¡åº¦
                    if (deviceModel.includes("Apple")) {
                        confidence = Math.min(95, confidence + 5);
                        evidence.push("WASM CPUç‰¹å¾ç¡®è®¤Appleæ¶æ„");
                    } else {
                        // GPUæ²¡è¯†åˆ«å‡ºAppleï¼Œä½†CPUè¯†åˆ«å‡ºæ¥äº†
                        deviceModel = "Apple Silicon è®¾å¤‡";
                        cpuModel = cpuFeatures.model;
                        confidence = Math.max(confidence, cpuFeatures.confidence);
                        evidence.push(`WASMè¯†åˆ«: ${cpuFeatures.model}`);
                    }
                }
            }

            // 4. æ·»åŠ è¯¦ç»†çš„æŠ€æœ¯ç‰¹å¾è¯æ®
            if (deviceModel.includes("Apple")) {
                if (webglAnalysis?.basic?.renderer) {
                    evidence.push(`WebGL renderer: ${webglAnalysis.basic.renderer}`);
                }
                if (webgpuAnalysis?.adapter?.vendor) {
                    evidence.push(`WebGPU vendor: ${webgpuAnalysis.adapter.vendor}`);
                }
                if (cpuFeatures.memRatio) {
                    evidence.push(`CPUå†…å­˜æ¯”ä¾‹: ${cpuFeatures.memRatio.toFixed(3)}`);
                }
            }

            return {
                deviceModel,
                cpuModel,
                gpuModel,
                confidence,
                evidence
            };
        }

        // ä½¿ç”¨æ•°æ®åº“å¢å¼ºè®¾å¤‡è¯†åˆ«
        function enhanceWithDatabase(cpuFeatures, webglAnalysis, webgpuAnalysis, databaseResult) {
            if (databaseResult.confidence > 70) {
                // æ•°æ®åº“è¯†åˆ«ç½®ä¿¡åº¦é«˜ï¼Œä½¿ç”¨æ•°æ®åº“ç»“æœ
                return {
                    deviceModel: databaseResult.deviceModel,
                    cpuModel: cpuFeatures.model,
                    gpuModel: (webgpuAnalysis && webgpuAnalysis.confidence > webglAnalysis?.confidence) ?
                        webgpuAnalysis.model : webglAnalysis?.model || "æœªçŸ¥GPU",
                    confidence: databaseResult.confidence,
                    evidence: [
                        `ğŸ¯ æ•°æ®åº“ç²¾ç¡®åŒ¹é… (${databaseResult.confidence}% ç½®ä¿¡åº¦)`,
                        ...databaseResult.evidence,
                        ...(databaseResult.alternatives.length > 0 ?
                            [`å¤‡é€‰æ–¹æ¡ˆ: ${databaseResult.alternatives.map(alt => `${alt.brand} ${alt.deviceName}`).join(', ')}`] : [])
                    ]
                };
            } else {
                // æ•°æ®åº“è¯†åˆ«ç½®ä¿¡åº¦ä½ï¼Œä½¿ç”¨ä¼ ç»Ÿæ–¹æ³•å¹¶å­¦ä¹ æ–°ç‰¹å¾
                const traditional = analyzeDeviceIdentity(cpuFeatures, webglAnalysis, webgpuAnalysis);

                // å­¦ä¹ æ–°è®¾å¤‡ç‰¹å¾ç”¨äºæœªæ¥è¯†åˆ«
                if (traditional.confidence > 60) {
                    deviceDatabase.learnDeviceSignature(traditional.deviceModel, cpuFeatures, webglAnalysis, webgpuAnalysis);
                }

                return {
                    ...traditional,
                    evidence: [
                        `âš ï¸ æ•°æ®åº“åŒ¹é…åº¦è¾ƒä½ (${databaseResult.confidence}%)ï¼Œä½¿ç”¨ä¼ ç»Ÿåˆ†æ`,
                        ...traditional.evidence,
                        ...(databaseResult.confidence > 30 ?
                            [`ç›¸ä¼¼è®¾å¤‡: ${databaseResult.deviceModel}`] : [])
                    ]
                };
            }
        }

        // æ˜¾ç¤ºè®¾å¤‡æ•°æ®åº“ç»Ÿè®¡
        function showDatabaseStats() {
            try {
                addResult('=== ğŸ“Š è®¾å¤‡æ•°æ®åº“ç»Ÿè®¡ ===', 'enhancement');

                // åˆå§‹åŒ–æ•°æ®åº“
                if (!deviceDatabase) {
                    deviceDatabase = new DeviceSignatureDatabase();
                }

                const stats = deviceDatabase.generateDeviceStats();

                addResult('ğŸ“‹ æ•°æ®åº“æ¦‚è§ˆ:', 'cpu-info');
                addResult(`   æ€»è®¾å¤‡é…ç½®: ${stats.totalProfiles}ä¸ª`, 'cpu-info');
                addResult(`   å­¦ä¹ è®¾å¤‡æ•°: ${stats.learningData.totalDevices}ä¸ª`, 'cpu-info');
                addResult(`   å­¦ä¹ æ ·æœ¬æ•°: ${stats.learningData.totalSignatures}ä¸ª`, 'cpu-info');

                addResult('ğŸ­ æŒ‰å“ç‰Œåˆ†å¸ƒ:', 'cpu-info');
                for (const [brand, count] of Object.entries(stats.byBrand)) {
                    addResult(`   ${brand}: ${count}ä¸ªè®¾å¤‡`, 'cpu-info');
                }

                // å±•ç¤ºæ”¯æŒçš„è®¾å¤‡ç±»å‹
                addResult('ğŸ¯ æ”¯æŒçš„è®¾å¤‡ç±»å‹:', 'enhancement');
                addResult('   Apple ç³»åˆ—:', 'enhancement');
                addResult('     â€¢ MacBook Air M1', 'enhancement');
                addResult('     â€¢ MacBook Pro M1 Pro/Max', 'enhancement');
                addResult('     â€¢ MacBook Pro M2', 'enhancement');

                addResult('   Intel ç³»åˆ—:', 'enhancement');
                addResult('     â€¢ Intelé«˜ç«¯æ¡Œé¢ + é›†æˆæ˜¾å¡', 'enhancement');
                addResult('     â€¢ Intelæ¸¸æˆæœ¬ + NVIDIAç‹¬æ˜¾', 'enhancement');

                addResult('   AMD ç³»åˆ—:', 'enhancement');
                addResult('     â€¢ Ryzenæ¡Œé¢ + Radeonæ˜¾å¡', 'enhancement');

                addResult('   ç§»åŠ¨è®¾å¤‡:', 'enhancement');
                addResult('     â€¢ é«˜ç«¯Androidè®¾å¤‡', 'enhancement');

                addResult('ğŸ”¬ è¯†åˆ«ç‰¹å¾:', 'cpu-info');
                addResult('   â€¢ CPUå†…å­˜è®¿é—®æ¯”ä¾‹åˆ†æ', 'cpu-info');
                addResult('   â€¢ WebGLæ¸²æŸ“å™¨å­—ç¬¦ä¸²åŒ¹é…', 'cpu-info');
                addResult('   â€¢ WebGPUé€‚é…å™¨ä¿¡æ¯éªŒè¯', 'cpu-info');
                addResult('   â€¢ GPUæ€§èƒ½åŸºå‡†æµ‹è¯•', 'cpu-info');
                addResult('   â€¢ å¤šç»´åº¦ç‰¹å¾èåˆç®—æ³•', 'cpu-info');

                addResult('ğŸ’¡ æ•°æ®åº“ä¼˜åŠ¿:', 'model-guess');
                addResult('   â€¢ åŸºäºçœŸå®è®¾å¤‡æ•°æ®è®­ç»ƒ', 'model-guess');
                addResult('   â€¢ æŒç»­å­¦ä¹ æ–°è®¾å¤‡ç‰¹å¾', 'model-guess');
                addResult('   â€¢ å¤šé‡éªŒè¯æé«˜å‡†ç¡®æ€§', 'model-guess');
                addResult('   â€¢ æ”¯æŒç›¸ä¼¼è®¾å¤‡æ¨è', 'model-guess');

            } catch (error) {
                addResult(`âŒ æ•°æ®åº“ç»Ÿè®¡å¤±è´¥: ${error.message}`, 'limitation');
            }
        }

        // ===== ç®€åŒ–çš„éªŒè¯å’Œè¯Šæ–­åŠŸèƒ½ =====

        function debugWASMModule(Module) {
            addResult('ğŸ” WASMæ¨¡å—çŠ¶æ€æ£€æŸ¥:', 'enhancement');

            // æ£€æŸ¥æ¨¡å—åŸºç¡€çŠ¶æ€
            const moduleKeys = Object.keys(Module || {});
            addResult(`ğŸ“‹ Moduleå¯¹è±¡å±æ€§æ•°é‡: ${moduleKeys.length}`, 'cpu-info');

            // æ£€æŸ¥å¯¼å‡ºçš„å‡½æ•°
            const wasmFunctions = moduleKeys.filter(key => key.startsWith('_') && typeof Module[key] === 'function');
            addResult(`ğŸ”§ WASMå¯¼å‡ºå‡½æ•°: ${wasmFunctions.length}ä¸ª`, wasmFunctions.length > 0 ? 'cpu-info' : 'limitation');

            if (wasmFunctions.length > 0) {
                wasmFunctions.slice(0, 5).forEach(funcName => {
                    addResult(`   â€¢ ${funcName}`, 'cpu-info');
                });
                if (wasmFunctions.length > 5) {
                    addResult(`   â€¢ ... è¿˜æœ‰${wasmFunctions.length - 5}ä¸ªå‡½æ•°`, 'cpu-info');
                }
            }

            // æ£€æŸ¥è¿è¡Œæ—¶çŠ¶æ€
            addResult('âš™ï¸ è¿è¡Œæ—¶çŠ¶æ€:', 'cpu-info');
            addResult(`   runtimeInitialized: ${!!Module.runtimeInitialized}`, 'cpu-info');
            addResult(`   calledRun: ${!!Module.calledRun}`, 'cpu-info');

            // å¼ºåˆ¶æ£€æŸ¥wasmMemory
            if (typeof Module.wasmMemory !== 'undefined' && Module.wasmMemory) {
                addResult(`   wasmMemoryå­˜åœ¨: æ˜¯ (${Module.wasmMemory.buffer ? Module.wasmMemory.buffer.byteLength + ' bytes' : 'æ— buffer'})`, 'cpu-info');
            } else {
                addResult(`   wasmMemoryå­˜åœ¨: å¦`, 'limitation');
            }

            // æ£€æŸ¥å†…å­˜ç›¸å…³API - åªæ˜¾ç¤ºé‡è¦çš„çŠ¶æ€
            const coreMemoryAPIs = {
                'HEAP8 å†…å­˜è§†å›¾': !!Module.HEAP8,
                '_malloc å‡½æ•°': typeof Module._malloc === 'function'
            };

            // å¯é€‰çš„APIï¼ˆä¸å½±å“åŠŸèƒ½ï¼‰
            const optionalAPIs = {
                'HEAP16': !!Module.HEAP16,
                'HEAP32': !!Module.HEAP32,
                'memoryå¯¹è±¡': !!Module.memory,
                'mallocåˆ«å': typeof Module.malloc === 'function'
            };

            addResult('ğŸ’¾ æ ¸å¿ƒå†…å­˜APIçŠ¶æ€:', 'cpu-info');
            for (const [api, available] of Object.entries(coreMemoryAPIs)) {
                const status = available ? 'âœ…' : 'âŒ';
                addResult(`   ${status} ${api}`, available ? 'cpu-info' : 'limitation');
            }

            const optionalCount = Object.values(optionalAPIs).filter(Boolean).length;
            addResult(`â„¹ï¸ å¯é€‰APIå¯ç”¨: ${optionalCount}/4 (ä¸å½±å“æ ¸å¿ƒåŠŸèƒ½)`, 'model-guess');

            // å°è¯•æ‰‹åŠ¨æ£€æŸ¥å†…å­˜
            if (Module.memory && Module.memory.buffer) {
                const bufferSize = Module.memory.buffer.byteLength;
                addResult(`ğŸ“Š WASMå†…å­˜ç¼“å†²åŒº: ${bufferSize} bytes`, 'cpu-info');

                // å°è¯•æ‰‹åŠ¨åˆ›å»ºHEAP8è§†å›¾
                try {
                    const heap8 = new Uint8Array(Module.memory.buffer);
                    addResult(`ğŸ“Š æ‰‹åŠ¨HEAP8è§†å›¾: ${heap8.length} bytes`, 'cpu-info');
                } catch (e) {
                    addResult(`âŒ æ— æ³•åˆ›å»ºHEAP8è§†å›¾: ${e.message}`, 'limitation');
                }
            } else if (Module.HEAP8) {
                addResult(`ğŸ“Š HEAP8å¤§å°: ${Module.HEAP8.length} bytes`, 'cpu-info');
            } else {
                addResult('âš ï¸ å†…å­˜ç¼“å†²åŒºä¸å¯ç”¨ - è¿™å¯èƒ½å½±å“æŸäº›åŠŸèƒ½', 'model-guess');
            }

            // æ£€æŸ¥å…¶ä»–é‡è¦å±æ€§
            const otherProps = ['wasmMemory', 'buffer', 'asm', 'wasmExports'];
            const availableProps = otherProps.filter(prop => Module[prop] !== undefined);
            if (availableProps.length > 0) {
                addResult(`ğŸ”§ å…¶ä»–å¯ç”¨å±æ€§: ${availableProps.join(', ')}`, 'cpu-info');
            }
        }

        async function runValidationTests() {
            try {
                addResult('=== ğŸ§ª WASMéªŒè¯æµ‹è¯• ===', 'enhancement');
                const Module = await initWASM();

                // å…ˆè°ƒè¯•WASMæ¨¡å—çŠ¶æ€
                debugWASMModule(Module);

                // åŸºç¡€åŠŸèƒ½éªŒè¯
                addResult('ğŸ“‹ åŸºç¡€åŠŸèƒ½éªŒè¯:', 'cpu-info');
                const testCases = [
                    { size: 16, iter: 10, name: "å°å†…å­˜å—" },
                    { size: 32, iter: 10, name: "ä¸­ç­‰å†…å­˜å—" },
                    { size: 64, iter: 10, name: "å¤§å†…å­˜å—" }
                ];

                for (const test of testCases) {
                    try {
                        const seq = Module._sequential_access_test(test.size, test.iter);
                        const rand = Module._random_access_test(test.size, test.iter);
                        const ratio = rand / seq;

                        if (isFinite(seq) && isFinite(rand) && !isNaN(seq) && !isNaN(rand) && seq !== 0 && rand !== 0) {
                            const ratio = Math.abs(rand / seq);  // ä½¿ç”¨ç»å¯¹å€¼è®¡ç®—æ¯”ä¾‹
                            addResult(`âœ… ${test.name}: æ¯”ä¾‹=${ratio.toFixed(2)}`, 'cpu-info');
                        } else {
                            addResult(`âŒ ${test.name}: ç»“æœå¼‚å¸¸ (seq=${seq}, rand=${rand})`, 'limitation');
                        }
                    } catch (error) {
                        addResult(`âŒ ${test.name}: æ‰§è¡Œå¤±è´¥ - ${error.message}`, 'limitation');
                    }
                }

                // ä¸€è‡´æ€§æ£€æŸ¥ (3æ¬¡è¿è¡Œ)
                addResult('ğŸ”„ ä¸€è‡´æ€§æ£€æŸ¥:', 'cpu-info');
                const results = [];
                for (let i = 0; i < 3; i++) {
                    try {
                        const seq = Module._sequential_access_test(16, 10);
                        const rand = Module._random_access_test(16, 10);
                        if (isFinite(seq) && isFinite(rand) && seq !== 0 && rand !== 0) {
                            results.push(Math.abs(rand / seq));  // ä½¿ç”¨ç»å¯¹å€¼
                        }
                    } catch (error) {
                        addResult(`âš ï¸ ä¸€è‡´æ€§æµ‹è¯•ç¬¬${i+1}æ¬¡å¤±è´¥: ${error.message}`, 'limitation');
                    }
                }

                if (results.length > 0) {
                    const mean = results.reduce((a, b) => a + b) / results.length;
                    const variance = results.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / results.length;
                    const cv = Math.sqrt(variance) / mean;
                    addResult(`ğŸ“Š å˜å¼‚ç³»æ•°: ${(cv*100).toFixed(1)}% (${results.length}æ¬¡æœ‰æ•ˆæµ‹è¯•)`, cv < 0.3 ? 'cpu-info' : 'model-guess');
                } else {
                    addResult(`âŒ ä¸€è‡´æ€§æµ‹è¯•å…¨éƒ¨å¤±è´¥`, 'limitation');
                }

                // è®¡ç®—å‡½æ•°éªŒè¯
                addResult('ğŸ§® è®¡ç®—å‡½æ•°éªŒè¯:', 'cpu-info');
                const computeTests = [
                    { name: "æµ®ç‚¹ç²¾åº¦", func: () => Module._float_precision_test(1000) },
                    { name: "æ•´æ•°ä¼˜åŒ–", func: () => Module._integer_optimization_test(1000) },
                    { name: "åˆ†æ”¯é¢„æµ‹", func: () => Module._branch_prediction_test(1000) }
                ];

                for (const test of computeTests) {
                    try {
                        const result = test.func();
                        if (isFinite(result) && !isNaN(result) && result !== 0) {
                            addResult(`âœ… ${test.name}: æ­£å¸¸`, 'cpu-info');
                        } else {
                            addResult(`âš ï¸ ${test.name}: å¼‚å¸¸å€¼`, 'model-guess');
                        }
                    } catch (error) {
                        addResult(`âŒ ${test.name}: å¤±è´¥`, 'limitation');
                    }
                }

            } catch (error) {
                addResult(`âŒ éªŒè¯æµ‹è¯•å¤±è´¥: ${error.message}`, 'limitation');
            }
        }

        async function runDiagnostics() {
            try {
                addResult('=== ğŸ” ç³»ç»Ÿè¯Šæ–­ ===', 'enhancement');
                const Module = await initWASM();

                // å†…å­˜åˆ†é…æµ‹è¯•
                addResult('ğŸ’¾ å†…å­˜ç³»ç»Ÿæ£€æŸ¥:', 'cpu-info');
                try {
                    // æ£€æŸ¥WASMæ¨¡å—çŠ¶æ€ - åªè¦åŠŸèƒ½å¯ç”¨å°±ç»§ç»­
                    if (!Module.runtimeInitialized && !Module.calledRun) {
                        addResult('âš ï¸ WASMè¿è¡Œæ—¶æœªå®Œå…¨åˆå§‹åŒ–ï¼Œç­‰å¾…ä¸­...', 'model-guess');
                        // å°è¯•ç­‰å¾…ä¸€ä¸‹
                        await new Promise(resolve => setTimeout(resolve, 100));
                    } else if (!Module.runtimeInitialized && Module.calledRun) {
                        addResult('â„¹ï¸ WASMå·²è¿è¡Œä½†è¿è¡Œæ—¶æ ‡å¿—æœªè®¾ç½®ï¼ŒåŠŸèƒ½åº”è¯¥å¯ç”¨', 'model-guess');
                    }

                    // å°è¯•ä¸åŒçš„å†…å­˜åˆ†é…API
                    let ptr = null;
                    let allocSuccess = false;

                    // å°è¯• _malloc
                    if (typeof Module._malloc === 'function') {
                        try {
                            ptr = Module._malloc(1024);
                            if (ptr && ptr > 0) {
                                addResult(`âœ… å†…å­˜åˆ†é…æ­£å¸¸ (_malloc): ptr=${ptr}`, 'cpu-info');
                                if (typeof Module._free === 'function') {
                                    Module._free(ptr);
                                }
                                allocSuccess = true;
                            }
                        } catch (e) {
                            addResult(`âš ï¸ _mallocæµ‹è¯•å¤±è´¥: ${e.message}`, 'limitation');
                        }
                    }

                    // å¦‚æœ_mallocä¸æˆåŠŸï¼Œå°è¯•malloc
                    if (!allocSuccess && typeof Module.malloc === 'function') {
                        try {
                            ptr = Module.malloc(1024);
                            if (ptr && ptr > 0) {
                                addResult(`âœ… å†…å­˜åˆ†é…æ­£å¸¸ (malloc): ptr=${ptr}`, 'cpu-info');
                                if (typeof Module.free === 'function') {
                                    Module.free(ptr);
                                }
                                allocSuccess = true;
                            }
                        } catch (e) {
                            addResult(`âš ï¸ mallocæµ‹è¯•å¤±è´¥: ${e.message}`, 'limitation');
                        }
                    }

                    if (!allocSuccess) {
                        addResult('âš ï¸ åŠ¨æ€å†…å­˜åˆ†é…ä¸å¯ç”¨ï¼Œæ£€æŸ¥HEAPè®¿é—®...', 'model-guess');
                        // æ£€æŸ¥HEAPæ˜¯å¦å¯è®¿é—®
                        if (Module.HEAP8 && Module.HEAP8.length > 0) {
                            addResult(`âœ… WASMå†…å­˜å †å¯è®¿é—®: ${Module.HEAP8.length} bytes`, 'cpu-info');
                            // æµ‹è¯•HEAPå†™å…¥
                            try {
                                const testIndex = Math.min(1000, Module.HEAP8.length - 1);
                                const originalValue = Module.HEAP8[testIndex];
                                Module.HEAP8[testIndex] = 42;
                                if (Module.HEAP8[testIndex] === 42) {
                                    addResult(`âœ… HEAPå†™å…¥æµ‹è¯•æˆåŠŸ`, 'cpu-info');
                                    Module.HEAP8[testIndex] = originalValue; // æ¢å¤åŸå€¼
                                } else {
                                    addResult(`âŒ HEAPå†™å…¥æµ‹è¯•å¤±è´¥`, 'limitation');
                                }
                            } catch (e) {
                                addResult(`âŒ HEAPè®¿é—®æµ‹è¯•å¤±è´¥: ${e.message}`, 'limitation');
                            }
                        } else {
                            addResult('âŒ WASMå†…å­˜å †ä¸å¯è®¿é—®', 'limitation');
                        }
                    }

                } catch (error) {
                    addResult(`âŒ å†…å­˜ç³»ç»Ÿæ£€æŸ¥å¤±è´¥: ${error.message}`, 'limitation');
                }

                // å‡½æ•°å¯ç”¨æ€§æ£€æŸ¥
                addResult('ğŸ”§ å‡½æ•°å¯ç”¨æ€§æ£€æŸ¥:', 'cpu-info');
                const functions = ['_sequential_access_test', '_random_access_test', '_float_precision_test'];
                for (const funcName of functions) {
                    const status = Module[funcName] ? 'âœ…' : 'âŒ';
                    addResult(`  ${status} ${funcName.replace('_', '')}`, Module[funcName] ? 'cpu-info' : 'limitation');
                }

                // ç¼“å­˜è¾¹ç•Œè¯Šæ–­
                addResult('ğŸ” ç¼“å­˜è¾¹ç•Œè¯Šæ–­:', 'cpu-info');
                const cacheSizes = [8, 16, 32, 64, 128, 256];
                const cacheResults = [];

                for (const sizeKB of cacheSizes) {
                    try {
                        const iterations = Math.max(10, 500 / sizeKB);
                        const seq = Module._sequential_access_test(sizeKB, iterations);
                        const rand = Module._random_access_test(sizeKB, iterations);

                        if (isFinite(seq) && isFinite(rand) && seq !== 0 && rand !== 0) {
                            const ratio = Math.abs(rand / seq);
                            cacheResults.push({ size: sizeKB, ratio });

                            let level = '';
                            if (ratio > 2.0) level = ' ğŸ”´';
                            else if (ratio > 1.6) level = ' ğŸŸ¡';
                            else if (ratio > 1.3) level = ' ğŸŸ ';
                            else level = ' ğŸŸ¢';

                            addResult(`  ${sizeKB}KB: ${ratio.toFixed(2)}${level}`, 'cpu-info');
                        } else {
                            addResult(`  ${sizeKB}KB: æµ‹è¯•å¤±è´¥ (seq=${seq}, rand=${rand})`, 'limitation');
                        }
                    } catch (error) {
                        addResult(`  ${sizeKB}KB: æµ‹è¯•å¼‚å¸¸ - ${error.message}`, 'limitation');
                    }
                }

                // ç¼“å­˜è¾¹ç•Œåˆ†æ
                for (let i = 1; i < cacheResults.length; i++) {
                    const prev = cacheResults[i-1];
                    const curr = cacheResults[i];
                    const jump = curr.ratio / prev.ratio;
                    if (jump > 1.5) {
                        addResult(`ğŸ“Š ç¼“å­˜è¾¹ç•Œ: ${prev.size}KB â†’ ${curr.size}KB`, 'model-guess');
                    }
                }

                // æµè§ˆå™¨ç¯å¢ƒæ£€æŸ¥
                addResult('ğŸŒ ç¯å¢ƒæ”¯æŒæ£€æŸ¥:', 'cpu-info');
                const features = {
                    'Performance API': typeof performance.now === 'function',
                    'WASM Memory': !!Module.HEAP8,
                    'BigInt': typeof BigInt !== 'undefined',
                    'SharedArrayBuffer': typeof SharedArrayBuffer !== 'undefined'
                };

                for (const [feature, supported] of Object.entries(features)) {
                    const status = supported ? 'âœ…' : (feature === 'Performance API' || feature === 'WASM Memory' ? 'âŒ' : 'â„¹ï¸');
                    const style = supported ? 'cpu-info' : (feature === 'Performance API' || feature === 'WASM Memory' ? 'limitation' : 'model-guess');

                    if (!supported && (feature === 'BigInt' || feature === 'SharedArrayBuffer')) {
                        addResult(`  ${status} ${feature} (å¯é€‰åŠŸèƒ½ï¼Œä¸å½±å“æ£€æµ‹)`, style);
                    } else {
                        addResult(`  ${status} ${feature}`, style);
                    }
                }

            } catch (error) {
                addResult(`âŒ ç³»ç»Ÿè¯Šæ–­å¤±è´¥: ${error.message}`, 'limitation');
            }
        }

        // é¡µé¢åŠ è½½æ—¶æ˜¾ç¤ºè¯´æ˜
        window.onload = function() {
            addResult('ğŸ” å¢å¼ºå‹è®¾å¤‡æŒ‡çº¹è¯†åˆ«ç³»ç»Ÿå·²å‡†å¤‡å°±ç»ª', 'cpu-info');
            addResult('ğŸ¯ ä¸»è¦æ£€æµ‹åŠŸèƒ½:', 'cpu-info');
            addResult('   ğŸ¯ WASM CPUæ£€æµ‹ - å¿«é€Ÿå‡†ç¡®çš„CPUå‹å·è¯†åˆ«', 'cpu-info');
            addResult('   ğŸ”§ WASMè¯¦ç»†åˆ†æ - CPUå¾®æ¶æ„æ·±åº¦åˆ†æ', 'cpu-info');
            addResult('   ğŸ¨ WebGL GPUæ£€æµ‹ - GPUåŸºç¡€ä¿¡æ¯å’Œæ¸²æŸ“ç‰¹å¾', 'cpu-info');
            addResult('   âš¡ WebGPUé«˜çº§æ£€æµ‹ - GPUæ€§èƒ½åˆ†æ', 'cpu-info');
            addResult('   ğŸ§¬ å®Œæ•´ç‰¹å¾åˆ†æ - è¯¦ç»†çš„ç¼“å­˜å’Œæ€§èƒ½åˆ†æ', 'cpu-info');
            addResult('   ğŸš€ ä¸‰é‡æ£€æµ‹ - èåˆæ‰€æœ‰æŠ€æœ¯çš„ç»ˆæç²¾åº¦è¯†åˆ«', 'cpu-info');
            addResult('ğŸ› ï¸ æµ‹è¯•å’Œè¯Šæ–­å·¥å…·:', 'enhancement');
            addResult('   ğŸ§ª WASMéªŒè¯æµ‹è¯• - éªŒè¯åŸºç¡€åŠŸèƒ½æ­£ç¡®æ€§', 'enhancement');
            addResult('   ğŸ” ç³»ç»Ÿè¯Šæ–­ - æ·±åº¦åˆ†ææ‰§è¡Œç¯å¢ƒ', 'enhancement');
            addResult('ğŸ’¡ å»ºè®®æµ‹è¯•é¡ºåº: WASM CPUæ£€æµ‹ â†’ ä¸‰é‡æ£€æµ‹ â†’ å®Œæ•´åˆ†æ', 'enhancement');
        };
    </script>
</body>
</html>
