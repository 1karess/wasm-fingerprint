
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced CPU Model Detection</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #0d1117;
            color: #c9d1d9;
        }
        .detection-section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #30363d;
            border-radius: 8px;
            background: #161b22;
        }
        .status {
            padding: 8px;
            margin: 3px 0;
            border-radius: 4px;
            font-size: 13px;
        }
        .cpu-info { background: #0d5016; border-left: 4px solid #56d364; }
        .limitation { background: #5d1a1a; border-left: 4px solid #f85149; }
        .enhancement { background: #1a3d5d; border-left: 4px solid #58a6ff; }
        .model-guess { background: #5d4b1a; border-left: 4px solid #f0d000; }
        button {
            background: #238636;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointser;
            margin: 5px;
            font-family: inherit;
        }
        button:hover { background: #2ea043; }
        .results { max-height: 600px; overflow-y: auto; }
        .highlight { color: #58a6ff; font-weight: bold; }
        .signature-table {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 8px;
            margin: 10px 0;
            font-size: 12px;
        }
        .signature-table > div {
            padding: 6px;
            background: #21262d;
            border-radius: 4px;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>Enhanced Device Fingerprint Recognition System</h1>

    <div class="detection-section">
        <h2>Detection Methods</h2>
        <button onclick="runCPUDetection()">WASM CPU Detection</button>
        <button onclick="runBasicDetection()">WASM Detailed Analysis</button>
        <button onclick="runWebGLDetection()">WebGL GPU Detection</button>
        <button onclick="runWebGPUDetection()">WebGPU Advanced Detection</button>
        <button onclick="runTripleDetection()">Triple Detection (Ultimate Accuracy)</button>
        <button onclick="analyzeSignatures()">Complete Feature Analysis</button>
        <button onclick="runRealWorldDetection()">Real Environment Detection</button>
        <button onclick="showDatabaseStats()">Device Database Statistics</button>
        <button onclick="exportCalibrationSample()">Export Calibration Sample</button>
        <button onclick="clearResults()">Clear Results</button>
    </div>

    <div class="detection-section">
        <h2>Testing and Diagnostic Tools</h2>
        <button onclick="runValidationTests()">WASM Verification Test</button>
        <button onclick="runDiagnostics()">System Diagnosis</button>
        <button onclick="testCPUCoreTypes()" style="background: #1f6feb;">ðŸ§µ Test CPU Core Types (P/E Cores)</button>
    </div>

    <div id="output" class="results"></div>

    <script src="./build/wasm-fingerprint.js?v=20251111"></script>
    <script src="./src/common.js?v=20251112"></script>
    <script src="./src/webgl-detection.js?v=20251111"></script>
    <script src="./src/webgpu-detection.js?v=20251111"></script>
    <script src="./src/device-database.js?v=20251111"></script>
    <script src="./src/realworld-detector.js?v=20251111"></script>
    <script>
        const output = document.getElementById('output');
        let wasmModule = null;
        let deviceDatabase = null;

        function addResult(message, type = 'cpu-info') {
            const div = document.createElement('div');
            div.className = `status ${type}`;
            div.innerHTML = `[${new Date().toLocaleTimeString()}] ${message}`;
            output.appendChild(div);
            output.scrollTop = output.scrollHeight;
        }

        function clearResults() {
            output.innerHTML = '';
        }

        async function initWASM() {
            if (wasmModule && wasmModule.runtimeInitialized) {
                return wasmModule;
            }

            // Clean up previous module instance
            wasmModule = null;

            try {
                const timestamp = Date.now();

                // Using more reliable initialization method
                wasmModule = await new Promise((resolve, reject) => {
                    let resolved = false;

                    const moduleConfig = {
                        locateFile: (path, scriptDirectory) => {
                            if (path.endsWith('.wasm')) {
                                return scriptDirectory + path + '?v=' + timestamp;
                            }
                            return scriptDirectory + path;
                        },
                        onRuntimeInitialized: function() {
                            if (resolved) return; // Prevent duplicate callbacks
                            resolved = true;

                            // Force set correct status flag
                            this.runtimeInitialized = true;

                            console.log(' WASM runtime officially initialized:', {
                                runtimeInitialized: this.runtimeInitialized,
                                calledRun: this.calledRun,
                                hasHEAP8: !!this.HEAP8,
                                hasMalloc: typeof this._malloc === 'function',
                                hasSequentialTest: typeof this._sequential_access_test === 'function'
                            });

                            // Immediately verify key functions
                            if (this._sequential_access_test && this.HEAP8 && this._malloc) {
                                resolve(this);
                            } else {
                                reject(new Error('WASM module missing key functions after initialization'));
                            }
                        },
                        onAbort: function(what) {
                            if (resolved) return;
                            resolved = true;
                            reject(new Error('WASM initialization aborted: ' + what));
                        }
                    };

                    // Start WASM module
                    try {
                        WASMModule(moduleConfig);
                    } catch (e) {
                        if (!resolved) {
                            resolved = true;
                            reject(e);
                        }
                    }

                    // Timeout protection
                    setTimeout(() => {
                        if (!resolved) {
                            resolved = true;
                            reject(new Error('WASM initialization timeout (5 seconds)'));
                        }
                    }, 5000);
                });

                // Final verification and status confirmation
                if (!wasmModule.runtimeInitialized) {
                    throw new Error('Runtime initialization flag still false');
                }

                // Function verification test
                try {
                    const testPtr = wasmModule._malloc(1024);
                    if (testPtr) {
                        wasmModule._free(testPtr);
                        console.log(' Memory allocation test passed');
                    } else {
                        console.warn(' Memory allocation test failed, but continuing execution');
                    }

                    const testResult = wasmModule._sequential_access_test(32, 10);
                    console.log(' Sequential access test passed:', testResult);
                } catch (e) {
                    console.warn(' Function verification testFailed:', e.message);
                }

                return wasmModule;
            } catch (error) {
                wasmModule = null;
                console.error(' WASM initialization completely failed:', error);
                addResult(` WASM Loading Failed: ${error.message}`, 'limitation');
                throw error;
            }
        }

        // Result validity verification function
        function validateTestResults(features) {
            const issues = [];
            const warnings = [];

            // 1. Check Prefetcher Efficiency
            if (features.prefetch_efficiency !== null && features.prefetch_efficiency !== undefined) {
                if (!isFinite(features.prefetch_efficiency) || features.prefetch_efficiency <= 0) {
                    issues.push("Prefetcher test invalid (Infinity or negative value)");
                } else if (features.prefetch_efficiency > 1000) {
                    warnings.push("Prefetcher Efficiency abnormally high (test may be invalid)");
                }
            }

            // 2. Check division efficiency
            if (features.division_efficiency !== undefined) {
                if (features.division_efficiency === 0) {
                    issues.push("Division test failed (returned 0)");
                } else if (!isFinite(features.division_efficiency)) {
                    issues.push("Division test invalid (non-finite value)");
                }
            }

            // 3. Check stride test consistency
            const strides = [64, 128, 256, 512, 4096];
            const strideValues = strides.map(s => features[`stride_${s}`]).filter(v => v > 0);

            if (strideValues.length < 3) {
                issues.push("Too many stride tests failed (less than 3 valid tests)");
            } else {
                // Check if all values are identical (unlikely)
                const uniqueValues = new Set(strideValues.map(v => Math.round(v * 1000)));
                if (uniqueValues.size === 1) {
                    warnings.push("Stride test results identical (test precision may be insufficient)");
                }
            }

            // 4. Check cache conflict test
            const conflicts = [4096, 8192, 16384, 32768].map(s => features[`conflict_${s}`]).filter(v => v !== undefined && v > 0);
            if (conflicts.length > 1) {
                const uniqueConflicts = new Set(conflicts.map(v => Math.round(v * 1000))); // Reduce precision requirement
                if (uniqueConflicts.size === 1) {
                    warnings.push("Cache conflict test results identical");
                } else if (conflicts.filter(v => v < 0.1).length === conflicts.length) {
                    issues.push("Cache conflict test precision too low (all results < 0.1ms)");
                }
            } else {
                warnings.push("Too few valid cache conflict tests");
            }

            // 5. Check calculation test reasonability
            if (features.float_precision !== undefined && features.float_precision === 0) {
                issues.push("Float ComputationTestFailed");
            }

            if (features.integer_opt !== undefined && features.integer_opt === 0) {
                warnings.push("Integer optimization test may be invalid");
            }

            return { issues, warnings };
        }

        // Core CPU detection function
        async function runCPUDetection() {
            try {
                addResult('=== CPU Model Detection Started ===', 'enhancement');
                const Module = await initWASM();

                // Core detection: Memory access pattern
                addResult('Memory Access Pattern Analysis:', 'cpu-info');

                // Run multiple iteration tests to get accurate ratio
                let ratios = [];
                const testParams = [
                    { size: 32, iter: 200 },  // Basic test - increased iterations to get measurable time
                    { size: 64, iter: 150 },  // Cache Boundary Test
                    { size: 32, iter: 200 }   // Repeat verification
                ];

                for (let i = 0; i < testParams.length; i++) {
                    const { size, iter } = testParams[i];

                    // Measure execution time instead of return value
                    const seqStart = performance.now();
                    Module._sequential_access_test(size, iter);
                    const seqTime = performance.now() - seqStart;

                    const randStart = performance.now();
                    Module._random_access_test(size, iter);
                    const randTime = performance.now() - randStart;

                    if (seqTime > 0.1 && randTime > 0.1) {  // At least 0.1ms to ensure meaningfulness
                        const ratio = randTime / seqTime;
                        ratios.push(ratio);
                        addResult(`   Test ${i+1}(${size}KB/${iter} iterations): Sequential=${seqTime.toFixed(2)}ms, Random=${randTime.toFixed(2)}ms, Ratio=${ratio.toFixed(3)}`, 'cpu-info');
                    }
                }

                const avgRatio = ratios.reduce((a, b) => a + b) / ratios.length;
                addResult(`   Average Ratio: ${avgRatio.toFixed(3)}`, 'cpu-info');

                // Cache architecture analysis
                addResult('Cache Architecture Analysis:', 'cpu-info');
                const l1Size = Module._l1_cache_size_detection(64);
                const cacheLineSize = Module._cache_line_size_detection();

                addResult(`   L1 Cache Size: ${l1Size}KB`, 'cpu-info');
                addResult(`   Cache Line Size: ${cacheLineSize} bytes`, 'cpu-info');

                // CPU Model inference - unified algorithm consistent with other detections
                let cpuModel = "Unknown CPU";
                let confidence = 0;
                let evidence = [];

                // Using exactly the same thresholds as all other detections to ensure consistent results
                if (avgRatio >= 0.5 && avgRatio < 1.6) {  // Unified Apple Silicon range
                    cpuModel = "Apple Silicon (M1/M2/M3/M4)";
                    confidence = 90;
                    evidence.push(`Memory access ratio ${avgRatio.toFixed(3)} indicates unified memory architecture`);

                    if (avgRatio <= 0.8) {
                        confidence = 95;
                        evidence.push("Very low random access penalty, typical Apple Silicon characteristic");
                    }
                } else if (avgRatio >= 1.6 && avgRatio <= 2.5) {  // Unified Intel range
                    cpuModel = "Intel High-Performance CPU";
                    confidence = 85;
                    evidence.push(`Memory access ratio ${avgRatio.toFixed(3)} matches Intel cache architecture`);
                } else if (avgRatio > 2.5 && avgRatio <= 4.0) {  // Unified AMD range
                    cpuModel = "AMD Ryzen/Mainstream CPU";
                    confidence = 80;
                    evidence.push(`Memory access ratio ${avgRatio.toFixed(3)} shows typical AMD characteristics`);
                } else if (avgRatio > 4.0) {
                    cpuModel = "Low-end CPU or Virtual Environment";
                    confidence = 70;
                    evidence.push(`Memory access ratio ${avgRatio.toFixed(3)} indicates performance-limited characteristics`);
                } else {
                    cpuModel = "Abnormal Result";
                    confidence = 30;
                    evidence.push(`Memory access ratio ${avgRatio.toFixed(3)} is abnormal, possibly a test environment issue`);
                }

                // Cache feature verification
                if (l1Size === 32 && cacheLineSize === 64) {
                    confidence += 5;
                    evidence.push("Standard L1 cache configuration (32KB/64B)");
                } else if (l1Size === 32 && cacheLineSize === 128) {
                    if (cpuModel.includes("Apple")) {
                        confidence += 10;
                        evidence.push("Apple-specific 128-byte cache line");
                    }
                }

                addResult('Detection Results:', 'model-guess');
                addResult(`   CPU Model: ${cpuModel}`, 'model-guess');
                addResult(`   Confidence: ${confidence}%`, 'model-guess');
                addResult('Inference Basis:', 'model-guess');
                evidence.forEach(e => addResult(`   - ${e}`, 'model-guess'));

            } catch (error) {
                addResult(`CPU Detection Failed: ${error.message}`, 'limitation');
            }
        }

        async function runBasicDetection() {
            try {
                addResult('=== WASM CPU Microarchitecture Deep Analysis ===', 'cpu-info');
                const Module = await initWASM();
                await ensureCommonLoaded();
                const wasmHelper = window.wasmFingerprint;

                // Basic performance characteristics - using fixed time measurement
                function timedTest(testFunc, ...args) {
                    const startTime = performance.now();
                    const result = testFunc(...args);
                    const endTime = performance.now();
                    return { result, time: endTime - startTime };
                }

                const seqTest = timedTest(Module._sequential_access_test.bind(Module), 16, 1000);
                const randTest = timedTest(Module._random_access_test.bind(Module), 16, 1000);
                const float_test = timedTest(Module._float_precision_test.bind(Module), 10000);
                const int_test = timedTest(Module._integer_optimization_test.bind(Module), 10000);
                const vector_test = timedTest(Module._vector_computation_test.bind(Module), 1000);

                // Apple Silicon special architecture handling: unified memory may lead to special access patterns
                let memRatio;
                let isAppleMemoryPattern = false;

                if (randTest.time > 0.001 && seqTest.time > 0.001) {
                    if (randTest.time < seqTest.time) {
                        // Sequential access slower than Random access - this may be normal on Apple Silicon
                        const reverseRatio = seqTest.time / randTest.time;

                        if (reverseRatio < 1.5) {
                            // Small difference, may be characteristic of Apple unified memory architecture
                            memRatio = reverseRatio;
                            isAppleMemoryPattern = true;
                            addResult(`Detected Apple Silicon memory pattern: Sequential access slightly slower than random access`, 'enhancement');
                        } else {
                            // Large difference, may indeed be abnormal
                            memRatio = reverseRatio;
                            addResult(`Warning: Sequential access significantly slower than random access (${reverseRatio.toFixed(2)}x)`, 'limitation');
                        }
                    } else {
                        memRatio = randTest.time / seqTest.time;
                    }
                } else {
                    memRatio = 'Too Fast';
                }

                // Display basic results
                addResult('Basic Performance Test Results:', 'cpu-info');
                if (typeof memRatio === 'number') {
                    let description;
                    if (isAppleMemoryPattern) {
                        description = `Apple Silicon mode - Sequential ${seqTest.time.toFixed(2)}ms / Random ${randTest.time.toFixed(2)}ms`;
                    } else {
                        const slowerAccess = randTest.time > seqTest.time ? 'Random' : 'Sequential';
                        const fasterAccess = randTest.time > seqTest.time ? 'Sequential' : 'Random';
                        description = `${slowerAccess} ${Math.max(randTest.time, seqTest.time).toFixed(2)}ms / ${fasterAccess} ${Math.min(randTest.time, seqTest.time).toFixed(2)}ms`;
                    }
                    addResult(`   Memory Access Time Ratio: <span class="highlight">${memRatio.toFixed(3)}</span> (${description})`, 'cpu-info');
                } else {
                    addResult(`   Memory Access Time Ratio: <span class="highlight">${memRatio}</span>`, 'limitation');
                }
                addResult(`   Float Computation: <span class="highlight">${float_test.result.toFixed(6)}</span> (${float_test.time.toFixed(2)}ms)`, 'cpu-info');
                addResult(`   Integer Optimization: <span class="highlight">${int_test.result}</span> (${int_test.time.toFixed(2)}ms)`, 'cpu-info');
                addResult(`   Vector Computation: <span class="highlight">${vector_test.result.toFixed(6)}</span> (${vector_test.time.toFixed(2)}ms)`, 'cpu-info');

                if (wasmHelper && typeof wasmHelper.detectSIMDSupport === 'function') {
                    const simdSupported = await wasmHelper.detectSIMDSupport();
                    addResult(`   SIMD Support: ${simdSupported ? 'Enabled' : 'Not Detected'}`, simdSupported ? 'cpu-info' : 'limitation');
                }

                // Execute WASM detailed cache analysis
                addResult('WASM Cache Hierarchy Analysis:', 'enhancement');

                const features = {};
                const testSizes = [
                    { size: 32, label: '32KB (L1 boundary)', iterations: 300 },
                    { size: 64, label: '64KB', iterations: 300 },
                    { size: 256, label: '256KB (L2 boundary)', iterations: 200 },
                    { size: 512, label: '512KB', iterations: 200 },
                    { size: 2048, label: '2MB (L3 boundary)', iterations: 100 },
                    { size: 4096, label: '4MB', iterations: 50 }
                ];

                addResult('   Analyzing cache characteristics...', 'enhancement');

                for (let testCase of testSizes) {
                    let seqTimes = [];
                    let randTimes = [];

                    for (let run = 0; run < 2; run++) {
                        Module._sequential_access_test(8192, 3);

                        const seqStart = performance.now();
                        Module._sequential_access_test(testCase.size, testCase.iterations);
                        const seqTime = performance.now() - seqStart;
                        seqTimes.push(seqTime);

                        Module._random_access_test(8192, 3);

                        const randStart = performance.now();
                        Module._random_access_test(testCase.size, testCase.iterations);
                        const randTime = performance.now() - randStart;
                        randTimes.push(randTime);
                    }

                    const avgSeqTime = seqTimes.reduce((a, b) => a + b) / seqTimes.length;
                    const avgRandTime = randTimes.reduce((a, b) => a + b) / randTimes.length;

                    if (avgSeqTime > 1.0 && avgRandTime > 1.0) {
                        const ratio = avgRandTime / avgSeqTime;
                        features[`mem_ratio_${testCase.size}KB`] = ratio;

                        const isSignificant = ratio > 1.6 ? 'Cache Boundary' : '';
                        addResult(`   ${testCase.label}: Ratio=${ratio.toFixed(3)} ${isSignificant}`, 'enhancement');
                    }
                }

                // WASM Microarchitecture Feature Analysis
                addResult('WASM Microarchitecture Feature Analysis:', 'model-guess');

                // Stride sensitivity test
                const strideTests = [
                    { stride: 64, label: '1 cache line (64B)' },
                    { stride: 128, label: '2 cache lines (128B)' },
                    { stride: 512, label: '8 cache lines (512B)' },
                    { stride: 4096, label: '1 memory page (4KB)' }
                ];

                addResult('   Prefetcher Behavior Analysis:', 'model-guess');
                for (const test of strideTests) {
                    const start = performance.now();
                    Module._stride_access_test(512, test.stride, 200);
                    const time = performance.now() - start;
                    features[`stride_${test.stride}`] = time;
                    addResult(`     ${test.label}: ${time.toFixed(1)}ms`, 'model-guess');
                }

                // Prefetcher Efficiency - stable calculation method
                let prefetchEfficiency = null;
                const strides = [64, 128, 512, 4096];
                const validStrides = strides.filter(s => features[`stride_${s}`] > 0.001);

                if (validStrides.length >= 2) {
                    const smallStride = validStrides[0];
                    const largeStride = validStrides[validStrides.length - 1];
                    const smallTime = features[`stride_${smallStride}`];
                    const largeTime = features[`stride_${largeStride}`];

                    prefetchEfficiency = smallTime / largeTime;

                    // Reasonability check
                    if (prefetchEfficiency > 0.1 && prefetchEfficiency < 50) {
                        let desc = "";
                        if (prefetchEfficiency < 0.5) desc = " (Ultra-strong prefetcher)";
                        else if (prefetchEfficiency < 1.0) desc = " (Strong prefetcher)";
                        else if (prefetchEfficiency < 3.0) desc = " (Medium prefetcher)";
                        else desc = " (Normal prefetcher)";

                        addResult(`   Prefetcher Efficiency: ${prefetchEfficiency.toFixed(1)}${desc}`, 'model-guess');
                    } else {
                        addResult(`   Warning: Prefetcher analysis data abnormal (efficiency=${prefetchEfficiency.toFixed(2)})`, 'limitation');

                        // Re-analyze time trend
                        addResult('   Detailed Time Analysis:', 'model-guess');
                        for (let i = 1; i < validStrides.length; i++) {
                            const prev = validStrides[i-1];
                            const curr = validStrides[i];
                            const ratio = features[`stride_${curr}`] / features[`stride_${prev}`];
                            const trend = ratio > 1 ? "increased" : "decreased";
                            addResult(`     ${prev}Bâ†’${curr}B: Time ${trend} ${(Math.abs(ratio-1)*100).toFixed(1)}%`, 'model-guess');
                        }

                        prefetchEfficiency = null;
                    }
                } else {
                    addResult(`   Warning: Prefetcher analysis insufficient data (${validStrides.length} valid strides)`, 'limitation');
                }

                // WASM-specific CPU identification algorithm
                const memoryTests = Object.entries(features)
                    .filter(([k, v]) => k.startsWith('mem_ratio'))
                    .map(([k, v]) => v);

                const avgMemRatio = memoryTests.length > 0 ?
                    memoryTests.reduce((a, b) => a + b) / memoryTests.length : memRatio;

                let wasmCpuType = "Unknown Architecture";
                let confidence = 30;
                let evidence = [];

                if (typeof avgMemRatio === 'number') {
                    // Prioritize Apple Silicon identification based on prefetcher characteristics
                    const isApplePrefetcher = prefetchEfficiency > 10 && prefetchEfficiency < 30;
                    const cacheJumps = memoryTests.filter(ratio => ratio > 1.4).length;
                    const hasAppleCachePattern = cacheJumps >= 3;

                    // Apple Silicon strong feature detection
                    if (isApplePrefetcher && hasAppleCachePattern) {
                        wasmCpuType = "Apple Silicon";
                        confidence = 90;
                        evidence.push("Apple Silicon prefetcher characteristics confirmed");
                        evidence.push("Apple unified memory cache pattern");

                        if (avgMemRatio < 1.2) {
                            wasmCpuType = "Apple Silicon (possibly M4 series with high performance)";
                            confidence = 95;
                        }

                    } else if (avgMemRatio >= 0.5 && avgMemRatio < 1.6) {  // Completely consistent with quick detection
                        wasmCpuType = "Apple Silicon";
                        confidence = 85;
                        evidence.push("Low memory access ratio, typical unified memory architecture");

                        if (isApplePrefetcher) {
                            confidence += 10;
                            evidence.push("Apple Silicon prefetcher characteristics");
                        }

                        if (hasAppleCachePattern) {
                            confidence += 5;
                            evidence.push("Apple unified memory cache pattern");
                        }

                    } else if (avgMemRatio >= 1.6 && avgMemRatio <= 2.5 && !isApplePrefetcher) {  // Unified threshold to 1.6
                        wasmCpuType = "Intel High-Performance CPU";
                        confidence = 75;
                        evidence.push("Medium memory access ratio, hierarchical cache architecture");

                        if (prefetchEfficiency < 10) {
                            confidence += 5;
                            evidence.push("Intel strong prefetcher characteristics");
                        }

                    } else if (avgMemRatio > 2.5 && !isApplePrefetcher) {
                        wasmCpuType = "AMD Ryzen or mainstream CPU";
                        confidence = 70;
                        evidence.push("High memory access ratio");
                    } else {
                        // Prefetcher characteristics strongly indicate Apple, even with abnormal memory ratio
                        if (isApplePrefetcher) {
                            wasmCpuType = "Apple Silicon (abnormal memory ratio)";
                            confidence = 80;
                            evidence.push("Prefetcher characteristics strongly indicate Apple Silicon");
                            evidence.push("Memory ratio abnormal, may be affected by test environment");
                        }
                    }
                }

                addResult('WASM Professional Analysis Results:', 'model-guess');
                addResult(`   CPU Architecture: <span class="highlight">${wasmCpuType}</span>`, 'model-guess');
                addResult(`   WASM Detection Confidence: <span class="highlight">${confidence}%</span>`, 'model-guess');

                if (evidence.length > 0) {
                    addResult('   WASM Analysis Basis:', 'model-guess');
                    evidence.forEach(ev => addResult(`     - ${ev}`, 'model-guess'));
                }

                addResult('WASM Unique Advantages:', 'cpu-info');
                addResult('   - Direct access to CPU microarchitecture features', 'cpu-info');
                addResult('   - Bypass operating system abstraction layer', 'cpu-info');
                addResult('   - Precise cache hierarchy analysis', 'cpu-info');
                addResult('   - Prefetcher behavior detection', 'cpu-info');
                addResult('   - Cross-platform consistency detection', 'cpu-info');

                addResult('WASM Detection Limitations:', 'limitation');
                addResult('   - Affected by browser security policies', 'limitation');
                addResult('   - Cannot obtain specific model information', 'limitation');
                addResult('   - Accuracy affected by execution environment standardization', 'limitation');

            } catch (error) {
                addResult(`WASM Basic Detection Failed: ${error.message}`, 'limitation');
            }
        }

        async function runEnhancedDetection() {
            try {
                addResult('===  Theoretical Enhanced Detection Scheme ===', 'enhancement');

                addResult(' Technologies Required for Enhanced Detection:', 'enhancement');
                addResult('   1. <span class="highlight">More micro-benchmark tests</span> - cache size, TLB characteristics, prefetch behavior', 'enhancement');
                addResult('   2. <span class="highlight">Instruction-level tests</span> - specific instruction latency, throughput differences', 'enhancement');
                addResult('   3. <span class="highlight">Timing side channels</span> - more precise performance timers', 'enhancement');
                addResult('   4. <span class="highlight">Machine learning classification</span> - training model to identify feature patterns', 'enhancement');

                addResult('ðŸ“‹ Detectable Specific Features:', 'enhancement');
                const signatures = [
                    'L1 Cache Size and latency',
                    'L2/L3 cache hierarchy structure',
                    'TLB size and grouping method',
                    'Branch predictor algorithm differences',
                    'Out-of-order execution window size',
                    'SIMD instruction set support',
                    'Memory prefetch strategy',
                    'Floating-points unit precision characteristics'
                ];

                for (const sig of signatures) {
                    addResult(`   - ${sig}`, 'enhancement');
                }

                addResult(' Theoretically identifiable CPU models:', 'model-guess');
                const cpuModels = [
                    { family: 'Intel', models: ['i5-8250U', 'i7-10700K', 'i9-11900K'], signature: 'Low memory ratio + high floating-points performance' },
                    { family: 'AMD', models: ['Ryzen 5 3600', 'Ryzen 7 5800X'], signature: 'Medium memory ratio + excellent integer performance' },
                    { family: 'ARM', models: ['A14 Bionic', 'Snapdragon 888'], signature: 'High memory ratio + mobile optimization' },
                    { family: 'Apple', models: ['M1', 'M2'], signature: 'Unique cache behavior + unified memory' }
                ];

                const signatureDiv = document.createElement('div');
                signatureDiv.className = 'signature-table';
                signatureDiv.innerHTML = `
                    <div><strong>Vendor</strong></div>
                    <div><strong>Representative Models</strong></div>
                    <div><strong>Feature Signature</strong></div>
                    <div><strong>Detection Difficulty</strong></div>
                `;

                for (const cpu of cpuModels) {
                    signatureDiv.innerHTML += `
                        <div>${cpu.family}</div>
                        <div>${cpu.models.join(', ')}</div>
                        <div>${cpu.signature}</div>
                        <div>${cpu.family === 'ARM' ? 'Easy' : 'Difficult'}</div>
                    `;
                }

                output.appendChild(signatureDiv);

                addResult(' Implementation Challenges:', 'limitation');
                addResult('   - Browser security policies limit high-precision timing', 'limitation');
                addResult('   - WASM execution environment standardization reduces hardware differences', 'limitation');
                addResult('   - Requires large amounts of real device data to train models', 'limitation');

            } catch (error) {
                addResult(` Enhanced Detection Analysis Failed: ${error.message}`, 'limitation');
            }
        }

        async function analyzeSignatures() {
            try {
                addResult('===  Current Device Feature Signature Analysis ===', 'enhancement');
                const Module = await initWASM();

                // Multi-dimensional feature extraction
                addResult('Extracting multi-dimensional features...', 'enhancement');

                const features = {};

                // Memory access pattern - balanced cache hierarchy test
                const testSizes = [
                    // L1 cache test
                    { size: 32, label: '32KB (L1 boundary)', iterations: 500 },
                    { size: 64, label: '64KB', iterations: 500 },

                    // L2 cache test
                    { size: 256, label: '256KB (L2 boundary)', iterations: 300 },
                    { size: 512, label: '512KB', iterations: 300 },

                    // L3 cache test
                    { size: 2048, label: '2MB (L3 boundary)', iterations: 200 },
                    { size: 4096, label: '4MB', iterations: 100 },

                    // Main memory test (reduced to reasonable range)
                    { size: 8192, label: '8MB (main memory)', iterations: 50 }
                ];

                addResult('ðŸ”§ Starting cache eviction test...', 'enhancement');

                for (let testCase of testSizes) {
                    // Cache eviction: first access large amounts of unrelated data to clear cache
                    addResult(`Test ${testCase.label} (${testCase.iterations}iterations)...`, 'enhancement');

                    // Multiple iteration tests to improve accuracy and stability
                    let seqTimes = [];
                    let randTimes = [];

                    for (let run = 0; run < 3; run++) {  // Reduced to 3 iteration repeat tests
                        // Lightweight cache eviction: access smaller data to clear cache
                        Module._sequential_access_test(8192, 5);  // 8MB to clear cache

                        // Test sequential access
                        const seqStart = performance.now();
                        Module._sequential_access_test(testCase.size, testCase.iterations);
                        const seqTime = performance.now() - seqStart;
                        seqTimes.push(seqTime);

                        // Another iteration of cache eviction
                        Module._random_access_test(8192, 5);  // 8MB to clear cache

                        // Test random access
                        const randStart = performance.now();
                        Module._random_access_test(testCase.size, testCase.iterations);
                        const randTime = performance.now() - randStart;
                        randTimes.push(randTime);
                    }

                    // Calculate average time and standard deviation
                    const avgSeqTime = seqTimes.reduce((a, b) => a + b) / seqTimes.length;
                    const avgRandTime = randTimes.reduce((a, b) => a + b) / randTimes.length;

                    const seqStdDev = Math.sqrt(seqTimes.reduce((sum, time) => sum + Math.pow(time - avgSeqTime, 2), 0) / seqTimes.length);
                    const randStdDev = Math.sqrt(randTimes.reduce((sum, time) => sum + Math.pow(time - avgRandTime, 2), 0) / randTimes.length);

                    // Calculate time ratio (should have significant difference now)
                    if (avgSeqTime > 1.0 && avgRandTime > 1.0) {  // 1ms minimum threshold
                        const ratio = avgRandTime / avgSeqTime;
                        features[`mem_ratio_${testCase.size}KB`] = ratio;

                        // Also record stability metrics
                        features[`mem_stability_${testCase.size}KB`] = (seqStdDev + randStdDev) / (avgSeqTime + avgRandTime);

                        addResult(`   ${testCase.label}: Ratio=${ratio.toFixed(3)}, Sequential=${avgSeqTime.toFixed(1)}msÂ±${seqStdDev.toFixed(1)}, Random=${avgRandTime.toFixed(1)}msÂ±${randStdDev.toFixed(1)}`, 'enhancement');
                    } else {
                        features[`mem_ratio_${testCase.size}KB`] = 1.0;
                        addResult(`   ${testCase.label}: Execution time too short to measure`, 'enhancement');
                    }
                }

                // Calculation features - balanced iteration count
                addResult(' Calculating performance test...', 'enhancement');
                features.float_precision = Module._float_precision_test(2000);
                features.integer_opt = Module._integer_optimization_test(2000);
                features.branch_pred = Module._branch_prediction_test(3000);
                features.vector_comp = Module._vector_computation_test(500);

                // Stride sensitivity test - different CPU prefetchers react differently
                addResult('ðŸƒ Stride sensitivity test...', 'enhancement');
                const strideTests = [
                    { stride: 64, label: '1 cache line (64B)' },
                    { stride: 128, label: '2 cache lines (128B)' },
                    { stride: 256, label: '4 cache lines (256B)' },
                    { stride: 512, label: '8 cache lines (512B)' },
                    { stride: 4096, label: '1 memory page (4KB)' }
                ];

                const strideResults = {};
                for (const test of strideTests) {
                    const start = performance.now();
                    const result = Module._stride_access_test(512, test.stride, 500); // 512KB data, reduced iterations
                    const time = performance.now() - start;

                    strideResults[test.stride] = { result, time };
                    features[`stride_${test.stride}`] = time;

                    if (time > 0) {
                        addResult(`   ${test.label}: ${time.toFixed(1)}ms`, 'enhancement');
                    } else {
                        addResult(`   ${test.label}: Test failed (time too short)`, 'limitation');
                    }
                }

                // Prefetcher Efficiency analysis - using multi-stride stable calculation
                let prefetchEfficiency;
                let strongPrefetcher = false; // Moved to outer scope
                const validStrides = [];

                // Collect all valid stride test results
                [64, 128, 256, 512, 4096].forEach(stride => {
                    if (strideResults[stride] && strideResults[stride].time > 0.001) {
                        validStrides.push({
                            stride: stride,
                            time: strideResults[stride].time,
                            label: stride < 1024 ? `${stride}B` : `${stride/1024}KB`
                        });
                    }
                });

                if (validStrides.length >= 3) {
                    // Using comparison of minimum stride vs maximum stride, more stable
                    const smallStride = validStrides[0]; // Smallest
                    const largeStride = validStrides[validStrides.length - 1]; // Largest

                    // If large stride is significantly slower than small stride, prefetcher is effective
                    prefetchEfficiency = smallStride.time / largeStride.time;

                    // Improved trend verification: distinguish between strong prefetcher and abnormal situations
                    let trendConsistent = true;

                    // Check if it is strong prefetcher mode (larger strides result in shorter times)
                    let descendingCount = 0;
                    for (let i = 1; i < validStrides.length; i++) {
                        if (validStrides[i].time < validStrides[i-1].time) {
                            descendingCount++;
                        }

                        // Only consider it truly abnormal if time suddenly becomes 1/10 of original
                        if (validStrides[i].time < validStrides[i-1].time * 0.1) {
                            trendConsistent = false;
                            break;
                        }
                    }

                    // If most tests are decreasing, this may be strong prefetcher characteristic
                    if (descendingCount >= validStrides.length * 0.6) {
                        strongPrefetcher = true;
                    }

                    if (!trendConsistent) {
                        addResult(` Stride test data abnormal (exists 10x or more variation)`, 'limitation');
                        prefetchEfficiency = null;
                    } else {
                        const trendDesc = strongPrefetcher ? "Strong prefetcher characteristics" : "Standard cache characteristics";
                        addResult(` ${trendDesc}: ${smallStride.label}(${smallStride.time.toFixed(1)}ms) vs ${largeStride.label}(${largeStride.time.toFixed(1)}ms)`, 'enhancement');

                        // For strong prefetcher, adjust efficiency calculation method
                        if (strongPrefetcher) {
                            // Strong prefetcher efficiency using inverse relationship is more reasonable
                            prefetchEfficiency = largeStride.time / smallStride.time;
                            addResult(` Detected strong prefetcher mode, using adjusted calculation method`, 'enhancement');
                        }
                    }
                } else if (validStrides.length >= 2) {
                    // At least 2 valid tests, using backup calculation
                    const first = validStrides[0];
                    const last = validStrides[validStrides.length - 1];
                    prefetchEfficiency = first.time / last.time;
                    addResult(` Stride test data limited, using${first.label}vs${last.label}calculation`, 'limitation');
                } else {
                    // Too little test data
                    prefetchEfficiency = null;
                    addResult(` Prefetcher test failed - less than 2 valid stride tests`, 'limitation');
                }

                features.prefetch_efficiency = prefetchEfficiency;

                // Save Apple Silicon special architecture features for subsequent analysis
                // Temporarily set to false at this stage, will be updated in basic detection
                features.apple_memory_pattern = false;

                if (prefetchEfficiency && isFinite(prefetchEfficiency) && prefetchEfficiency > 0) {
                    // Provide more meaningful explanation based on Prefetcher Efficiency, considering strong prefetcher mode
                    let interpretation = "";
                    let prefetchStrength = "";

                    if (strongPrefetcher) {
                        // Strong prefetcher mode: smaller ratio indicates stronger prefetcher
                        if (prefetchEfficiency < 0.3) {
                            interpretation = " - Ultra-strong prefetcher (Apple Silicon level)";
                            prefetchStrength = "Ultra-strong";
                        } else if (prefetchEfficiency < 0.6) {
                            interpretation = " - Strong prefetcher (high-end CPU)";
                            prefetchStrength = "Strong";
                        } else if (prefetchEfficiency < 1.0) {
                            interpretation = " - Medium prefetcher";
                            prefetchStrength = "Medium";
                        } else {
                            interpretation = " - Normal prefetcher";
                            prefetchStrength = "Normal";
                        }
                    } else {
                        // Standard mode: traditional interpretation
                        if (prefetchEfficiency < 0.5) {
                            interpretation = " - Ultra-strong prefetcher";
                            prefetchStrength = "Ultra-strong";
                        } else if (prefetchEfficiency < 1.0) {
                            interpretation = " - Strong prefetcher";
                            prefetchStrength = "Strong";
                        } else if (prefetchEfficiency < 3.0) {
                            interpretation = " - Medium prefetcher";
                            prefetchStrength = "Medium";
                        } else if (prefetchEfficiency < 10.0) {
                            interpretation = " - prefetcher effectNormal";
                            prefetchStrength = "Normal";
                        } else {
                            interpretation = " - Weak prefetcher";
                            prefetchStrength = "weak";
                        }
                    }

                    features.prefetch_strength = prefetchStrength; // Save prefetcher strength
                    addResult(` Prefetcher Efficiency: ${prefetchEfficiency.toFixed(2)}${interpretation}`, 'enhancement');
                } else {
                    addResult(` Prefetcher Efficiency: test invalid`, 'limitation');
                }

                // CPU stress characteristics test - test multi-core performance degradation curve
                addResult('ðŸ’ª CPUstress characteristicsTest...', 'enhancement');
                const pressureTests = [];

                // Baseline performance (no stress)
                const baselineStart = performance.now();
                Module._integer_optimization_test(1000);
                const baselineTime = performance.now() - baselineStart;

                // Light stress test (background calculation)
                const lightPressureStart = performance.now();
                Module._float_precision_test(500); // backgroundFloat Computation
                Module._integer_optimization_test(1000);
                const lightPressureTime = performance.now() - lightPressureStart;

                // Calculate performance degradation rate
                const performanceDrop = baselineTime > 0 ? (lightPressureTime - baselineTime) / baselineTime : 0;
                features.pressure_resistance = Math.max(0, performanceDrop); // Ensure non-negative value
                const dropPercent = isFinite(performanceDrop) ? (performanceDrop * 100).toFixed(1) : '0.0';
                addResult(`ðŸ“‰ Performance degradation under stress: ${dropPercent}% (Smaller value indicates stronger stress resistance)`, 'enhancement');

                // Cache associativity test - optimized precision for Apple Silicon
                addResult('ðŸ”„ cache associativityTest...', 'enhancement');
                const conflictTests = [
                    { offset: 4096, label: '4KBinterval', iterations: 8000, size: 256 },
                    { offset: 8192, label: '8KBinterval', iterations: 6000, size: 512 },
                    { offset: 16384, label: '16KBinterval', iterations: 4000, size: 512 },
                    { offset: 32768, label: '32KBinterval', iterations: 3000, size: 1024 }
                ];

                let worstConflict = 0;
                let validConflictTests = 0;

                for (const test of conflictTests) {
                    // More aggressive multi-iteration runs to overcome Apple Silicon optimizations
                    const times = [];
                    for (let run = 0; run < 5; run++) {
                        // Warm-up run to avoid cold start effects
                        if (run === 0) {
                            Module._alignment_sensitivity_test(test.size, test.offset, test.iterations / 4);
                        }

                        const start = performance.now();
                        Module._alignment_sensitivity_test(test.size, test.offset, test.iterations);
                        const time = performance.now() - start;

                        // Reduce precision requirement, adapt to Apple Silicon's efficient cache
                        if (time > 0.05) times.push(time);
                    }

                    let finalTime = 0;
                    if (times.length >= 2) {
                        times.sort((a, b) => a - b);
                        finalTime = times[Math.floor(times.length / 2)]; // median
                        validConflictTests++;
                    } else if (times.length === 1) {
                        finalTime = times[0];
                        validConflictTests++;
                    }

                    features[`conflict_${test.offset}`] = finalTime;

                    if (finalTime > 0.05 && baselineTime > 0.05) {
                        const conflictRatio = finalTime / baselineTime;
                        if (conflictRatio > worstConflict) worstConflict = conflictRatio;
                        addResult(`   ${test.label}: ${finalTime.toFixed(1)}ms (Ratio${conflictRatio.toFixed(2)})`, 'enhancement');
                    } else {
                        addResult(`   ${test.label}: Test has insufficient precision (${finalTime.toFixed(3)}ms) - Apple Silicon cache may be too efficient`, 'limitation');
                    }
                }

                // Verify validity of cache conflict test
                if (validConflictTests >= 2 && worstConflict > 0.1) {
                    features.cache_conflict_sensitivity = worstConflict;
                    addResult(` Cache conflict sensitivity: ${worstConflict.toFixed(3)} (Intelusually<1.5, AMDmay>1.5)`, 'enhancement');
                } else {
                    features.cache_conflict_sensitivity = 1.0; // Default value
                    addResult(` Cache conflict test has insufficient precision (valid tests${validConflictTests})`, 'limitation');
                }

                // special computation fingerprintTest
                addResult('ðŸ§® special computation fingerprint...', 'enhancement');

                // Division vs multiplication performance ratio
                const divStart = performance.now();
                for (let i = 0; i < 10000; i++) {
                    const result = (i * 12345) / 67890; // Enforce division operation
                }
                const divTime = performance.now() - divStart;

                const mulStart = performance.now();
                for (let i = 0; i < 10000; i++) {
                    const result = i * 12345 * 67890; // Pure multiplication operation
                }
                const mulTime = performance.now() - mulStart;

                const divMulRatio = mulTime > 0.001 ? divTime / mulTime : 1.0;
                features.division_efficiency = isFinite(divMulRatio) ? divMulRatio : 1.0;
                const divDisplay = isFinite(divMulRatio) ? divMulRatio.toFixed(2) : '1.00';
                addResult(`âž— divisionefficiency: ${divDisplay} (Intelusually<5, AMDmay>5)`, 'enhancement');

                if (typeof features.simd_supported === 'boolean') {
                    const simdStatus = features.simd_supported ? 'support (WASM SIMD Enabled)' : 'Not Detected';
                    addResult(` SIMD Instruction Extension: ${simdStatus}`, features.simd_supported ? 'cpu-info' : 'limitation');

                    if (features.simd_supported && typeof features.simd_speedup === 'number' && isFinite(features.simd_speedup)) {
                        addResult(`   SIMD relative to integer speed: ${features.simd_speedup.toFixed(2)}x`, 'cpu-info');
                    }
                }

                const logicalCores = typeof features.hardware_concurrency === 'number' && isFinite(features.hardware_concurrency)
                    ? features.hardware_concurrency : null;
                const workerCap = typeof features.worker_spawn_cap === 'number' && isFinite(features.worker_spawn_cap)
                    ? features.worker_spawn_cap : null;

                if (logicalCores || workerCap) {
                    addResult('ðŸ§µ Concurrency capability detection:', 'cpu-info');
                    if (logicalCores) {
                        addResult(`   navigator.hardwareConcurrency â‰ˆ ${logicalCores}`, 'cpu-info');
                    }
                    if (workerCap) {
                        const latency = typeof features.worker_latency_median === 'number' && isFinite(features.worker_latency_median)
                            ? `${features.worker_latency_median.toFixed(2)}ms` : 'N/A';
                        addResult(`   Worker stable concurrency: ${workerCap}  (median round-trip ${latency})`, 'cpu-info');
                    }
                }

                addResult(' Device Feature Signature:', 'cpu-info');

                // Display memory test results in groups for easier Cache Boundary observation
                addResult(' Memory Access Pattern (Finding Cache Boundaries):', 'cpu-info');
                const memoryTests = Object.entries(features)
                    .filter(([k, v]) => k.startsWith('mem_ratio'))
                    .sort((a, b) => {
                        const sizeA = parseInt(a[0].replace('mem_ratio_', '').replace('KB', ''));
                        const sizeB = parseInt(b[0].replace('mem_ratio_', '').replace('KB', ''));
                        return sizeA - sizeB;
                    });

                for (const [key, value] of memoryTests) {
                    const size = key.replace('mem_ratio_', '').replace('KB', '');
                    const color = value > 1.6 ? 'style="color: #f85149; font-weight: bold;"' :
                                  value > 1.4 ? 'style="color: #f0d000; font-weight: bold;"' :
                                  'style="color: #56d364;"';
                    addResult(`   ${size}KB: <span class="highlight" ${color}>${value.toFixed(4)}</span> ${value > 1.6 ? ' Definite Cache Boundary' : value > 1.4 ? ' possible boundary' : ''}`, 'cpu-info');
                }

                addResult(' Calculation performance features:', 'cpu-info');
                const hiddenKeys = new Set([
                    'mem_ratio_l1_band',
                    'mem_ratio_deep',
                    'prefetch_efficiency',
                    'prefetch_strength',
                    'apple_memory_pattern',
                    'simd_supported',
                    'simd_speedup',
                    'simd_vector_ratio',
                    'hardware_concurrency',
                    'worker_spawn_cap',
                    'worker_latency_median',
                    'worker_latency_mean'
                ]);

                const computeTests = Object.entries(features)
                    .filter(([k, v]) => !k.startsWith('mem_ratio') && !hiddenKeys.has(k));

                for (const [key, value] of computeTests) {
                    if (typeof value === 'number' && isFinite(value)) {
                        addResult(`   ${key}: <span class="highlight">${value.toFixed(4)}</span>`, 'cpu-info');
                    }
                }

                // Feature vector analysis
                const signature = Object.values(features).filter(v => typeof v === 'number' && isFinite(v));
                let hash = 0;
                for (let i = 0; i < signature.length; i++) {
                    hash = ((hash << 5) - hash + signature[i] * 1000) & 0xffffffff;
                }

                addResult(`ðŸ”‘ device feature hash: <span class="highlight">${hash.toString(16)}</span>`, 'model-guess');

                // Cache Boundary Analysis algorithm
                const memRatioEntries = Object.entries(features)
                    .filter(([k, v]) => k.startsWith('mem_ratio') && typeof v === 'number' && v > 0.5 && v < 20)
                    .map(([k, v]) => ({ size: parseInt(k.replace('mem_ratio_', '').replace('KB', '')), ratio: v }))
                    .sort((a, b) => a.size - b.size);

                // Intelligent Cache Boundary detection algorithm
                let cacheTransitions = [];
                let l1Boundary = null;
                let l2Boundary = null;
                let l3Boundary = null;

                for (let i = 1; i < memRatioEntries.length; i++) {
                    const prev = memRatioEntries[i-1];
                    const curr = memRatioEntries[i];
                    const jump = curr.ratio / prev.ratio;

                    // Detect significant performance jumps
                    if (jump > 1.5) {  // 50% or more performance jump is considered a true Cache Boundary
                        let boundaryType = "Cache Boundary";

                        if (prev.size <= 128 && !l1Boundary) {
                            boundaryType = "L1Cache Boundary";
                            l1Boundary = `${prev.size}KB`;
                        } else if (prev.size <= 1024 && !l2Boundary) {
                            boundaryType = "L2Cache Boundary";
                            l2Boundary = `${prev.size}KB`;
                        } else if (prev.size <= 8192 && !l3Boundary) {
                            boundaryType = "L3Cache Boundary";
                            l3Boundary = `${prev.size}KB`;
                        }

                        cacheTransitions.push({
                            from: prev.size,
                            to: curr.size,
                            jump: jump,
                            boundary: `${boundaryType}: ${prev.size}KB â†’ ${curr.size}KB`,
                            type: boundaryType
                        });
                    }
                }

                // Supplement: even without jumps, judge based on empirical thresholds
                const heavyRatios = memRatioEntries.filter(entry => entry.ratio > 2.0);
                if (heavyRatios.length > 0 && cacheTransitions.length === 0) {
                    const firstHeavy = heavyRatios[0];
                    cacheTransitions.push({
                        boundary: `Suspected Cache Boundary: ${firstHeavy.size}KB (Ratio${firstHeavy.ratio.toFixed(2)})`,
                        type: "Speculated boundary"
                    });
                }

                addResult(' Cache Boundary Analysis:', 'model-guess');
                if (cacheTransitions.length > 0) {
                    for (const transition of cacheTransitions) {
                        addResult(`   ${transition.boundary} (Performance jump${transition.jump.toFixed(2)}x)`, 'model-guess');
                    }
                } else {
                    addResult('   No obvious cache performance boundary found', 'model-guess');
                }

                const validMemRatios = memRatioEntries.map(entry => entry.ratio);
                const memAvg = validMemRatios.length > 0 ?
                    validMemRatios.reduce((sum, v) => sum + v, 0) / validMemRatios.length : 1.0;

                // CPU recognition algorithm based on real cache tests
                let modelGuess = "UnknownModel";
                let confidence = "low";
                let evidencePoints = [];

                if (validMemRatios.length >= 5) {
                    // analysisL1 Cache Size
                    const l1Ratios = memRatioEntries.filter(e => e.size <= 128).map(e => e.ratio);
                    const l2Ratios = memRatioEntries.filter(e => e.size >= 256 && e.size <= 1024).map(e => e.ratio);
                    const l3Ratios = memRatioEntries.filter(e => e.size >= 2048).map(e => e.ratio);

                    const avgL1 = l1Ratios.length > 0 ? l1Ratios.reduce((a, b) => a + b) / l1Ratios.length : 1.0;
                    const avgL2 = l2Ratios.length > 0 ? l2Ratios.reduce((a, b) => a + b) / l2Ratios.length : 1.0;
                    const avgL3 = l3Ratios.length > 0 ? l3Ratios.reduce((a, b) => a + b) / l3Ratios.length : 1.0;

                    addResult(` Cache Hierarchy Analysis: L1 Average=${avgL1.toFixed(3)}, L2 Average=${avgL2.toFixed(3)}, L3 Average=${avgL3.toFixed(3)}`, 'model-guess');

                    // Cleaned up CPU Features detection algorithm
                    let score = { apple: 0, intel: 0, amd: 0 };
                    let featureLog = []; // Record all feature analysis

                    const simdSupported = !!features.simd_supported;
                    const workerCap = typeof features.worker_spawn_cap === 'number' && isFinite(features.worker_spawn_cap)
                        ? features.worker_spawn_cap : null;
                    const logicalCores = typeof features.hardware_concurrency === 'number' && isFinite(features.hardware_concurrency)
                        ? features.hardware_concurrency : null;

                    const prefetchEff = typeof features.prefetch_efficiency === 'number' && isFinite(features.prefetch_efficiency)
                        ? features.prefetch_efficiency : null;
                    const hasStrongPrefetch = prefetchEff !== null && prefetchEff > 0 && prefetchEff <= 0.7;
                    const hasUltraPrefetch = prefetchEff !== null && prefetchEff > 0 && prefetchEff <= 0.4;

                    // Apple Silicon characteristics scoring (updated thresholds to adapt to latest test data)
                    const l1Jump = l1Ratios.length >= 2 ? Math.max(...l1Ratios.map((v, idx) => idx < l1Ratios.length - 1 ? l1Ratios[idx + 1] / Math.max(0.5, v) : 0)) : 0;
                    const hasLargeL1 = avgL1 < 1.25 && l1Jump > 1.25;
                    const hasUnifiedMemory = avgL3 > 1.5 && avgL3 < 1.9;
                    const hasLowPressureDrop = typeof features.pressure_resistance === 'number' ? features.pressure_resistance < 0.2 : false;
                    const hasAppleCache = avgL1 < 1.25 && avgL2 > 1.5;

                    if (hasLargeL1) {
                        score.apple += 2;
                        featureLog.push(" Large L1 cache characteristics (+2 Apple)");
                    }
                    if (hasStrongPrefetch) {
                        score.apple += hasUltraPrefetch ? 3 : 2;
                        featureLog.push(hasUltraPrefetch ? " Ultra-strong prefetcher (+3 Apple)" : " Strong prefetcher (+2 Apple)");
                    }
                    if (hasUnifiedMemory) {
                        score.apple += 2;
                        featureLog.push(" Unified memory architecture (+2 Apple)");
                    }
                    if (hasLowPressureDrop) {
                        score.apple += 1;
                        featureLog.push(" Strong stress resistance (+1 Apple)");
                    }
                    if (hasAppleCache) {
                        score.apple += 3;
                        featureLog.push(" Apple unique cache architecture (+3 Apple)");
                    }

                    // Intel characteristics scoring (reduced weight to avoid confusion with Apple)
                    const hasTypicalL2 = avgL2 > 1.5 && avgL2 < 1.9 && avgL1 > 1.3; // L1 must also match Intel characteristics
                    const hasGoodDivision = features.division_efficiency && features.division_efficiency < 4 && avgL1 > 1.3;
                    const hasLowConflict = features.cache_conflict_sensitivity < 1.5;
                    const hasPositiveInt = features.integer_opt > 0;

                    // Only add score to Intel when not Apple features
                    const isNotApple = !hasAppleCache && avgL1 > 1.3;

                    if (hasTypicalL2 && isNotApple) {
                        score.intel += 2;
                        featureLog.push(" Typical L2 cache characteristics (+2 Intel)");
                    }
                    if (hasGoodDivision && isNotApple) {
                        score.intel += 2;
                        featureLog.push(" Efficient division unit (+2 Intel)");
                    }
                    if (hasLowConflict && isNotApple) {
                        score.intel += 1;
                        featureLog.push(" Low cache conflict (+1 Intel)");
                    }
                    if (hasPositiveInt && isNotApple) {
                        score.intel += 1;
                        featureLog.push(" Positive Integer Optimization (+1 Intel)");
                    }

                    // AMD characteristics scoring
                    const hasStrongL3 = avgL3 > 1.8;
                    const hasPoorDivision = features.division_efficiency && features.division_efficiency > 5;
                    const hasHighConflict = features.cache_conflict_sensitivity > 1.5;
                    const hasNegativeInt = features.integer_opt < 0;

                    if (hasStrongL3) {
                        score.amd += 2;
                        featureLog.push(" StrongL3cache characteristics (+2 AMD)");
                    }
                    if (hasPoorDivision) {
                        score.amd += 2;
                        featureLog.push(" Relatively slow division (+2 AMD)");
                    }
                    if (hasHighConflict) {
                        score.amd += 1;
                        featureLog.push(" Cache conflict sensitive (+1 AMD)");
                    }
                    if (hasNegativeInt) {
                        score.amd += 1;
                        featureLog.push(" Special integer features (+1 AMD)");
                    }

                    if (simdSupported) {
                        score.apple += 1;
                        score.intel += 1;
                        featureLog.push(" WASM SIMD Support (+1 Apple/+1 Intel)");
                    }

                    if (workerCap && workerCap >= 16) {
                        score.intel += 2;
                        score.apple += 1;
                        featureLog.push(` Workerconcurrencyâ‰¥${workerCap} (+2 Intel, +1 Apple)`);
                    } else if (workerCap && workerCap >= 10) {
                        score.apple += 1;
                        featureLog.push(` Workerconcurrencyâ‰¥${workerCap} (+1 Apple)`);
                    }

                    if (logicalCores && logicalCores >= 16) {
                        score.intel += 2;
                        featureLog.push(` hardware concurrencyâ‰ˆ${logicalCores} (+2 Intel)`);
                    } else if (logicalCores && logicalCores >= 10) {
                        score.apple += 1;
                        featureLog.push(` hardware concurrencyâ‰ˆ${logicalCores} (+1 Apple)`);
                    }

                    // Determine result based on score
                    const maxScore = Math.max(score.apple, score.intel, score.amd);

                    if (maxScore >= 5) {
                        confidence = "high";
                    } else if (maxScore >= 3) {
                        confidence = "in";
                    } else {
                        confidence = "low";
                    }

                    // Clean up evidence pointss, only show features of the winning side
                    evidencePoints = [];

                    if (score.apple === maxScore && maxScore >= 3) {
                        modelGuess = "Apple Silicon (M1/M2/M3series)";
                        evidencePoints.push(`Applefeature score: ${score.apple}score`);
                        evidencePoints.push(...featureLog.filter(log => log.includes("Apple")));
                    } else if (score.intel === maxScore && maxScore >= 3) {
                        modelGuess = "Intel High-Performance CPU (Core i5/i7/i9)";
                        evidencePoints.push(`Intel characteristics score: ${score.intel}score`);
                        evidencePoints.push(...featureLog.filter(log => log.includes("Intel")));
                    } else if (score.amd === maxScore && maxScore >= 3) {
                        modelGuess = "AMD Ryzenseries";
                        evidencePoints.push(`AMD characteristics score: ${score.amd}score`);
                        evidencePoints.push(...featureLog.filter(log => log.includes("AMD")));
                    } else {
                        modelGuess = "Modern high-performance CPU (type uncertain)";
                        evidencePoints.push(`Low scores: Apple=${score.apple}, Intel=${score.intel}, AMD=${score.amd}`);
                        evidencePoints.push(...featureLog.slice(0, 3)); // Only show first 3 features
                    }

                    // Prefetcher analysisincreaseStrongConfidence
                    if (features.prefetch_efficiency) {
                        if (features.prefetch_efficiency < 1.0) {
                            evidencePoints.push("Ultra-strong prefetcher (mayisApple/high-endIntel)");
                            if (confidence === "in") confidence = "high";
                        } else if (features.prefetch_efficiency > 10) {
                            evidencePoints.push("prefetcher effectNormal (mayisAMD/Mainstream CPU)");
                        }
                    }

                } else {
                    modelGuess = "Test has insufficient data, cannot accurately analyze";
                    confidence = "Very low";
                }

                addResult(` Model Inference: <span class="highlight">${modelGuess}</span>`, 'model-guess');
                addResult(` Confidence: <span class="highlight">${confidence}</span> (based on${validMemRatios.length}validfeature)`, 'model-guess');

                // Display evidence pointss
                if (evidencePoints.length > 0) {
                    addResult(' Identification Basis:', 'model-guess');
                    for (const evidence of evidencePoints) {
                        addResult(`   - ${evidence}`, 'model-guess');
                    }
                }

                addResult(' Note: This is only speculation based on limited features, actual accuracy is affected by multiple factors', 'limitation');

                // Execute result verification
                const validation = validateTestResults(features);
                if (validation.issues.length > 0 || validation.warnings.length > 0) {
                    addResult(' Test quality assessment:', 'enhancement');

                    if (validation.issues.length > 0) {
                        addResult(' Issues Found:', 'limitation');
                        validation.issues.forEach(issue => {
                            addResult(`   - ${issue}`, 'limitation');
                        });
                    }

                    if (validation.warnings.length > 0) {
                        addResult(' Warning:', 'limitation');
                        validation.warnings.forEach(warning => {
                            addResult(`   - ${warning}`, 'limitation');
                        });
                    }

                    // Calculate test quality score
                    const qualityScore = Math.max(0, 100 - validation.issues.length * 20 - validation.warnings.length * 10);
                    let qualityLevel;
                    if (qualityScore >= 80) qualityLevel = "Excellent";
                    else if (qualityScore >= 60) qualityLevel = "Good";
                    else if (qualityScore >= 40) qualityLevel = "Normal";
                    else qualityLevel = "Poor";

                    addResult(` Test quality score: ${qualityScore}/100 (${qualityLevel})`, 'enhancement');
                } else {
                    addResult(' Test quality: Excellent (No obvious issues found)', 'enhancement');
                }

            } catch (error) {
                addResult(` Feature Analysis Failed: ${error.message}`, 'limitation');
            }
        }

        // WebGLdetection function
        async function runWebGLDetection() {
            try {
                addResult('=== ðŸŽ¨ WebGL GPU Detection ===', 'enhancement');

                const webglFP = new WebGLFingerprinter();
                const fingerprint = await webglFP.generateFingerprint();

                if (!fingerprint) {
                    addResult(' WebGLnotAvailable: Browser not supported or disabled', 'model-guess');
                    return;
                }

                addResult(' GPU Basic Information:', 'cpu-info');
                addResult(`   Vendor: ${fingerprint.basic.vendor}`, 'cpu-info');
                addResult(`   Renderer: ${fingerprint.basic.renderer}`, 'cpu-info');
                addResult(`   Version: ${fingerprint.basic.version}`, 'cpu-info');

                addResult(' Extension Support:', 'cpu-info');
                addResult(`   Total Extensions: ${fingerprint.extensions.count}`, 'cpu-info');
                addResult(`   Important Extensions: ${fingerprint.extensions.important.length}`, 'cpu-info');

                addResult(' Canvas Fingerprint:', 'cpu-info');
                addResult(`   Main Fingerprint: ${fingerprint.canvasHash}`, 'cpu-info');
                const canvasVariants = fingerprint.canvasVariants || {};
                const variantEntries = Object.entries(canvasVariants);
                if (variantEntries.length > 0) {
                    addResult('   Fingerprint Variants:', 'cpu-info');
                    variantEntries.forEach(([variantKey, variantValue]) => {
                        addResult(`     - ${variantKey}: ${variantValue}`, 'cpu-info');
                    });
                }

                if (fingerprint.performance) {
                    addResult(' Rendering Performance:', 'cpu-info');
                    addResult(`   Simple Rendering: ${fingerprint.performance.simpleRender?.toFixed(2)}ms`, 'cpu-info');
                    addResult(`   Complex Rendering: ${fingerprint.performance.complexRender?.toFixed(2)}ms`, 'cpu-info');
                    addResult(`   Texture Operations: ${fingerprint.performance.textureOps?.toFixed(2)}ms`, 'cpu-info');
                }

                // GPUModelanalysis
                const analysis = webglFP.analyzeGPUModel(fingerprint);
                addResult(' WebGL GPUModel Inference:', 'model-guess');
                addResult(`   Model: ${analysis.model}`, 'model-guess');
                addResult(`   Confidence: ${analysis.confidence}%`, 'model-guess');
                if (analysis.evidence.length > 0) {
                    addResult('   Inference Basis:', 'model-guess');
                    analysis.evidence.forEach(evidence => {
                        addResult(`     - ${evidence}`, 'model-guess');
                    });
                }

                webglFP.cleanup();

            } catch (error) {
                addResult(` WebGL Detection Exception: ${error.message}`, 'limitation');
            }
        }

        // WebGPUdetection function
        async function runWebGPUDetection() {
            try {
                addResult('===  WebGPU GPU Detection ===', 'enhancement');

                const webgpuFP = new WebGPUFingerprinter();
                const fingerprint = await webgpuFP.generateFingerprint();

                if (!fingerprint) {
                    addResult(' WebGPUnotAvailable: Browser not supported or disabled', 'model-guess');
                    return;
                }

                addResult(' GPU Adapter Information:', 'cpu-info');
                const adapter = fingerprint.adapter;
                addResult(`   Vendor: ${adapter.vendor || 'Unknown'}`, 'cpu-info');
                addResult(`   architecture: ${adapter.architecture || 'Unknown'}`, 'cpu-info');
                addResult(`   device: ${adapter.device || 'Unknown'}`, 'cpu-info');
                addResult(`   Description: ${adapter.description || 'Unknown'}`, 'cpu-info');
                if (adapter.subgroupMaxSize) {
                    addResult(`   Subgroup size: ${adapter.subgroupMinSize}-${adapter.subgroupMaxSize}`, 'cpu-info');
                }

                addResult('ðŸ’ª GPUcapability:', 'cpu-info');
                const caps = fingerprint.capabilities;
                addResult(`   supportfeatures: ${caps.features?.length || 0}`, 'cpu-info');
                if (caps.limits) {
                    addResult(`   maximum texture size: ${caps.limits.maxTextureSize}`, 'cpu-info');
                    addResult(`   maximum buffer: ${caps.limits.maxBufferSize}bytes`, 'cpu-info');
                    addResult(`   maximum workgroup: ${caps.limits.maxComputeWorkgroupSizeX}`, 'cpu-info');
                }

                if (fingerprint.timing) {
                    addResult('â±ï¸ GPUperformanceanalysis:', 'cpu-info');

                    if (fingerprint.timing.timerResolution) {
                        const timer = fingerprint.timing.timerResolution;
                        addResult(`   timerscoreresolution: ${timer.average?.toFixed(3)}ms (Â±${timer.standardDeviation?.toFixed(3)})`, 'cpu-info');
                    }

                    if (fingerprint.timing.memoryBandwidth) {
                        const mem = fingerprint.timing.memoryBandwidth;
                        if (typeof mem.bandwidthGB === 'number' && isFinite(mem.bandwidthGB)) {
                            addResult(`   memory bandwidth: ${mem.bandwidthGB.toFixed(2)} GB/s`, 'cpu-info');
                        } else if (typeof mem.bandwidthMB === 'number' && isFinite(mem.bandwidthMB)) {
                            addResult(`   memory bandwidth: ${mem.bandwidthMB.toFixed(2)} MB/s`, 'cpu-info');
                        }
                    }

                    if (fingerprint.timing.computeLatency) {
                        const compute = fingerprint.timing.computeLatency;
                        addResult(`   simplecalculation: ${compute.simple?.toFixed(2)}ms`, 'cpu-info');
                        addResult(`   math intensive: ${compute.math_intensive?.toFixed(2)}ms`, 'cpu-info');
                        addResult(`   Memoryintensive: ${compute.memory_intensive?.toFixed(2)}ms`, 'cpu-info');
                    }

                    if (fingerprint.timing.cacheProfile) {
                        const cache = fingerprint.timing.cacheProfile;
                        addResult(`   cacheefficiency: ${cache.cacheEfficiency?.toFixed(2)}`, 'cpu-info');
                    }
                }

                // GPUModelanalysis
                const analysis = webgpuFP.analyzeGPUModel(fingerprint);
                addResult(' WebGPU GPUModel Inference:', 'model-guess');
                addResult(`   Model: ${analysis.model}`, 'model-guess');
                addResult(`   Confidence: ${analysis.confidence}%`, 'model-guess');
                if (analysis.evidence.length > 0) {
                    addResult('   Inference Basis:', 'model-guess');
                    analysis.evidence.forEach(evidence => {
                        addResult(`     - ${evidence}`, 'model-guess');
                    });
                }

                webgpuFP.cleanup();

            } catch (error) {
                addResult(` WebGPU Detection Exception: ${error.message}`, 'limitation');
            }
        }

        async function ensureCommonLoaded() {
            if (typeof WASMFingerprint === 'function' && window.wasmFingerprint instanceof WASMFingerprint) {
                return;
            }
            if (typeof WASMFingerprint === 'function' && !window.wasmFingerprint) {
                window.wasmFingerprint = new WASMFingerprint();
                return;
            }
            await new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = `./src/common.js?v=${Date.now()}`;
                script.dataset.autoLoaded = 'common';
                script.onload = resolve;
                script.onerror = () => reject(new Error('failed to load common.js'));
                document.head.appendChild(script);
            });
            if (typeof WASMFingerprint === 'function' && !(window.wasmFingerprint instanceof WASMFingerprint)) {
                window.wasmFingerprint = new WASMFingerprint();
            }
        }

        async function exportCalibrationSample() {
            try {
                addResult('===  Export calibration sample ===', 'enhancement');

                await initWASM();
                await ensureCommonLoaded();
                let wasmHelper = window.wasmFingerprint;
                const errors = {};

                let wasmFingerprint = null;
                try {
                    if (!wasmHelper || typeof wasmHelper.generateFingerprint !== 'function') {
                        throw new Error('WASM Fingerprint helper not loaded');
                    }
                    // preload calibration dataï¼Œfacilitate subsequent databasescoreutilize thresholds
                    try { await wasmHelper.loadCalibration(); } catch (_e) {}
                    wasmFingerprint = await wasmHelper.generateFingerprint();
                } catch (err) {
                    errors.wasm = err?.message || String(err);
                    addResult(` Unable to acquire WASM fingerprint: ${errors.wasm}`, 'limitation');
                }

                let webglFingerprint = null;
                try {
                    const webglFP = new WebGLFingerprinter();
                    webglFingerprint = await webglFP.generateFingerprint();
                    webglFP.cleanup();
                    if (!webglFingerprint) {
                        addResult(' WebGLfingerprint notAvailableï¼ŒWill be recorded in sample nullã€‚', 'model-guess');
                    }
                } catch (err) {
                    errors.webgl = err?.message || String(err);
                    addResult(` Unable to acquire WebGL fingerprint: ${errors.webgl}`, 'limitation');
                }

                let webgpuFingerprint = null;
                try {
                    const webgpuFP = new WebGPUFingerprinter();
                    webgpuFingerprint = await webgpuFP.generateFingerprint();
                    webgpuFP.cleanup();
                    if (!webgpuFingerprint) {
                        addResult(' WebGPUfingerprint notAvailableï¼ŒWill be recorded in sample nullã€‚', 'model-guess');
                    }
                } catch (err) {
                    errors.webgpu = err?.message || String(err);
                    addResult(` Unable to acquire WebGPU fingerprint: ${errors.webgpu}`, 'limitation');
                }

                const sample = {
                    createdAt: new Date().toISOString(),
                    userAgent: navigator.userAgent,
                    wasm: wasmFingerprint,
                    webgl: webglFingerprint,
                    webgpu: webgpuFingerprint,
                    meta: {
                        page: 'enhanced-detection.html',
                        wasmRuntimeInitialized: !!(wasmModule && wasmModule.runtimeInitialized)
                    },
                    errors
                };

                const blob = new Blob([JSON.stringify(sample, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                link.href = url;
                link.download = `calibration-sample-${timestamp}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                if (Object.keys(errors).length) {
                    addResult(' Sample exported but contains some missing fieldsï¼›Please check errors in JSONã€‚', 'limitation');
                } else {
                    addResult(' Sample exported, please place JSON in docs/device-database/samples/ then run ingestã€‚', 'cpu-info');
                }

            } catch (error) {
                console.error('exportCalibrationSample failed', error);
                addResult(` Sample Export Failed: ${error.message}`, 'limitation');
            }
        }

        async function runRealWorldDetection() {
            try {
                addResult('===  Real Environment Detection Started ===', 'enhancement');
                await initWASM();
                await ensureCommonLoaded();

                if (typeof RealWorldDetector !== 'function') {
                    throw new Error('RealWorldDetector not loaded');
                }

                const detector = new RealWorldDetector();
                const report = await detector.detect();

                addResult('ðŸ§± Basic Signals:', 'cpu-info');
                addResult(`   cores: ${report.basic.hardwareConcurrency ?? 'Unknown'}`, 'cpu-info');
                addResult(`   deviceMemory: ${report.basic.deviceMemory ?? 'Unknown'} GB`, 'cpu-info');
                addResult(`   platform: ${report.basic.platform ?? 'Unknown'}`, 'cpu-info');

                addResult(' Advanced Capability Detection:', 'enhancement');
                const simdStatus = report.advanced.simd === null ? 'Unknown' : (report.advanced.simd ? ' SIMD Supported' : ' notSIMD Supported');
                const simdClass = report.advanced.simd === true ? 'cpu-info' : (report.advanced.simd === false ? 'limitation' : 'enhancement');
                addResult(`   SIMD: ${simdStatus}`, simdClass);
                const sabStatus = report.advanced.sharedArrayBuffer ? ' Available' : ' notAvailable';
                addResult(`   SharedArrayBuffer: ${sabStatus}`, report.advanced.sharedArrayBuffer ? 'cpu-info' : 'limitation');
                if (report.advanced.webgpu.available) {
                    const detected = report.advanced.webgpu.detected ? ' Fingerprint Acquired' : ' Availablebut collectFailed';
                    addResult(`   WebGPU: ${detected}`, report.advanced.webgpu.detected ? 'cpu-info' : 'limitation');
                    if (report.advanced.webgpu.analysis) {
                        addResult(`     - ${report.advanced.webgpu.analysis.model} (${report.advanced.webgpu.analysis.confidence}%)`, 'cpu-info');
                    }
                    if (report.advanced.webgpu.error) {
                        addResult(`     - Error: ${report.advanced.webgpu.error}`, 'limitation');
                    }
                } else {
                    addResult('   WebGPU:  notAvailable', 'limitation');
                }

                addResult('ðŸ”„ Fallback Features:', 'cpu-info');
                if (report.fallback.wasm?.summary) {
                    const wasm = report.fallback.wasm.summary;
                    addResult(`   WASM CPU Family: ${wasm.cpuFamily ?? 'Unknown'} (${wasm.confidence ?? 0}% confidence)`, 'cpu-info');
                    addResult(`     L1Ratio: ${wasm.l1Band ?? 'N/A'} | deepRatio: ${wasm.deepBand ?? 'N/A'}`, 'cpu-info');
                }
                if (report.fallback.webgl?.summary) {
                    const webgl = report.fallback.webgl.summary;
                    addResult(`   WebGL Renderer: ${webgl.renderer ?? 'Unknown'}`, 'cpu-info');
                    addResult(`     CanvasHash: ${webgl.canvasHash ?? 'N/A'}`, 'cpu-info');
                    if (webgl.blendHash || webgl.canvas2DHash) {
                        addResult(`     Blend: ${webgl.blendHash ?? 'N/A'}, Canvas2D: ${webgl.canvas2DHash ?? 'N/A'}`, 'cpu-info');
                    }
                }
                const fallbackErrors = Object.entries(report.fallback.errors || {});
                if (fallbackErrors.length) {
                    addResult('    FallbackError:', 'limitation');
                    fallbackErrors.forEach(([key, message]) => addResult(`     - ${key}: ${message}`, 'limitation'));
                }

                addResult(' Comprehensive Conclusion:', 'model-guess');
                addResult(`   Identified Device: ${report.analysis.device}`, 'model-guess');
                addResult(`   Method: ${report.analysis.method} (${report.analysis.tier})`, 'model-guess');
                addResult(`   Confidence: ${report.analysis.confidence}%`, 'model-guess');
                if (Array.isArray(report.analysis.evidence) && report.analysis.evidence.length) {
                    report.analysis.evidence.forEach(ev => addResult(`   - ${ev}`, 'model-guess'));
                }

                const dbSignal = report.analysis.signals?.databaseResult;
                if (dbSignal && dbSignal.deviceModel) {
                    addResult(`   Database Match: ${dbSignal.deviceModel} (${dbSignal.confidence}% )`, 'model-guess');
                }

                if (Array.isArray(report.timeline) && report.timeline.length) {
                    addResult('â±ï¸ Stage Duration:', 'enhancement');
                    const baseTs = report.timeline[0].timestamp;
                    report.timeline.forEach(entry => {
                        const dt = ((entry.timestamp - baseTs) / 1000).toFixed(2);
                        addResult(`   [${entry.stage}] +${dt}s`, 'enhancement');
                    });
                }

                if (typeof report.durationMs === 'number') {
                    addResult(` Total Detection Duration: ${report.durationMs.toFixed(1)}ms`, 'cpu-info');
                }

            } catch (error) {
                console.error('runRealWorldDetection failed', error);
                addResult(` Real Environment Detection Failed: ${error.message}`, 'limitation');
            }
        }

        // tripledetection function - core functionality
        async function runTripleDetection() {
            try {
                addResult('===  Triple Detection System Started ===', 'enhancement');
                addResult('Executing WASM + WebGL + WebGPU Comprehensive Detection...', 'enhancement');

                // 1. WASM CPUdetection
                addResult('ðŸ”§ Stage 1: WASM CPU Microarchitecture Detection', 'cpu-info');
                await initWASM();
                await ensureCommonLoaded();

                const wasmHelper = window.wasmFingerprint;
                if (!wasmHelper || typeof wasmHelper.generateFingerprint !== 'function') {
                    throw new Error('WASM Fingerprint helper not loaded');
                }

                let calibrationData = null;
                try {
                    calibrationData = await wasmHelper.loadCalibration();
                } catch (_e) {
                    calibrationData = null;
                }

                const wasmSummary = await buildWasmFingerprintSummary(wasmHelper);
                const wasmFingerprintData = wasmSummary.fingerprint;
                wasmFingerprint = wasmFingerprintData;
                const cpuFeatures = wasmSummary.cpuFeatures;
                const cpuAnalysis = wasmSummary.cpuAnalysis;

                addResult(` CPU Features: ${cpuFeatures.model} (Confidence: ${cpuFeatures.confidence}%)`, 'cpu-info');

                if (typeof cpuFeatures.memRatio === 'number') {
                    addResult(`   memory accessRatio: ${cpuFeatures.memRatio.toFixed(3)}`, 'cpu-info');
                }

                if (typeof wasmFingerprintData?.structure?.l1_kb === 'number') {
                    addResult(`   Detected L1 Cache: ${wasmFingerprintData.structure.l1_kb}KB`, 'cpu-info');
                }

                if (Array.isArray(cpuAnalysis?.evidence) && cpuAnalysis.evidence.length) {
                    cpuAnalysis.evidence.forEach(e => addResult(`   - ${e}`, 'cpu-info'));
                }

                const wasmFeatureSet = wasmFingerprintData?.features || {};
                if (typeof wasmFeatureSet.simd_supported === 'boolean') {
                    const simdMsg = wasmFeatureSet.simd_supported ? 'supportWASM SIMDextension' : 'Not DetectedWASM SIMD';
                    addResult(`   SIMDextension: ${simdMsg}`, wasmFeatureSet.simd_supported ? 'cpu-info' : 'limitation');
                    if (wasmFeatureSet.simd_supported && typeof wasmFeatureSet.simd_speedup === 'number' && isFinite(wasmFeatureSet.simd_speedup)) {
                        addResult(`   SIMDspeed improvement: ${wasmFeatureSet.simd_speedup.toFixed(2)}x`, 'cpu-info');
                    }
                }

                const workerProfile = wasmFingerprintData?.workerProfile;
                if (workerProfile && workerProfile.spawned) {
                    const latency = typeof workerProfile.medianLatency === 'number' && isFinite(workerProfile.medianLatency)
                        ? `${workerProfile.medianLatency.toFixed(2)}ms` : 'N/A';
                    addResult(`   Workerconcurrencycapability: ${workerProfile.spawned} (median round-trip ${latency})`, 'cpu-info');
                }

                // 2. WebGL GPU Detection
                addResult('ðŸŽ¨ Stage 2: WebGL GPU Detection', 'enhancement');
                const webglFP = new WebGLFingerprinter();
                const webglFingerprint = await webglFP.generateFingerprint();
                const webglAnalysis = webglFingerprint ? webglFP.analyzeGPUModel(webglFingerprint) : null;

                if (webglAnalysis) {
                    addResult(` WebGL GPU: ${webglAnalysis.model} (Confidence: ${webglAnalysis.confidence}%)`, 'enhancement');
                } else {
                    addResult(' WebGLdetectionFailed', 'limitation');
                }

                // 3. WebGPUdetection
                addResult(' Stage 3: WebGPU Advanced Detection', 'enhancement');
                const webgpuFP = new WebGPUFingerprinter();
                const webgpuFingerprint = await webgpuFP.generateFingerprint();
                const webgpuAnalysis = webgpuFingerprint ? webgpuFP.analyzeGPUModel(webgpuFingerprint) : null;

                if (webgpuAnalysis) {
                    addResult(` WebGPU GPU: ${webgpuAnalysis.model} (Confidence: ${webgpuAnalysis.confidence}%)`, 'enhancement');
                } else {
                    addResult(' WebGPUdetectionFailed', 'limitation');
                }

                // 4. comprehensiveanalysisanddevicerecognition
                addResult(' Stage 4: Comprehensive Analysis and Device Identification', 'model-guess');

                // initializedevicedatabase
                if (!deviceDatabase) {
                    deviceDatabase = new DeviceSignatureDatabase();
                }

                if (calibrationData?.bands) {
                    deviceDatabase.calibrationBands = calibrationData.bands;
                }

                // usingdatabase for preciserecognition
                const databaseResult = deviceDatabase.identifyDevice(cpuFeatures, webglAnalysis, webgpuAnalysis);
                const deviceIdentification = enhanceWithDatabase(cpuFeatures, webglAnalysis, webgpuAnalysis, databaseResult);

                addResult(' Final Device Identification Results:', 'model-guess');
                addResult(`   deviceModel: ${deviceIdentification.deviceModel}`, 'model-guess');
                addResult(`   CPU Model: ${deviceIdentification.cpuModel}`, 'model-guess');
                addResult(`   GPUModel: ${deviceIdentification.gpuModel}`, 'model-guess');
                addResult(`   comprehensiveConfidence: ${deviceIdentification.confidence}%`, 'model-guess');

                addResult(' Identification Basis:', 'model-guess');
                deviceIdentification.evidence.forEach(evidence => {
                    addResult(`   - ${evidence}`, 'model-guess');
                });

                // cleanup
                if (webglFP) webglFP.cleanup();
                if (webgpuFP) webgpuFP.cleanup();

            } catch (error) {
                addResult(` Triple Detection Failed: ${error.message}`, 'limitation');
            }
        }

        // generateWASMfingerprint digestï¼ˆfor tripledetectionreuseï¼‰
        async function buildWasmFingerprintSummary(wasmHelper) {
            if (!wasmHelper || typeof wasmHelper.generateFingerprint !== 'function') {
                throw new Error('WASM fingerprint helperNot initialized');
            }

            const fingerprint = await wasmHelper.generateFingerprint();
            const cpuAnalysis = typeof wasmHelper.analyzeCPUType === 'function'
                ? wasmHelper.analyzeCPUType(fingerprint)
                : { family: 'Unknown Architecture', confidence: 50 };

            let memRatio = null;
            if (typeof wasmHelper._safeOverallRatio === 'function') {
                memRatio = wasmHelper._safeOverallRatio(fingerprint.memoryResults);
            }
            if (typeof memRatio !== 'number' || !isFinite(memRatio)) {
                if (typeof cpuAnalysis.overall === 'number' && isFinite(cpuAnalysis.overall)) {
                    memRatio = cpuAnalysis.overall;
                } else {
                    const ratios = fingerprint?.memoryResults || {};
                    const values = Object.values(ratios).map(v => v?.ratio).filter(x => typeof x === 'number');
                    if (values.length) {
                        memRatio = values.reduce((a, b) => a + b, 0) / values.length;
                    }
                }
            }

            const l1Band = (typeof cpuAnalysis.l1Band === 'number' && isFinite(cpuAnalysis.l1Band))
                ? cpuAnalysis.l1Band : null;
            const deepBand = (typeof cpuAnalysis.deepBand === 'number' && isFinite(cpuAnalysis.deepBand))
                ? cpuAnalysis.deepBand : null;

            const cpuFeatures = {
                model: cpuAnalysis.family || 'Unknown Architecture',
                confidence: cpuAnalysis.confidence ?? 50,
                memRatio: (typeof memRatio === 'number' && isFinite(memRatio)) ? memRatio : null,
                memRatioL1: l1Band,
                memRatioDeep: deepBand
            };

            return { fingerprint, cpuFeatures, cpuAnalysis };
        }

        // timeTestfunction
        function timedTest(testFunc, ...args) {
            const startTime = performance.now();
            const result = testFunc(...args);
            const endTime = performance.now();
            return { result, time: endTime - startTime };
        }


        // comprehensivedevicerecognitionanalysis
        function analyzeDeviceIdentity(cpuFeatures, webglAnalysis, webgpuAnalysis) {
            const evidence = [];
            let deviceModel = "Unknowndevice";
            let cpuModel = cpuFeatures.model;
            let gpuModel = "UnknownGPU";
            let confidence = 0;

            // determineGPUModel
            if (webgpuAnalysis && webgpuAnalysis.confidence > 70) {
                gpuModel = webgpuAnalysis.model;
                evidence.push(`WebGPUhighConfidencerecognition: ${gpuModel}`);
            } else if (webglAnalysis && webglAnalysis.confidence > 60) {
                gpuModel = webglAnalysis.model;
                evidence.push(`WebGLrecognition: ${gpuModel}`);
            }

            // based onCPU+GPUcombinationrecognitionspecificdevice
            if (cpuFeatures.model.includes("Apple Silicon")) {
                if (gpuModel.includes("Apple") || gpuModel.includes("M1") || gpuModel.includes("M2") || gpuModel.includes("M3")) {
                    // Appledevicepreciserecognition
                    if (gpuModel.includes("M1 Pro") || gpuModel.includes("M1 Max")) {
                        deviceModel = "MacBook Pro (M1 Pro/Max)";
                        confidence = 95;
                    } else if (gpuModel.includes("M2")) {
                        deviceModel = "MacBook (M2 series)";
                        confidence = 92;
                    } else if (gpuModel.includes("M1")) {
                        deviceModel = "MacBook/iMac (M1)";
                        confidence = 90;
                    } else {
                        deviceModel = "Apple Silicon device";
                        confidence = 85;
                    }
                    evidence.push("CPUandGPUfeatureexact matchAppleecosystem");
                } else {
                    deviceModel = "Appledevice (GPUrecognitionabnormal)";
                    confidence = 70;
                    evidence.push("CPUisApple SiliconbutGPUrecognitionnotmatch");
                }
            }
            else if (cpuFeatures.model.includes("Intel")) {
                if (gpuModel.includes("Intel")) {
                    deviceModel = "Intelplatform (Integrated Graphics)";
                    confidence = 85;
                    evidence.push("Intel CPU + Intel GPUcombination");
                } else if (gpuModel.includes("NVIDIA") || gpuModel.includes("RTX") || gpuModel.includes("GTX")) {
                    deviceModel = "Intelplatform + NVIDIAdiscrete GPU";
                    confidence = 90;
                    evidence.push("Intel CPU + NVIDIA GPUcombination");
                } else if (gpuModel.includes("AMD") || gpuModel.includes("Radeon")) {
                    deviceModel = "Intelplatform + AMDdiscrete GPU";
                    confidence = 88;
                    evidence.push("Intel CPU + AMD GPUcombination");
                } else {
                    deviceModel = "Intelplatform";
                    confidence = 75;
                }
            }
            else if (cpuFeatures.model.includes("AMD")) {
                if (gpuModel.includes("AMD") || gpuModel.includes("Radeon")) {
                    deviceModel = "AMDfull suiteplatform";
                    confidence = 90;
                    evidence.push("AMD CPU + AMD GPUcombination");
                } else if (gpuModel.includes("NVIDIA")) {
                    deviceModel = "AMD CPU + NVIDIA GPU";
                    confidence = 88;
                    evidence.push("AMD CPU + NVIDIA GPUcombination");
                } else {
                    deviceModel = "AMDplatform";
                    confidence = 75;
                }
            }
            else {
                deviceModel = "cannot determinedeviceModel";
                confidence = 30;
                evidence.push("CPUandGPUrecognitionConfidenceall relativelylow");
            }

            // adddetectionMethoddescription
            evidence.push(`CPUMemoryRatio: ${cpuFeatures.memRatio?.toFixed(3) || 'Unknown'}`);

            if (webglAnalysis) {
                evidence.push(`WebGL renderer: ${webglAnalysis.rawRenderer || 'Unknown'}`);
            }

            if (webgpuAnalysis) {
                evidence.push(`WebGPU vendor: ${webgpuAnalysis.rawAdapter?.vendor || 'Unknown'}`);
            }

            return {
                deviceModel,
                cpuModel,
                gpuModel,
                confidence,
                evidence
            };
        }

        // optimizeddevicerecognitionanalysis
        function analyzeDeviceIdentity(cpuFeatures, webglAnalysis, webgpuAnalysis) {
            let deviceModel = "Unknowndevice";
            let cpuModel = cpuFeatures.model;
            let gpuModel = "UnknownGPU";
            let confidence = 30;
            const evidence = [];

            // 1. GPUdetectionhighest priorityhighï¼ˆApple Siliconcan clearlyrecognitionGPUModelï¼‰
            if (webgpuAnalysis && webgpuAnalysis.confidence >= 90) {
                if (webgpuAnalysis.model.includes("M4 Pro")) {
                    deviceModel = "Apple Silicon device";
                    cpuModel = "Apple M4 Pro";
                    gpuModel = webgpuAnalysis.model;
                    confidence = Math.max(90, webgpuAnalysis.confidence);
                    evidence.push(`WebGPUhighConfidencerecognition: ${webgpuAnalysis.model}`);
                    evidence.push("CPUandGPUfeatureexact matchAppleecosystem");
                } else if (webgpuAnalysis.model.includes("Apple")) {
                    deviceModel = "Apple Silicon device";
                    cpuModel = "Apple Silicon";
                    gpuModel = webgpuAnalysis.model;
                    confidence = Math.max(85, webgpuAnalysis.confidence);
                    evidence.push(`WebGPUrecognitionApple GPU: ${webgpuAnalysis.model}`);
                }
            }

            // 2. WebGLas supplementverification
            if (webglAnalysis && webglAnalysis.confidence >= 85) {
                if (webglAnalysis.model.includes("Apple") || webglAnalysis.model.includes("Metal")) {
                    if (confidence < 80) {
                        deviceModel = "Apple Silicon device";
                        cpuModel = "Apple Silicon";
                        confidence = Math.max(confidence, 80);
                    }
                    evidence.push(`WebGLrecognition: ${webglAnalysis.model}`);
                }
            }

            // 3. CPU Featuresas finalverificationï¼ˆreducelowweight to avoid interferenceï¼‰
            if (cpuFeatures.model && cpuFeatures.confidence >= 70) {
                if (cpuFeatures.model.includes("Apple")) {
                    // ifGPUalreadyrecognitionforAppleï¼ŒincreaseStrongConfidence
                    if (deviceModel.includes("Apple")) {
                        confidence = Math.min(95, confidence + 5);
                        evidence.push("WASM CPU FeaturesconfirmApplearchitecture");
                    } else {
                        // GPUnorecognitionoutAppleï¼ŒbutCPUrecognitioncame out
                        deviceModel = "Apple Silicon device";
                        cpuModel = cpuFeatures.model;
                        confidence = Math.max(confidence, cpuFeatures.confidence);
                        evidence.push(`WASMrecognition: ${cpuFeatures.model}`);
                    }
                }
            }

            // 4. add detailed technicalfeatureevidence
            if (deviceModel.includes("Apple")) {
                if (webglAnalysis?.basic?.renderer) {
                    evidence.push(`WebGL renderer: ${webglAnalysis.basic.renderer}`);
                }
                if (webgpuAnalysis?.adapter?.vendor) {
                    evidence.push(`WebGPU vendor: ${webgpuAnalysis.adapter.vendor}`);
                }
                if (cpuFeatures.memRatio) {
                    evidence.push(`CPUMemoryRatio: ${cpuFeatures.memRatio.toFixed(3)}`);
                }
            }

            return {
                deviceModel,
                cpuModel,
                gpuModel,
                confidence,
                evidence
            };
        }

        // usingdatabaseincreaseStrongdevicerecognition
        function enhanceWithDatabase(cpuFeatures, webglAnalysis, webgpuAnalysis, databaseResult) {
            if (databaseResult.confidence > 70) {
                // databaserecognitionConfidencehighï¼Œusingdatabase results
                return {
                    deviceModel: databaseResult.deviceModel,
                    cpuModel: cpuFeatures.model,
                    gpuModel: (webgpuAnalysis && webgpuAnalysis.confidence > webglAnalysis?.confidence) ?
                        webgpuAnalysis.model : webglAnalysis?.model || "UnknownGPU",
                    confidence: databaseResult.confidence,
                    evidence: [
                        ` Database Exact Match (${databaseResult.confidence}% Confidence)`,
                        ...databaseResult.evidence,
                        ...(databaseResult.alternatives.length > 0 ?
                            [`alternative: ${databaseResult.alternatives.map(alt => `${alt.brand} ${alt.deviceName}`).join(', ')}`] : [])
                    ]
                };
            } else {
                // databaserecognitionConfidencelowï¼ŒusingtraditionalMethodand learn newfeature
                const traditional = analyzeDeviceIdentity(cpuFeatures, webglAnalysis, webgpuAnalysis);

                // learn newdevicefeaturefor futurerecognition
                if (traditional.confidence > 60) {
                    deviceDatabase.learnDeviceSignature(traditional.deviceModel, cpuFeatures, webglAnalysis, webgpuAnalysis);
                }

                return {
                    ...traditional,
                    evidence: [
                        ` Database Matchdegree relativelylow (${databaseResult.confidence}%)ï¼Œusingtraditionalanalysis`,
                        ...traditional.evidence,
                        ...(databaseResult.confidence > 30 ?
                            [`similardevice: ${databaseResult.deviceModel}`] : [])
                    ]
                };
            }
        }

        // displayDevice Database Statistics
        function showDatabaseStats() {
            try {
                addResult('===  Device Database Statistics ===', 'enhancement');

                // initialize database
                if (!deviceDatabase) {
                    deviceDatabase = new DeviceSignatureDatabase();
                }

                const stats = deviceDatabase.generateDeviceStats();

                addResult('ðŸ“‹ database overview:', 'cpu-info');
                addResult(`   totaldeviceconfiguration: ${stats.totalProfiles}`, 'cpu-info');
                addResult(`   learningdevicecount: ${stats.learningData.totalDevices}`, 'cpu-info');
                addResult(`   learning sample count: ${stats.learningData.totalSignatures}`, 'cpu-info');

                addResult('ðŸ­ by brandscoredistribution:', 'cpu-info');
                for (const [brand, count] of Object.entries(stats.byBrand)) {
                    addResult(`   ${brand}: ${count}device`, 'cpu-info');
                }

                // showcaseSupported Device Types
                addResult(' Supported Device Types:', 'enhancement');
                addResult('   Apple Series:', 'enhancement');
                addResult('     - MacBook Air M1', 'enhancement');
                addResult('     - MacBook Pro M1 Pro/Max', 'enhancement');
                addResult('     - MacBook Pro M2', 'enhancement');

                addResult('   Intel Series:', 'enhancement');
                addResult('     - Intelhigh-enddesktop + Integrated Graphics', 'enhancement');
                addResult('     - Intelgaming laptop + NVIDIAdiscrete GPU', 'enhancement');

                addResult('   AMD Series:', 'enhancement');
                addResult('     - Ryzendesktop + Radeongraphics card', 'enhancement');

                addResult('   Mobile Devices:', 'enhancement');
                addResult('     - high-endAndroiddevice', 'enhancement');

                addResult(' Identification Features:', 'cpu-info');
                addResult('   - CPUmemory accessRatioanalysis', 'cpu-info');
                addResult('   - WebGLRendererstring matching', 'cpu-info');
                addResult('   - WebGPU Adapter Informationverification', 'cpu-info');
                addResult('   - GPUperformance benchmarkTest', 'cpu-info');
                addResult('   - Multi-dimensional Feature Fusion Algorithm', 'cpu-info');

                addResult(' Database Advantages:', 'model-guess');
                addResult('   - based onrealdevicedata training', 'model-guess');
                addResult('   - Continuously learning new device features', 'model-guess');
                addResult('   - Multiple verification improves accuracy', 'model-guess');
                addResult('   - Supports similar device recommendations', 'model-guess');

            } catch (error) {
                addResult(` Database Statistics Failed: ${error.message}`, 'limitation');
            }
        }

        // ===== simplifiedverificationanddiagnostic function =====

        function debugWASMModule(Module) {
            addResult(' WASM Module Status Check:', 'enhancement');

            // check module basic status
            const moduleKeys = Object.keys(Module || {});
            addResult(`ðŸ“‹ Moduleobject property count: ${moduleKeys.length}`, 'cpu-info');

            // check exportedfunction
            const wasmFunctions = moduleKeys.filter(key => key.startsWith('_') && typeof Module[key] === 'function');
            addResult(`ðŸ”§ WASMexportfunction: ${wasmFunctions.length}`, wasmFunctions.length > 0 ? 'cpu-info' : 'limitation');

            if (wasmFunctions.length > 0) {
                wasmFunctions.slice(0, 5).forEach(funcName => {
                    addResult(`   - ${funcName}`, 'cpu-info');
                });
                if (wasmFunctions.length > 5) {
                    addResult(`   - ... more${wasmFunctions.length - 5}function`, 'cpu-info');
                }
            }

            // check runtime status
            addResult('âš™ï¸ runtime status:', 'cpu-info');
            addResult(`   runtimeInitialized: ${!!Module.runtimeInitialized}`, 'cpu-info');
            addResult(`   calledRun: ${!!Module.calledRun}`, 'cpu-info');

            // Strongenforce checkwasmMemory
            if (typeof Module.wasmMemory !== 'undefined' && Module.wasmMemory) {
                addResult(`   wasmMemoryexists: is (${Module.wasmMemory.buffer ? Module.wasmMemory.buffer.byteLength + ' bytes' : 'nonebuffer'})`, 'cpu-info');
            } else {
                addResult(`   wasmMemoryexists: no`, 'limitation');
            }

            // checkMemoryrelatedAPI - only show important status
            const coreMemoryAPIs = {
                'HEAP8 Memoryview': !!Module.HEAP8,
                '_malloc function': typeof Module._malloc === 'function'
            };

            // optionalAPIï¼ˆnotaffects functionalityï¼‰
            const optionalAPIs = {
                'HEAP16': !!Module.HEAP16,
                'HEAP32': !!Module.HEAP32,
                'memoryobject': !!Module.memory,
                'mallocalias': typeof Module.malloc === 'function'
            };

            addResult(' Core Memory API Status:', 'cpu-info');
            for (const [api, available] of Object.entries(coreMemoryAPIs)) {
                const status = available ? '' : '';
                addResult(`   ${status} ${api}`, available ? 'cpu-info' : 'limitation');
            }

            const optionalCount = Object.values(optionalAPIs).filter(Boolean).length;
            addResult(` optionalAPIAvailable: ${optionalCount}/4 (notaffects core functionality)`, 'model-guess');

            // try manual checkMemory
            if (Module.memory && Module.memory.buffer) {
                const bufferSize = Module.memory.buffer.byteLength;
                addResult(` WASM Memory Buffer: ${bufferSize} bytes`, 'cpu-info');

                // try manual creationHEAP8view
                try {
                    const heap8 = new Uint8Array(Module.memory.buffer);
                    addResult(` Manual HEAP8 View: ${heap8.length} bytes`, 'cpu-info');
                } catch (e) {
                    addResult(` Unable to create HEAP8 view: ${e.message}`, 'limitation');
                }
            } else if (Module.HEAP8) {
                addResult(` HEAP8 Size: ${Module.HEAP8.length} bytes`, 'cpu-info');
            } else {
                addResult(' MemorybuffernotAvailable - thismayaffects some functions', 'model-guess');
            }

            // check other important properties
            const otherProps = ['wasmMemory', 'buffer', 'asm', 'wasmExports'];
            const availableProps = otherProps.filter(prop => Module[prop] !== undefined);
            if (availableProps.length > 0) {
                addResult(`ðŸ”§ otherAvailableproperty: ${availableProps.join(', ')}`, 'cpu-info');
            }
        }

        async function runValidationTests() {
            try {
                addResult('=== ðŸ§ª WASMverificationTest ===', 'enhancement');
                const Module = await initWASM();

                // debug firstWASMmodule status
                debugWASMModule(Module);

                // basic functionverification
                addResult('ðŸ“‹ basic functionverification:', 'cpu-info');
                const testCases = [
                    { size: 16, iter: 10, name: "smallMemoryblock" },
                    { size: 32, iter: 10, name: "MediumMemoryblock" },
                    { size: 64, iter: 10, name: "largeMemoryblock" }
                ];

                for (const test of testCases) {
                    try {
                        const seq = Module._sequential_access_test(test.size, test.iter);
                        const rand = Module._random_access_test(test.size, test.iter);
                        const ratio = rand / seq;

                        if (isFinite(seq) && isFinite(rand) && !isNaN(seq) && !isNaN(rand) && seq !== 0 && rand !== 0) {
                            const ratio = Math.abs(rand / seq);  // usingabsolute valuecalculationRatio
                            addResult(` ${test.name}: Ratio=${ratio.toFixed(2)}`, 'cpu-info');
                        } else {
                            addResult(` ${test.name}: Abnormal result (seq=${seq}, rand=${rand})`, 'limitation');
                        }
                    } catch (error) {
                        addResult(` ${test.name}: Execution failed - ${error.message}`, 'limitation');
                    }
                }

                // consistency check (3iterationsrun)
                addResult('ðŸ”„ consistency check:', 'cpu-info');
                const results = [];
                for (let i = 0; i < 3; i++) {
                    try {
                        const seq = Module._sequential_access_test(16, 10);
                        const rand = Module._random_access_test(16, 10);
                        if (isFinite(seq) && isFinite(rand) && seq !== 0 && rand !== 0) {
                            results.push(Math.abs(rand / seq));  // usingabsolute value
                        }
                    } catch (error) {
                        addResult(` consistencyTestround${i+1}iterationsFailed: ${error.message}`, 'limitation');
                    }
                }

                if (results.length > 0) {
                    const mean = results.reduce((a, b) => a + b) / results.length;
                    const variance = results.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / results.length;
                    const cv = Math.sqrt(variance) / mean;
                    addResult(` Coefficient of Variation: ${(cv*100).toFixed(1)}% (${results.length}iterationsvalidTest)`, cv < 0.3 ? 'cpu-info' : 'model-guess');
                } else {
                    addResult(` consistencyTestallFailed`, 'limitation');
                }

                // calculationfunctionverification
                addResult('ðŸ§® calculationfunctionverification:', 'cpu-info');
                const computeTests = [
                    { name: "floating-pointPrecision", func: () => Module._float_precision_test(1000) },
                    { name: "Integer Optimization", func: () => Module._integer_optimization_test(1000) },
                    { name: "scorebranch prediction", func: () => Module._branch_prediction_test(1000) }
                ];

                for (const test of computeTests) {
                    try {
                        const result = test.func();
                        if (isFinite(result) && !isNaN(result) && result !== 0) {
                            addResult(` ${test.name}: Normal`, 'cpu-info');
                        } else {
                            addResult(` ${test.name}: Abnormal value`, 'model-guess');
                        }
                    } catch (error) {
                        addResult(` ${test.name}: Failed`, 'limitation');
                    }
                }

            } catch (error) {
                addResult(` verificationTestFailed: ${error.message}`, 'limitation');
            }
        }

        async function runDiagnostics() {
            try {
                addResult('===  System Diagnosis ===', 'enhancement');
                const Module = await initWASM();

                // memory allocationTest
                addResult(' Memorysystem check:', 'cpu-info');
                try {
                    // checkWASMmodule status - as long as functionalityAvailablecontinue
                    if (!Module.runtimeInitialized && !Module.calledRun) {
                        addResult(' WASM runtime not fully initializedï¼ŒWaiting...', 'model-guess');
                        // try waiting a bit
                        await new Promise(resolve => setTimeout(resolve, 100));
                    } else if (!Module.runtimeInitialized && Module.calledRun) {
                        addResult(' WASMran but runtime flag not setï¼Œfunction shouldAvailable', 'model-guess');
                    }

                    // trynotsamememory allocationAPI
                    let ptr = null;
                    let allocSuccess = false;

                    // try _malloc
                    if (typeof Module._malloc === 'function') {
                        try {
                            ptr = Module._malloc(1024);
                            if (ptr && ptr > 0) {
                                addResult(` memory allocationNormal (_malloc): ptr=${ptr}`, 'cpu-info');
                                if (typeof Module._free === 'function') {
                                    Module._free(ptr);
                                }
                                allocSuccess = true;
                            }
                        } catch (e) {
                            addResult(` _mallocTestFailed: ${e.message}`, 'limitation');
                        }
                    }

                    // if_mallocnotsuccessï¼Œtrymalloc
                    if (!allocSuccess && typeof Module.malloc === 'function') {
                        try {
                            ptr = Module.malloc(1024);
                            if (ptr && ptr > 0) {
                                addResult(` memory allocationNormal (malloc): ptr=${ptr}`, 'cpu-info');
                                if (typeof Module.free === 'function') {
                                    Module.free(ptr);
                                }
                                allocSuccess = true;
                            }
                        } catch (e) {
                            addResult(` mallocTestFailed: ${e.message}`, 'limitation');
                        }
                    }

                    if (!allocSuccess) {
                        addResult(' dynamicmemory allocationnotAvailableï¼ŒChecking HEAP access...', 'model-guess');
                        // checkHEAPisaccessible or not
                        if (Module.HEAP8 && Module.HEAP8.length > 0) {
                            addResult(` WASM memory heap accessible: ${Module.HEAP8.length} bytes`, 'cpu-info');
                            // TestHEAPwrite
                            try {
                                const testIndex = Math.min(1000, Module.HEAP8.length - 1);
                                const originalValue = Module.HEAP8[testIndex];
                                Module.HEAP8[testIndex] = 42;
                                if (Module.HEAP8[testIndex] === 42) {
                                    addResult(` HEAPwriteTestsuccess`, 'cpu-info');
                                    Module.HEAP8[testIndex] = originalValue; // restore original value
                                } else {
                                    addResult(` HEAPwriteTestFailed`, 'limitation');
                                }
                            } catch (e) {
                                addResult(` HEAPaccessTestFailed: ${e.message}`, 'limitation');
                            }
                        } else {
                            addResult(' WASM memory heap not accessible', 'limitation');
                        }
                    }

                } catch (error) {
                    addResult(` Memorysystem checkFailed: ${error.message}`, 'limitation');
                }

                // functionAvailablecheck
                addResult('ðŸ”§ functionAvailablecheck:', 'cpu-info');
                const functions = ['_sequential_access_test', '_random_access_test', '_float_precision_test'];
                for (const funcName of functions) {
                    const status = Module[funcName] ? '' : '';
                    addResult(`  ${status} ${funcName.replace('_', '')}`, Module[funcName] ? 'cpu-info' : 'limitation');
                }

                // Cache Boundary Diagnosis
                addResult(' Cache Boundary Diagnosis:', 'cpu-info');
                const cacheSizes = [8, 16, 32, 64, 128, 256];
                const cacheResults = [];

                for (const sizeKB of cacheSizes) {
                    try {
                        const iterations = Math.max(10, 500 / sizeKB);
                        const seq = Module._sequential_access_test(sizeKB, iterations);
                        const rand = Module._random_access_test(sizeKB, iterations);

                        if (isFinite(seq) && isFinite(rand) && seq !== 0 && rand !== 0) {
                            const ratio = Math.abs(rand / seq);
                            cacheResults.push({ size: sizeKB, ratio });

                            let level = '';
                            if (ratio > 2.0) level = ' ðŸ”´';
                            else if (ratio > 1.6) level = ' ðŸŸ¡';
                            else if (ratio > 1.3) level = ' ðŸŸ ';
                            else level = ' ðŸŸ¢';

                            addResult(`  ${sizeKB}KB: ${ratio.toFixed(2)}${level}`, 'cpu-info');
                        } else {
                            addResult(`  ${sizeKB}KB: TestFailed (seq=${seq}, rand=${rand})`, 'limitation');
                        }
                    } catch (error) {
                        addResult(`  ${sizeKB}KB: Testabnormal - ${error.message}`, 'limitation');
                    }
                }

                // Cache Boundary Analysis
                for (let i = 1; i < cacheResults.length; i++) {
                    const prev = cacheResults[i-1];
                    const curr = cacheResults[i];
                    const jump = curr.ratio / prev.ratio;
                    if (jump > 1.5) {
                        addResult(` Cache Boundary: ${prev.size}KB â†’ ${curr.size}KB`, 'model-guess');
                    }
                }

                // browser environment check
                addResult('ðŸŒ environmentsupportcheck:', 'cpu-info');
                const features = {
                    'Performance API': typeof performance.now === 'function',
                    'WASM Memory': !!Module.HEAP8,
                    'BigInt': typeof BigInt !== 'undefined',
                    'SharedArrayBuffer': typeof SharedArrayBuffer !== 'undefined'
                };

                for (const [feature, supported] of Object.entries(features)) {
                    const status = supported ? '' : (feature === 'Performance API' || feature === 'WASM Memory' ? '' : '');
                    const style = supported ? 'cpu-info' : (feature === 'Performance API' || feature === 'WASM Memory' ? 'limitation' : 'model-guess');

                    if (!supported && (feature === 'BigInt' || feature === 'SharedArrayBuffer')) {
                        addResult(`  ${status} ${feature} (optional featuresï¼Œnotaffectdetection)`, style);
                    } else {
                        addResult(`  ${status} ${feature}`, style);
                    }
                }

            } catch (error) {
                addResult(` System DiagnosisFailed: ${error.message}`, 'limitation');
            }
        }

        // show instructions when page loads
        window.onload = function() {
            addResult('Enhanced Device Fingerprint Recognition System Ready', 'cpu-info');
            addResult('Main Detection Features:', 'cpu-info');
            addResult('   WASM CPU Detection - Fast and accurate CPU model identification', 'cpu-info');
            addResult('   WASM Detailed Analysis - Deep CPU microarchitecture analysis', 'cpu-info');
            addResult('   WebGL GPU Detection - GPU basic information and rendering features', 'cpu-info');
            addResult('   WebGPU Advanced Detection - GPU performance analysis', 'cpu-info');
            addResult('   Complete Feature Analysis - Detailed cache and performance analysis', 'cpu-info');
            addResult('   Triple Detection - Ultimate accuracy combining all technologies', 'cpu-info');
            addResult('Testing and Diagnostic Tools:', 'enhancement');
            addResult('   WASM Verification Test - Verify basic functionality', 'enhancement');
            addResult('   System Diagnosis - Deep analysis of execution environment', 'enhancement');
            addResult('   Test CPU Core Types - Detect P-cores vs E-cores', 'enhancement');
            addResult('Suggested test order: WASM CPU Detection â†’ Triple Detection â†’ Complete Analysis', 'enhancement');
        };

        async function testCPUCoreTypes() {
            try {
                addResult('=== CPU Core Type Detection (P-cores vs E-cores) ===', 'enhancement');
                await ensureCommonLoaded();
                
                // Wait a bit to ensure scripts are fully loaded
                await new Promise(resolve => setTimeout(resolve, 100));
                
                const wasmHelper = window.wasmFingerprint;
                
                // Debug information
                if (!wasmHelper) {
                    addResult('âš ï¸ Debug: window.wasmFingerprint is not defined', 'limitation');
                    addResult('   Trying to reload common.js...', 'enhancement');
                    
                    // Force reload common.js
                    const script = document.createElement('script');
                    script.src = `./src/common.js?v=${Date.now()}`;
                    document.head.appendChild(script);
                    
                    await new Promise((resolve, reject) => {
                        script.onload = () => {
                            setTimeout(() => {
                                const reloadedHelper = window.wasmFingerprint;
                                if (reloadedHelper && typeof reloadedHelper.profileWorkerPerformance === 'function') {
                                    addResult('âœ… Successfully reloaded common.js', 'cpu-info');
                                    resolve();
                                } else {
                                    reject(new Error('Failed to load profileWorkerPerformance method after reload'));
                                }
                            }, 200);
                        };
                        script.onerror = () => reject(new Error('Failed to reload common.js'));
                        setTimeout(() => reject(new Error('Reload timeout')), 5000);
                    });
                }
                
                const finalHelper = window.wasmFingerprint;
                if (!finalHelper) {
                    throw new Error('WASM helper (window.wasmFingerprint) is not available');
                }
                
                if (typeof finalHelper.profileWorkerPerformance !== 'function') {
                    addResult('âš ï¸ Debug: profileWorkerPerformance method not found', 'limitation');
                    addResult(`   Available methods: ${Object.getOwnPropertyNames(finalHelper).filter(k => typeof finalHelper[k] === 'function').join(', ')}`, 'limitation');
                    throw new Error('profileWorkerPerformance method not available. Please refresh the page to clear cache.');
                }

                addResult('Starting Worker performance profiling...', 'cpu-info');
                addResult('This test creates multiple Workers to run compute-intensive tasks', 'cpu-info');
                addResult('and analyzes performance distribution to identify P-cores and E-cores.', 'cpu-info');
                addResult('Please wait, this may take 10-30 seconds...', 'enhancement');

                const startTime = performance.now();
                const profile = await wasmHelper.profileWorkerPerformance(24);
                const endTime = performance.now();
                const duration = ((endTime - startTime) / 1000).toFixed(2);

                if (!profile.available) {
                    addResult(`âŒ Core type detection failed: ${profile.failureReason || 'Unknown error'}`, 'limitation');
                    if (profile.hardwareConcurrency) {
                        addResult(`   Hardware concurrency: ${profile.hardwareConcurrency} cores`, 'cpu-info');
                    }
                    return;
                }

                addResult(`âœ… Worker performance profiling completed in ${duration}s`, 'cpu-info');
                addResult('', 'cpu-info');

                // Display basic information
                addResult('ðŸ“Š Basic Information:', 'enhancement');
                addResult(`   Hardware Concurrency: ${profile.hardwareConcurrency} logical cores`, 'cpu-info');
                addResult(`   Workers Tested: ${profile.totalWorkers}`, 'cpu-info');
                addResult('', 'cpu-info');

                // Display core type analysis
                if (profile.analysis) {
                    const analysis = profile.analysis;
                    addResult('ðŸ§µ Core Type Analysis:', 'enhancement');
                    addResult(`   Performance Cores (P-cores): ${analysis.pCoreCount}`, 'cpu-info');
                    addResult(`   Efficiency Cores (E-cores): ${analysis.eCoreCount}`, 'cpu-info');
                    if (analysis.rawPCoreCount && analysis.rawPCoreCount !== analysis.pCoreCount) {
                        addResult(`   (Raw detection: ${analysis.rawPCoreCount}P + ${analysis.rawECoreCount}E, scaled to hardware concurrency)`, 'enhancement');
                    }
                    addResult(`   Performance Gap: ${analysis.performanceGap.toFixed(2)}x (E-core is ${analysis.performanceGap.toFixed(2)}x slower)`, 'cpu-info');
                    addResult(`   Detection Confidence: ${analysis.confidence}%`, analysis.confidence >= 70 ? 'cpu-info' : 'model-guess');
                    addResult(`   Detection Method: ${analysis.method}`, 'cpu-info');
                    
                    if (analysis.pCoreMean && analysis.eCoreMean) {
                        addResult(`   P-core Average Time: ${analysis.pCoreMean.toFixed(2)}ms`, 'cpu-info');
                        addResult(`   E-core Average Time: ${analysis.eCoreMean.toFixed(2)}ms`, 'cpu-info');
                    }
                    if (analysis.scaleFactor && analysis.scaleFactor < 1.0) {
                        addResult(`   Note: Tested ${profile.totalWorkers} workers on ${profile.hardwareConcurrency} cores (scale factor: ${analysis.scaleFactor.toFixed(2)})`, 'enhancement');
                    }
                    addResult('', 'cpu-info');

                    // Device inference based on core configuration
                    addResult('ðŸ” Device Inference:', 'enhancement');
                    let deviceGuess = 'Unknown';
                    let confidence = analysis.confidence;
                    
                    if (profile.hardwareConcurrency === 8) {
                        if (analysis.pCoreCount === 4 && analysis.eCoreCount === 4) {
                            // M1, M2, M3 all have 4P+4E configuration
                            // Need additional features to distinguish (L1 cache, memory ratio, etc.)
                            // For now, show as M1/M2/M3 series
                            deviceGuess = 'Apple M1/M2/M3 (4P+4E) - 8-core configuration';
                            confidence = Math.min(95, confidence + 10);
                            addResult('   Note: M1, M2, and M3 all have 4P+4E configuration.', 'enhancement');
                            addResult('   Run "WASM CPU Deep Analysis" for more detailed identification (L1 cache, memory ratio).', 'enhancement');
                        }
                    } else if (profile.hardwareConcurrency === 10) {
                        if (analysis.pCoreCount === 4 && analysis.eCoreCount === 6) {
                            deviceGuess = 'Apple M4 (4P+6E)';
                            confidence = Math.min(95, confidence + 15);
                        } else if (analysis.pCoreCount === 6 && analysis.eCoreCount === 4) {
                            deviceGuess = 'Apple M1 Pro (6P+4E) or similar';
                            confidence = Math.min(95, confidence + 10);
                        } else if (analysis.pCoreCount === 8 && analysis.eCoreCount === 2) {
                            deviceGuess = 'Apple M1 Max (8P+2E)';
                            confidence = Math.min(95, confidence + 10);
                        }
                    } else if (profile.hardwareConcurrency === 12) {
                        if (analysis.pCoreCount === 6 && analysis.eCoreCount === 6) {
                            deviceGuess = 'Apple M4 Pro (6P+6E)';
                            confidence = Math.min(95, confidence + 15);
                        } else if (analysis.pCoreCount === 8 && analysis.eCoreCount === 4) {
                            deviceGuess = 'Apple M3 Pro (8P+4E) or similar 12-core configuration';
                            confidence = Math.min(95, confidence + 10);
                        } else if (analysis.pCoreCount >= 5 && analysis.pCoreCount <= 7 && 
                                   analysis.eCoreCount >= 5 && analysis.eCoreCount <= 7) {
                            // Close to 6P+6E, likely M4 Pro
                            deviceGuess = 'Apple M4 Pro (likely 6P+6E, detected as ' + 
                                        analysis.pCoreCount + 'P+' + analysis.eCoreCount + 'E)';
                            confidence = Math.min(90, confidence + 5);
                        }
                    } else if (profile.hardwareConcurrency === 14) {
                        if (analysis.pCoreCount === 10 && analysis.eCoreCount === 4) {
                            deviceGuess = 'Apple M4 Max (10P+4E)';
                            confidence = Math.min(95, confidence + 15);
                        }
                    } else if (profile.hardwareConcurrency === 16) {
                        if (analysis.pCoreCount === 12 && analysis.eCoreCount === 4) {
                            deviceGuess = 'Apple M4 Max (12P+4E) or high-end configuration';
                            confidence = Math.min(95, confidence + 15);
                        }
                    }

                    addResult(`   Inferred Device: ${deviceGuess}`, 'model-guess');
                    addResult(`   Inference Confidence: ${confidence}%`, confidence >= 70 ? 'model-guess' : 'limitation');
                    addResult('', 'cpu-info');
                }

                // Display performance distribution
                if (profile.results && profile.results.length > 0) {
                    addResult('ðŸ“ˆ Performance Distribution:', 'enhancement');
                    const sortedResults = [...profile.results].sort((a, b) => a.duration - b.duration);
                    
                    // Show top 5 fastest and slowest
                    addResult('   Fastest Workers (likely P-cores):', 'cpu-info');
                    sortedResults.slice(0, Math.min(5, sortedResults.length)).forEach((r, idx) => {
                        addResult(`     Worker ${r.workerId}: ${r.duration.toFixed(2)}ms`, 'cpu-info');
                    });
                    
                    if (sortedResults.length > 5) {
                        addResult('   Slowest Workers (likely E-cores):', 'cpu-info');
                        sortedResults.slice(-Math.min(5, sortedResults.length - 5)).reverse().forEach((r, idx) => {
                            addResult(`     Worker ${r.workerId}: ${r.duration.toFixed(2)}ms`, 'cpu-info');
                        });
                    }
                    addResult('', 'cpu-info');
                }

                // Display gaps analysis
                if (profile.analysis && profile.analysis.gaps && profile.analysis.gaps.length > 0) {
                    addResult('ðŸ“Š Performance Gaps Analysis:', 'enhancement');
                    profile.analysis.gaps.forEach((gap, idx) => {
                        addResult(`   Gap ${idx + 1}: Worker ${gap.index - 1} â†’ ${gap.index}: ${gap.gap.toFixed(2)}x (${gap.prevDuration.toFixed(2)}ms â†’ ${gap.currDuration.toFixed(2)}ms)`, 'cpu-info');
                    });
                    addResult('', 'cpu-info');
                }

                addResult('âœ… Core type detection completed!', 'cpu-info');
                addResult('Note: Results may vary based on system load, temperature, and power state.', 'enhancement');

            } catch (error) {
                addResult(`âŒ Core type detection failed: ${error.message}`, 'limitation');
                console.error('Core type detection error:', error);
            }
        }
    </script>
</body>
</html>
