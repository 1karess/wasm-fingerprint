
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced CPU Model Detection</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #0d1117;
            color: #c9d1d9;
        }
        .detection-section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #30363d;
            border-radius: 8px;
            background: #161b22;
        }
        .status {
            padding: 8px;
            margin: 3px 0;
            border-radius: 4px;
            font-size: 13px;
        }
        .cpu-info { background: #0d5016; border-left: 4px solid #56d364; }
        .limitation { background: #5d1a1a; border-left: 4px solid #f85149; }
        .enhancement { background: #1a3d5d; border-left: 4px solid #58a6ff; }
        .model-guess { background: #5d4b1a; border-left: 4px solid #f0d000; }
        button {
            background: #238636;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            margin: 5px;
            font-family: inherit;
        }
        button:hover { background: #2ea043; }
        .results { max-height: 600px; overflow-y: auto; }
        .highlight { color: #58a6ff; font-weight: bold; }
        .signature-table {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 8px;
            margin: 10px 0;
            font-size: 12px;
        }
        .signature-table > div {
            padding: 6px;
            background: #21262d;
            border-radius: 4px;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>Enhanced Device Fingerprint Recognition System</h1>

    <div class="detection-section">
        <h2>Detection Methods</h2>
        <button onclick="runCPUDetection()">WASM CPU Detection</button>
        <button onclick="runBasicDetection()">WASM Detailed Analysis</button>
        <button onclick="runWebGLDetection()">WebGL GPU Detection</button>
        <button onclick="runWebGPUDetection()">WebGPU Advanced Detection</button>
        <button onclick="runTripleDetection()">Triple Detection (Ultimate Accuracy)</button>
        <button onclick="analyzeSignatures()">Complete Feature Analysis</button>
        <button onclick="runRealWorldDetection()">Real Environment Detection</button>
        <button onclick="showDatabaseStats()">Device Database Statistics</button>
        <button onclick="exportCalibrationSample()">Export Calibration Sample</button>
        <button onclick="clearResults()">Clear Results</button>
    </div>

    <div class="detection-section">
        <h2>Testing and Diagnostic Tools</h2>
        <button onclick="runValidationTests()">WASM Verification Test</button>
        <button onclick="runDiagnostics()">System Diagnosis</button>
    </div>

    <div id="output" class="results"></div>

    <script src="./build/wasm-fingerprint.js?v=20251002"></script>
    <script src="./src/common.js?v=20251002"></script>
    <script src="./src/webgl-detection.js?v=20251002"></script>
    <script src="./src/webgpu-detection.js?v=20251002"></script>
    <script src="./src/device-database.js?v=20251002"></script>
    <script src="./src/realworld-detector.js?v=20251002"></script>
    <script>
        const output = document.getElementById('output');
        let wasmModule = null;
        let deviceDatabase = null;

        function addResult(message, type = 'cpu-info') {
            const div = document.createElement('div');
            div.className = `status ${type}`;
            div.innerHTML = `[${new Date().toLocaleTimeString()}] ${message}`;
            output.appendChild(div);
            output.scrollTop = output.scrollHeight;
        }

        function clearResults() {
            output.innerHTML = '';
        }

        async function initWASM() {
            if (wasmModule && wasmModule.runtimeInitialized) {
                return wasmModule;
            }

            // æ¸…ç†ä¹‹å‰çš„æ¨¡å—å®ä¾‹
            wasmModule = null;

            try {
                const timestamp = Date.now();

                // usingæ›´å¯é çš„åˆå§‹åŒ–æ–¹å¼
                wasmModule = await new Promise((resolve, reject) => {
                    let resolved = false;

                    const moduleConfig = {
                        locateFile: (path, scriptDirectory) => {
                            if (path.endsWith('.wasm')) {
                                return scriptDirectory + path + '?v=' + timestamp;
                            }
                            return scriptDirectory + path;
                        },
                        onRuntimeInitialized: function() {
                            if (resolved) return; // é˜²æ­¢é‡å¤å›è°ƒ
                            resolved = true;

                            // å¼ºåˆ¶è®¾ç½®æ­£ç¡®çš„çŠ¶æ€æ ‡å¿—
                            this.runtimeInitialized = true;

                            console.log(' WASMè¿è¡Œæ—¶æ­£å¼åˆå§‹åŒ–å®Œæˆ:', {
                                runtimeInitialized: this.runtimeInitialized,
                                calledRun: this.calledRun,
                                hasHEAP8: !!this.HEAP8,
                                hasMalloc: typeof this._malloc === 'function',
                                hasSequentialTest: typeof this._sequential_access_test === 'function'
                            });

                            // ç«‹å³éªŒè¯å…³é”®åŠŸèƒ½
                            if (this._sequential_access_test && this.HEAP8 && this._malloc) {
                                resolve(this);
                            } else {
                                reject(new Error('WASMæ¨¡å—åˆå§‹åŒ–åç¼ºå°‘å…³é”®åŠŸèƒ½'));
                            }
                        },
                        onAbort: function(what) {
                            if (resolved) return;
                            resolved = true;
                            reject(new Error('WASMåˆå§‹åŒ–ä¸­æ­¢: ' + what));
                        }
                    };

                    // å¯åŠ¨WASMæ¨¡å—
                    try {
                        WASMModule(moduleConfig);
                    } catch (e) {
                        if (!resolved) {
                            resolved = true;
                            reject(e);
                        }
                    }

                    // è¶…æ—¶ä¿æŠ¤
                    setTimeout(() => {
                        if (!resolved) {
                            resolved = true;
                            reject(new Error('WASMåˆå§‹åŒ–è¶…æ—¶ (5ç§’)'));
                        }
                    }, 5000);
                });

                // æœ€ç»ˆéªŒè¯å’ŒçŠ¶æ€ç¡®è®¤
                if (!wasmModule.runtimeInitialized) {
                    throw new Error('è¿è¡Œæ—¶åˆå§‹åŒ–æ ‡å¿—ä»ç„¶ä¸ºfalse');
                }

                // åŠŸèƒ½éªŒè¯Test
                try {
                    const testPtr = wasmModule._malloc(1024);
                    if (testPtr) {
                        wasmModule._free(testPtr);
                        console.log(' å†…å­˜åˆ†é…Testé€šè¿‡');
                    } else {
                        console.warn(' å†…å­˜åˆ†é…TestFailedï¼Œä½†ç»§ç»­æ‰§è¡Œ');
                    }

                    const testResult = wasmModule._sequential_access_test(32, 10);
                    console.log(' åºåˆ—è®¿é—®Testé€šè¿‡:', testResult);
                } catch (e) {
                    console.warn(' åŠŸèƒ½éªŒè¯TestFailed:', e.message);
                }

                return wasmModule;
            } catch (error) {
                wasmModule = null;
                console.error(' WASMåˆå§‹åŒ–å½»åº•Failed:', error);
                addResult(` WASM Loading Failed: ${error.message}`, 'limitation');
                throw error;
            }
        }

        // ç»“æœæœ‰æ•ˆæ€§éªŒè¯å‡½æ•°
        function validateTestResults(features) {
            const issues = [];
            const warnings = [];

            // 1. æ£€æŸ¥Prefetcher Efficiency
            if (features.prefetch_efficiency !== null && features.prefetch_efficiency !== undefined) {
                if (!isFinite(features.prefetch_efficiency) || features.prefetch_efficiency <= 0) {
                    issues.push("é¢„å–å™¨Testæ— æ•ˆ (Infinityæˆ–è´Ÿå€¼)");
                } else if (features.prefetch_efficiency > 1000) {
                    warnings.push("Prefetcher Efficiencyå¼‚å¸¸é«˜ (mayTestå¤±æ•ˆ)");
                }
            }

            // 2. æ£€æŸ¥é™¤æ³•efficiency
            if (features.division_efficiency !== undefined) {
                if (features.division_efficiency === 0) {
                    issues.push("é™¤æ³•TestFailed (è¿”å›0)");
                } else if (!isFinite(features.division_efficiency)) {
                    issues.push("é™¤æ³•Testæ— æ•ˆ (éæœ‰é™å€¼)");
                }
            }

            // 3. æ£€æŸ¥æ­¥é•¿Testçš„ä¸€è‡´æ€§
            const strides = [64, 128, 256, 512, 4096];
            const strideValues = strides.map(s => features[`stride_${s}`]).filter(v => v > 0);

            if (strideValues.length < 3) {
                issues.push("æ­¥é•¿Testå¤±æ•ˆè¿‡å¤š (æœ‰æ•ˆTestå°‘äº3)");
            } else {
                // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å€¼éƒ½å®Œå…¨ç›¸åŒï¼ˆä¸å¤ªmayï¼‰
                const uniqueValues = new Set(strideValues.map(v => Math.round(v * 1000)));
                if (uniqueValues.size === 1) {
                    warnings.push("æ­¥é•¿Testç»“æœå®Œå…¨ç›¸åŒ (mayTestç²¾åº¦ä¸è¶³)");
                }
            }

            // 4. æ£€æŸ¥ç¼“å­˜å†²çªTest
            const conflicts = [4096, 8192, 16384, 32768].map(s => features[`conflict_${s}`]).filter(v => v !== undefined && v > 0);
            if (conflicts.length > 1) {
                const uniqueConflicts = new Set(conflicts.map(v => Math.round(v * 1000))); // é™ä½ç²¾åº¦è¦æ±‚
                if (uniqueConflicts.size === 1) {
                    warnings.push("ç¼“å­˜å†²çªTestç»“æœå®Œå…¨ç›¸åŒ");
                } else if (conflicts.filter(v => v < 0.1).length === conflicts.length) {
                    issues.push("ç¼“å­˜å†²çªTestç²¾åº¦è¿‡ä½ (æ‰€æœ‰ç»“æœ<0.1ms)");
                }
            } else {
                warnings.push("ç¼“å­˜å†²çªæœ‰æ•ˆTestè¿‡å°‘");
            }

            // 5. æ£€æŸ¥calculationTestçš„åˆç†æ€§
            if (features.float_precision !== undefined && features.float_precision === 0) {
                issues.push("Float ComputationTestFailed");
            }

            if (features.integer_opt !== undefined && features.integer_opt === 0) {
                warnings.push("Integer OptimizationTestmayæ— æ•ˆ");
            }

            return { issues, warnings };
        }

        // æ ¸å¿ƒCPUæ£€æµ‹å‡½æ•°
        async function runCPUDetection() {
            try {
                addResult('=== CPU Model Detection Started ===', 'enhancement');
                const Module = await initWASM();

                // æ ¸å¿ƒæ£€æµ‹: å†…å­˜è®¿é—®æ¨¡å¼
                addResult('Memory Access Pattern Analysis:', 'cpu-info');

                // è¿è¡Œå¤šiterationsTestè·å¾—å‡†ç¡®Ratio
                let ratios = [];
                const testParams = [
                    { size: 32, iter: 200 },  // åŸºç¡€Test - increasedè¿­ä»£iterationsæ•°ä»¥è·å¾—å¯æµ‹é‡æ—¶é—´
                    { size: 64, iter: 150 },  // Cache BoundaryTest
                    { size: 32, iter: 200 }   // é‡å¤éªŒè¯
                ];

                for (let i = 0; i < testParams.length; i++) {
                    const { size, iter } = testParams[i];

                    // æµ‹é‡æ‰§è¡Œæ—¶é—´è€Œä¸æ˜¯è¿”å›å€¼
                    const seqStart = performance.now();
                    Module._sequential_access_test(size, iter);
                    const seqTime = performance.now() - seqStart;

                    const randStart = performance.now();
                    Module._random_access_test(size, iter);
                    const randTime = performance.now() - randStart;

                    if (seqTime > 0.1 && randTime > 0.1) {  // è‡³å°‘0.1msç¡®ä¿æœ‰æ„ä¹‰
                        const ratio = randTime / seqTime;
                        ratios.push(ratio);
                        addResult(`   Test ${i+1}(${size}KB/${iter} iterations): Sequential=${seqTime.toFixed(2)}ms, Random=${randTime.toFixed(2)}ms, Ratio=${ratio.toFixed(3)}`, 'cpu-info');
                    }
                }

                const avgRatio = ratios.reduce((a, b) => a + b) / ratios.length;
                addResult(`   Average Ratio: ${avgRatio.toFixed(3)}`, 'cpu-info');

                // ç¼“å­˜ç‰¹å¾åˆ†æ
                addResult('Cache Architecture Analysis:', 'cpu-info');
                const l1Size = Module._l1_cache_size_detection(64);
                const cacheLineSize = Module._cache_line_size_detection();

                addResult(`   L1 Cache Size: ${l1Size}KB`, 'cpu-info');
                addResult(`   Cache Line Size: ${cacheLineSize} bytes`, 'cpu-info');

                // CPU Modelæ¨æ–­ - ç»Ÿä¸€ç®—æ³•ä¸å…¶ä»–æ£€æµ‹ä¿æŒä¸€è‡´
                let cpuModel = "Unknown CPU";
                let confidence = 0;
                let evidence = [];

                // ä¸æ‰€æœ‰å…¶ä»–æ£€æµ‹usingå®Œå…¨ç›¸åŒçš„é˜ˆå€¼ï¼Œç¡®ä¿ç»“æœä¸€è‡´
                if (avgRatio >= 0.5 && avgRatio < 1.6) {  // ç»Ÿä¸€Apple SiliconèŒƒå›´
                    cpuModel = "Apple Silicon (M1/M2/M3/M4)";
                    confidence = 90;
                    evidence.push(`Memory access ratio ${avgRatio.toFixed(3)} indicates unified memory architecture`);

                    if (avgRatio <= 0.8) {
                        confidence = 95;
                        evidence.push("Very low random access penalty, typical Apple Silicon characteristic");
                    }
                } else if (avgRatio >= 1.6 && avgRatio <= 2.5) {  // ç»Ÿä¸€IntelèŒƒå›´
                    cpuModel = "Intel High-Performance CPU";
                    confidence = 85;
                    evidence.push(`Memory access ratio ${avgRatio.toFixed(3)} matches Intel cache architecture`);
                } else if (avgRatio > 2.5 && avgRatio <= 4.0) {  // ç»Ÿä¸€AMDèŒƒå›´
                    cpuModel = "AMD Ryzen/Mainstream CPU";
                    confidence = 80;
                    evidence.push(`Memory access ratio ${avgRatio.toFixed(3)} shows typical AMD characteristics`);
                } else if (avgRatio > 4.0) {
                    cpuModel = "Low-end CPU or Virtual Environment";
                    confidence = 70;
                    evidence.push(`Memory access ratio ${avgRatio.toFixed(3)} indicates performance-limited characteristics`);
                } else {
                    cpuModel = "Abnormal Result";
                    confidence = 30;
                    evidence.push(`Memory access ratio ${avgRatio.toFixed(3)} is abnormal, possibly a test environment issue`);
                }

                // ç¼“å­˜ç‰¹å¾éªŒè¯
                if (l1Size === 32 && cacheLineSize === 64) {
                    confidence += 5;
                    evidence.push("Standard L1 cache configuration (32KB/64B)");
                } else if (l1Size === 32 && cacheLineSize === 128) {
                    if (cpuModel.includes("Apple")) {
                        confidence += 10;
                        evidence.push("Apple-specific 128-byte cache line");
                    }
                }

                addResult('Detection Results:', 'model-guess');
                addResult(`   CPU Model: ${cpuModel}`, 'model-guess');
                addResult(`   Confidence: ${confidence}%`, 'model-guess');
                addResult('Inference Basis:', 'model-guess');
                evidence.forEach(e => addResult(`   - ${e}`, 'model-guess'));

            } catch (error) {
                addResult(`CPU Detection Failed: ${error.message}`, 'limitation');
            }
        }

        async function runBasicDetection() {
            try {
                addResult('=== WASM CPU Microarchitecture Deep Analysis ===', 'cpu-info');
                const Module = await initWASM();
                await ensureCommonLoaded();
                const wasmHelper = window.wasmFingerprint;

                // åŸºç¡€æ€§èƒ½ç‰¹å¾ - usingä¿®å¤ç‰ˆæ—¶é—´æµ‹é‡
                function timedTest(testFunc, ...args) {
                    const startTime = performance.now();
                    const result = testFunc(...args);
                    const endTime = performance.now();
                    return { result, time: endTime - startTime };
                }

                const seqTest = timedTest(Module._sequential_access_test.bind(Module), 16, 1000);
                const randTest = timedTest(Module._random_access_test.bind(Module), 16, 1000);
                const float_test = timedTest(Module._float_precision_test.bind(Module), 10000);
                const int_test = timedTest(Module._integer_optimization_test.bind(Module), 10000);
                const vector_test = timedTest(Module._vector_computation_test.bind(Module), 1000);

                // Apple Siliconç‰¹æ®Šæ¶æ„å¤„ç†ï¼šç»Ÿä¸€å†…å­˜mayå¯¼è‡´ç‰¹æ®Šçš„è®¿é—®æ¨¡å¼
                let memRatio;
                let isAppleMemoryPattern = false;

                if (randTest.time > 0.001 && seqTest.time > 0.001) {
                    if (randTest.time < seqTest.time) {
                        // Sequentialè®¿é—®æ¯”Randomè®¿é—®æ…¢ - è¿™åœ¨Apple Siliconä¸Šmayæ˜¯Normalçš„
                        const reverseRatio = seqTest.time / randTest.time;

                        if (reverseRatio < 1.5) {
                            // å·®å¼‚ä¸å¤§ï¼Œmayæ˜¯Appleç»Ÿä¸€å†…å­˜æ¶æ„çš„ç‰¹å¾
                            memRatio = reverseRatio;
                            isAppleMemoryPattern = true;
                            addResult(`Detected Apple Silicon memory pattern: Sequential access slightly slower than random access`, 'enhancement');
                        } else {
                            // å·®å¼‚å¾ˆå¤§ï¼Œmayç¡®å®æ˜¯å¼‚å¸¸
                            memRatio = reverseRatio;
                            addResult(`Warning: Sequential access significantly slower than random access (${reverseRatio.toFixed(2)}x)`, 'limitation');
                        }
                    } else {
                        memRatio = randTest.time / seqTest.time;
                    }
                } else {
                    memRatio = 'Too Fast';
                }

                // æ˜¾ç¤ºåŸºç¡€ç»“æœ
                addResult('Basic Performance Test Results:', 'cpu-info');
                if (typeof memRatio === 'number') {
                    let description;
                    if (isAppleMemoryPattern) {
                        description = `Apple Silicon mode - Sequential ${seqTest.time.toFixed(2)}ms / Random ${randTest.time.toFixed(2)}ms`;
                    } else {
                        const slowerAccess = randTest.time > seqTest.time ? 'Random' : 'Sequential';
                        const fasterAccess = randTest.time > seqTest.time ? 'Sequential' : 'Random';
                        description = `${slowerAccess} ${Math.max(randTest.time, seqTest.time).toFixed(2)}ms / ${fasterAccess} ${Math.min(randTest.time, seqTest.time).toFixed(2)}ms`;
                    }
                    addResult(`   Memory Access Time Ratio: <span class="highlight">${memRatio.toFixed(3)}</span> (${description})`, 'cpu-info');
                } else {
                    addResult(`   Memory Access Time Ratio: <span class="highlight">${memRatio}</span>`, 'limitation');
                }
                addResult(`   Float Computation: <span class="highlight">${float_test.result.toFixed(6)}</span> (${float_test.time.toFixed(2)}ms)`, 'cpu-info');
                addResult(`   Integer Optimization: <span class="highlight">${int_test.result}</span> (${int_test.time.toFixed(2)}ms)`, 'cpu-info');
                addResult(`   Vector Computation: <span class="highlight">${vector_test.result.toFixed(6)}</span> (${vector_test.time.toFixed(2)}ms)`, 'cpu-info');

                if (wasmHelper && typeof wasmHelper.detectSIMDSupport === 'function') {
                    const simdSupported = await wasmHelper.detectSIMDSupport();
                    addResult(`   SIMD Support: ${simdSupported ? 'Enabled' : 'Not Detected'}`, simdSupported ? 'cpu-info' : 'limitation');
                }

                // æ‰§è¡ŒWASMè¯¦ç»†ç¼“å­˜åˆ†æ
                addResult('WASM Cache Hierarchy Analysis:', 'enhancement');

                const features = {};
                const testSizes = [
                    { size: 32, label: '32KB(L1è¾¹ç•Œ)', iterations: 300 },
                    { size: 64, label: '64KB', iterations: 300 },
                    { size: 256, label: '256KB(L2è¾¹ç•Œ)', iterations: 200 },
                    { size: 512, label: '512KB', iterations: 200 },
                    { size: 2048, label: '2MB(L3è¾¹ç•Œ)', iterations: 100 },
                    { size: 4096, label: '4MB', iterations: 50 }
                ];

                addResult('   Analyzing cache characteristics...', 'enhancement');

                for (let testCase of testSizes) {
                    let seqTimes = [];
                    let randTimes = [];

                    for (let run = 0; run < 2; run++) {
                        Module._sequential_access_test(8192, 3);

                        const seqStart = performance.now();
                        Module._sequential_access_test(testCase.size, testCase.iterations);
                        const seqTime = performance.now() - seqStart;
                        seqTimes.push(seqTime);

                        Module._random_access_test(8192, 3);

                        const randStart = performance.now();
                        Module._random_access_test(testCase.size, testCase.iterations);
                        const randTime = performance.now() - randStart;
                        randTimes.push(randTime);
                    }

                    const avgSeqTime = seqTimes.reduce((a, b) => a + b) / seqTimes.length;
                    const avgRandTime = randTimes.reduce((a, b) => a + b) / randTimes.length;

                    if (avgSeqTime > 1.0 && avgRandTime > 1.0) {
                        const ratio = avgRandTime / avgSeqTime;
                        features[`mem_ratio_${testCase.size}KB`] = ratio;

                        const isSignificant = ratio > 1.6 ? 'Cache Boundary' : '';
                        addResult(`   ${testCase.label}: Ratio=${ratio.toFixed(3)} ${isSignificant}`, 'enhancement');
                    }
                }

                // WASM Microarchitecture Feature Analysis
                addResult('WASM Microarchitecture Feature Analysis:', 'model-guess');

                // æ­¥é•¿æ•æ„Ÿæ€§Test
                const strideTests = [
                    { stride: 64, label: '1ç¼“å­˜è¡Œ(64B)' },
                    { stride: 128, label: '2ç¼“å­˜è¡Œ(128B)' },
                    { stride: 512, label: '8ç¼“å­˜è¡Œ(512B)' },
                    { stride: 4096, label: '1å†…å­˜é¡µ(4KB)' }
                ];

                addResult('   Prefetcher Behavior Analysis:', 'model-guess');
                for (const test of strideTests) {
                    const start = performance.now();
                    Module._stride_access_test(512, test.stride, 200);
                    const time = performance.now() - start;
                    features[`stride_${test.stride}`] = time;
                    addResult(`     ${test.label}: ${time.toFixed(1)}ms`, 'model-guess');
                }

                // Prefetcher Efficiency - ç¨³å®šcalculationMethod
                let prefetchEfficiency = null;
                const strides = [64, 128, 512, 4096];
                const validStrides = strides.filter(s => features[`stride_${s}`] > 0.001);

                if (validStrides.length >= 2) {
                    const smallStride = validStrides[0];
                    const largeStride = validStrides[validStrides.length - 1];
                    const smallTime = features[`stride_${smallStride}`];
                    const largeTime = features[`stride_${largeStride}`];

                    prefetchEfficiency = smallTime / largeTime;

                    // åˆç†æ€§æ£€æŸ¥
                    if (prefetchEfficiency > 0.1 && prefetchEfficiency < 50) {
                        let desc = "";
                        if (prefetchEfficiency < 0.5) desc = " (Ultra-strong prefetcher)";
                        else if (prefetchEfficiency < 1.0) desc = " (Strong prefetcher)";
                        else if (prefetchEfficiency < 3.0) desc = " (Medium prefetcher)";
                        else desc = " (Normal prefetcher)";

                        addResult(`   Prefetcher Efficiency: ${prefetchEfficiency.toFixed(1)}${desc}`, 'model-guess');
                    } else {
                        addResult(`   Warning: Prefetcher analysis data abnormal (efficiency=${prefetchEfficiency.toFixed(2)})`, 'limitation');

                        // é‡æ–°åˆ†ææ—¶é—´è¶‹åŠ¿
                        addResult('   Detailed Time Analysis:', 'model-guess');
                        for (let i = 1; i < validStrides.length; i++) {
                            const prev = validStrides[i-1];
                            const curr = validStrides[i];
                            const ratio = features[`stride_${curr}`] / features[`stride_${prev}`];
                            const trend = ratio > 1 ? "increased" : "decreased";
                            addResult(`     ${prev}Bâ†’${curr}B: Time ${trend} ${(Math.abs(ratio-1)*100).toFixed(1)}%`, 'model-guess');
                        }

                        prefetchEfficiency = null;
                    }
                } else {
                    addResult(`   Warning: Prefetcher analysis insufficient data (${validStrides.length} valid strides)`, 'limitation');
                }

                // WASMä¸“ç”¨CPUè¯†åˆ«ç®—æ³•
                const memoryTests = Object.entries(features)
                    .filter(([k, v]) => k.startsWith('mem_ratio'))
                    .map(([k, v]) => v);

                const avgMemRatio = memoryTests.length > 0 ?
                    memoryTests.reduce((a, b) => a + b) / memoryTests.length : memRatio;

                let wasmCpuType = "Unknown Architecture";
                let confidence = 30;
                let evidence = [];

                if (typeof avgMemRatio === 'number') {
                    // ä¼˜å…ˆbased oné¢„å–å™¨ç‰¹å¾è¯†åˆ«Apple Silicon
                    const isApplePrefetcher = prefetchEfficiency > 10 && prefetchEfficiency < 30;
                    const cacheJumps = memoryTests.filter(ratio => ratio > 1.4).length;
                    const hasAppleCachePattern = cacheJumps >= 3;

                    // Apple Siliconå¼ºç‰¹å¾æ£€æµ‹
                    if (isApplePrefetcher && hasAppleCachePattern) {
                        wasmCpuType = "Apple Silicon";
                        confidence = 90;
                        evidence.push("Apple Siliconé¢„å–å™¨ç‰¹å¾ç¡®è®¤");
                        evidence.push("Appleç»Ÿä¸€å†…å­˜ç¼“å­˜æ¨¡å¼");

                        if (avgMemRatio < 1.2) {
                            wasmCpuType = "Apple Silicon (M4ç³»åˆ—mayæ€§é«˜)";
                            confidence = 95;
                        }

                    } else if (avgMemRatio >= 0.5 && avgMemRatio < 1.6) {  // ä¸å¿«é€Ÿæ£€æµ‹å®Œå…¨ä¸€è‡´
                        wasmCpuType = "Apple Silicon";
                        confidence = 85;
                        evidence.push("ä½å†…å­˜è®¿é—®Ratioï¼Œå…¸å‹ç»Ÿä¸€å†…å­˜æ¶æ„");

                        if (isApplePrefetcher) {
                            confidence += 10;
                            evidence.push("Apple Siliconé¢„å–å™¨ç‰¹å¾");
                        }

                        if (hasAppleCachePattern) {
                            confidence += 5;
                            evidence.push("Appleç»Ÿä¸€å†…å­˜ç¼“å­˜æ¨¡å¼");
                        }

                    } else if (avgMemRatio >= 1.6 && avgMemRatio <= 2.5 && !isApplePrefetcher) {  // ç»Ÿä¸€é˜ˆå€¼è‡³1.6
                        wasmCpuType = "Intelé«˜æ€§èƒ½CPU";
                        confidence = 75;
                        evidence.push("ä¸­ç­‰å†…å­˜è®¿é—®Ratioï¼Œåˆ†å±‚ç¼“å­˜æ¶æ„");

                        if (prefetchEfficiency < 10) {
                            confidence += 5;
                            evidence.push("IntelStrong prefetcherç‰¹å¾");
                        }

                    } else if (avgMemRatio > 2.5 && !isApplePrefetcher) {
                        wasmCpuType = "AMD Ryzenæˆ–ä¸»æµCPU";
                        confidence = 70;
                        evidence.push("é«˜å†…å­˜è®¿é—®Ratio");
                    } else {
                        // é¢„å–å™¨ç‰¹å¾å¼ºçƒˆæŒ‡å‘Appleï¼Œå³ä½¿å†…å­˜Ratioå¼‚å¸¸
                        if (isApplePrefetcher) {
                            wasmCpuType = "Apple Silicon (å¼‚å¸¸å†…å­˜Ratio)";
                            confidence = 80;
                            evidence.push("é¢„å–å™¨ç‰¹å¾å¼ºçƒˆæŒ‡å‘Apple Silicon");
                            evidence.push("å†…å­˜Ratioå¼‚å¸¸ï¼Œmayå—Testç¯å¢ƒå½±å“");
                        }
                    }
                }

                addResult('WASM Professional Analysis Results:', 'model-guess');
                addResult(`   CPU Architecture: <span class="highlight">${wasmCpuType}</span>`, 'model-guess');
                addResult(`   WASM Detection Confidence: <span class="highlight">${confidence}%</span>`, 'model-guess');

                if (evidence.length > 0) {
                    addResult('   WASM Analysis Basis:', 'model-guess');
                    evidence.forEach(ev => addResult(`     - ${ev}`, 'model-guess'));
                }

                addResult('WASM Unique Advantages:', 'cpu-info');
                addResult('   - Direct access to CPU microarchitecture features', 'cpu-info');
                addResult('   - Bypass operating system abstraction layer', 'cpu-info');
                addResult('   - Precise cache hierarchy analysis', 'cpu-info');
                addResult('   - Prefetcher behavior detection', 'cpu-info');
                addResult('   - Cross-platform consistency detection', 'cpu-info');

                addResult('WASM Detection Limitations:', 'limitation');
                addResult('   - Affected by browser security policies', 'limitation');
                addResult('   - Cannot obtain specific model information', 'limitation');
                addResult('   - Accuracy affected by execution environment standardization', 'limitation');

            } catch (error) {
                addResult(`WASM Basic Detection Failed: ${error.message}`, 'limitation');
            }
        }

        async function runEnhancedDetection() {
            try {
                addResult('===  Theoretical Enhanced Detection Scheme ===', 'enhancement');

                addResult(' Technologies Required for Enhanced Detection:', 'enhancement');
                addResult('   1. <span class="highlight">æ›´å¤šå¾®åŸºå‡†Test</span> - ç¼“å­˜å¤§å°ã€TLBç‰¹æ€§ã€é¢„å–è¡Œä¸º', 'enhancement');
                addResult('   2. <span class="highlight">æŒ‡ä»¤çº§Test</span> - ç‰¹å®šæŒ‡ä»¤å»¶è¿Ÿã€ååé‡å·®å¼‚', 'enhancement');
                addResult('   3. <span class="highlight">æ—¶åºä¾§ä¿¡é“</span> - æ›´ç²¾ç¡®çš„æ€§èƒ½è®¡æ—¶å™¨', 'enhancement');
                addResult('   4. <span class="highlight">æœºå™¨å­¦ä¹ åˆ†ç±»</span> - è®­ç»ƒæ¨¡å‹Identification Featuresæ¨¡å¼', 'enhancement');

                addResult('ğŸ“‹ Detectable Specific Features:', 'enhancement');
                const signatures = [
                    'L1 Cache Sizeå’Œå»¶è¿Ÿ',
                    'L2/L3ç¼“å­˜å±‚iterationsç»“æ„',
                    'TLBå¤§å°å’Œåˆ†ç»„æ–¹å¼',
                    'åˆ†æ”¯é¢„æµ‹å™¨ç®—æ³•å·®å¼‚',
                    'ä¹±åºæ‰§è¡Œçª—å£å¤§å°',
                    'SIMDæŒ‡ä»¤é›†æ”¯æŒ',
                    'å†…å­˜é¢„å–ç­–ç•¥',
                    'æµ®ç‚¹å•å…ƒç²¾åº¦ç‰¹å¾'
                ];

                for (const sig of signatures) {
                    addResult(`   - ${sig}`, 'enhancement');
                }

                addResult(' ç†è®ºå¯è¯†åˆ«çš„CPU Model:', 'model-guess');
                const cpuModels = [
                    { family: 'Intel', models: ['i5-8250U', 'i7-10700K', 'i9-11900K'], signature: 'ä½å†…å­˜Ratio + é«˜æµ®ç‚¹æ€§èƒ½' },
                    { family: 'AMD', models: ['Ryzen 5 3600', 'Ryzen 7 5800X'], signature: 'ä¸­ç­‰å†…å­˜Ratio + ä¼˜ç§€æ•´æ•°æ€§èƒ½' },
                    { family: 'ARM', models: ['A14 Bionic', 'Snapdragon 888'], signature: 'é«˜å†…å­˜Ratio + ç§»åŠ¨ä¼˜åŒ–' },
                    { family: 'Apple', models: ['M1', 'M2'], signature: 'ç‹¬ç‰¹ç¼“å­˜è¡Œä¸º + ç»Ÿä¸€å†…å­˜' }
                ];

                const signatureDiv = document.createElement('div');
                signatureDiv.className = 'signature-table';
                signatureDiv.innerHTML = `
                    <div><strong>Vendor</strong></div>
                    <div><strong>ä»£è¡¨Model</strong></div>
                    <div><strong>ç‰¹å¾ç­¾å</strong></div>
                    <div><strong>æ£€æµ‹éš¾åº¦</strong></div>
                `;

                for (const cpu of cpuModels) {
                    signatureDiv.innerHTML += `
                        <div>${cpu.family}</div>
                        <div>${cpu.models.join(', ')}</div>
                        <div>${cpu.signature}</div>
                        <div>${cpu.family === 'ARM' ? 'å®¹æ˜“' : 'å›°éš¾'}</div>
                    `;
                }

                output.appendChild(signatureDiv);

                addResult(' Implementation Challenges:', 'limitation');
                addResult('   - Browser security policies limit high-precision timing', 'limitation');
                addResult('   - WASM execution environment standardization reduces hardware differences', 'limitation');
                addResult('   - Requires large amounts of real device data to train models', 'limitation');

            } catch (error) {
                addResult(` Enhanced Detection Analysis Failed: ${error.message}`, 'limitation');
            }
        }

        async function analyzeSignatures() {
            try {
                addResult('===  Current Device Feature Signature Analysis ===', 'enhancement');
                const Module = await initWASM();

                // å¤šç»´åº¦ç‰¹å¾æå–
                addResult('æ­£åœ¨æå–å¤šç»´åº¦ç‰¹å¾...', 'enhancement');

                const features = {};

                // å†…å­˜è®¿é—®æ¨¡å¼ - å¹³è¡¡çš„ç¼“å­˜å±‚çº§Test
                const testSizes = [
                    // L1ç¼“å­˜Test
                    { size: 32, label: '32KB(L1è¾¹ç•Œ)', iterations: 500 },
                    { size: 64, label: '64KB', iterations: 500 },

                    // L2ç¼“å­˜Test
                    { size: 256, label: '256KB(L2è¾¹ç•Œ)', iterations: 300 },
                    { size: 512, label: '512KB', iterations: 300 },

                    // L3ç¼“å­˜Test
                    { size: 2048, label: '2MB(L3è¾¹ç•Œ)', iterations: 200 },
                    { size: 4096, label: '4MB', iterations: 100 },

                    // ä¸»å†…å­˜Testï¼ˆdecreasedåˆ°åˆç†èŒƒå›´ï¼‰
                    { size: 8192, label: '8MB(ä¸»å†…å­˜)', iterations: 50 }
                ];

                addResult('ğŸ”§ å¼€å§‹ç¼“å­˜é©±é€Test...', 'enhancement');

                for (let testCase of testSizes) {
                    // ç¼“å­˜é©±é€ï¼šå…ˆè®¿é—®å¤§é‡æ— å…³æ•°æ®æ¸…ç©ºç¼“å­˜
                    addResult(`Test ${testCase.label} (${testCase.iterations}iterationsè¿­ä»£)...`, 'enhancement');

                    // å¤šiterationsTestæé«˜ç²¾åº¦å’Œç¨³å®šæ€§
                    let seqTimes = [];
                    let randTimes = [];

                    for (let run = 0; run < 3; run++) {  // decreasedåˆ°3iterationsé‡å¤Test
                        // è½»é‡ç¼“å­˜é©±é€ï¼šè®¿é—®è¾ƒå°æ•°æ®æ¸…ç©ºç¼“å­˜
                        Module._sequential_access_test(8192, 5);  // 8MBæ¸…ç©ºç¼“å­˜

                        // TestSequentialè®¿é—®
                        const seqStart = performance.now();
                        Module._sequential_access_test(testCase.size, testCase.iterations);
                        const seqTime = performance.now() - seqStart;
                        seqTimes.push(seqTime);

                        // å†iterationsç¼“å­˜é©±é€
                        Module._random_access_test(8192, 5);  // 8MBæ¸…ç©ºç¼“å­˜

                        // TestRandomè®¿é—®
                        const randStart = performance.now();
                        Module._random_access_test(testCase.size, testCase.iterations);
                        const randTime = performance.now() - randStart;
                        randTimes.push(randTime);
                    }

                    // calculationå¹³å‡æ—¶é—´å’Œæ ‡å‡†å·®
                    const avgSeqTime = seqTimes.reduce((a, b) => a + b) / seqTimes.length;
                    const avgRandTime = randTimes.reduce((a, b) => a + b) / randTimes.length;

                    const seqStdDev = Math.sqrt(seqTimes.reduce((sum, time) => sum + Math.pow(time - avgSeqTime, 2), 0) / seqTimes.length);
                    const randStdDev = Math.sqrt(randTimes.reduce((sum, time) => sum + Math.pow(time - avgRandTime, 2), 0) / randTimes.length);

                    // calculationæ—¶é—´Ratioï¼ˆç°åœ¨åº”è¯¥æœ‰æ˜æ˜¾å·®å¼‚ï¼‰
                    if (avgSeqTime > 1.0 && avgRandTime > 1.0) {  // 1msæœ€å°é˜ˆå€¼
                        const ratio = avgRandTime / avgSeqTime;
                        features[`mem_ratio_${testCase.size}KB`] = ratio;

                        // åŒæ—¶è®°å½•ç¨³å®šæ€§æŒ‡æ ‡
                        features[`mem_stability_${testCase.size}KB`] = (seqStdDev + randStdDev) / (avgSeqTime + avgRandTime);

                        addResult(`   ${testCase.label}: Ratio=${ratio.toFixed(3)}, Sequential=${avgSeqTime.toFixed(1)}msÂ±${seqStdDev.toFixed(1)}, Random=${avgRandTime.toFixed(1)}msÂ±${randStdDev.toFixed(1)}`, 'enhancement');
                    } else {
                        features[`mem_ratio_${testCase.size}KB`] = 1.0;
                        addResult(`   ${testCase.label}: æ‰§è¡Œæ—¶é—´è¿‡çŸ­ï¼Œæ— æ³•æµ‹é‡`, 'enhancement');
                    }
                }

                // calculationç‰¹å¾ - å¹³è¡¡çš„è¿­ä»£iterationsæ•°
                addResult(' calculationæ€§èƒ½Test...', 'enhancement');
                features.float_precision = Module._float_precision_test(2000);
                features.integer_opt = Module._integer_optimization_test(2000);
                features.branch_pred = Module._branch_prediction_test(3000);
                features.vector_comp = Module._vector_computation_test(500);

                // æ­¥é•¿æ•æ„Ÿæ€§Test - ä¸åŒCPUçš„é¢„å–å™¨ååº”ä¸åŒ
                addResult('ğŸƒ æ­¥é•¿æ•æ„Ÿæ€§Test...', 'enhancement');
                const strideTests = [
                    { stride: 64, label: '1ç¼“å­˜è¡Œ(64B)' },
                    { stride: 128, label: '2ç¼“å­˜è¡Œ(128B)' },
                    { stride: 256, label: '4ç¼“å­˜è¡Œ(256B)' },
                    { stride: 512, label: '8ç¼“å­˜è¡Œ(512B)' },
                    { stride: 4096, label: '1å†…å­˜é¡µ(4KB)' }
                ];

                const strideResults = {};
                for (const test of strideTests) {
                    const start = performance.now();
                    const result = Module._stride_access_test(512, test.stride, 500); // 512KBæ•°æ®ï¼Œdecreasedè¿­ä»£
                    const time = performance.now() - start;

                    strideResults[test.stride] = { result, time };
                    features[`stride_${test.stride}`] = time;

                    if (time > 0) {
                        addResult(`   ${test.label}: ${time.toFixed(1)}ms`, 'enhancement');
                    } else {
                        addResult(`   ${test.label}: Testå¤±æ•ˆ (æ—¶é—´å¤ªçŸ­)`, 'limitation');
                    }
                }

                // Prefetcher Efficiencyåˆ†æ - usingå¤šæ­¥é•¿ç¨³å®šcalculation
                let prefetchEfficiency;
                let strongPrefetcher = false; // ç§»åˆ°å¤–å±‚ä½œç”¨åŸŸ
                const validStrides = [];

                // æ”¶é›†æ‰€æœ‰æœ‰æ•ˆçš„æ­¥é•¿Testç»“æœ
                [64, 128, 256, 512, 4096].forEach(stride => {
                    if (strideResults[stride] && strideResults[stride].time > 0.001) {
                        validStrides.push({
                            stride: stride,
                            time: strideResults[stride].time,
                            label: stride < 1024 ? `${stride}B` : `${stride/1024}KB`
                        });
                    }
                });

                if (validStrides.length >= 3) {
                    // usingæœ€å°æ­¥é•¿vsæœ€å¤§æ­¥é•¿çš„æ¯”è¾ƒï¼Œæ›´ç¨³å®š
                    const smallStride = validStrides[0]; // æœ€å°çš„
                    const largeStride = validStrides[validStrides.length - 1]; // æœ€å¤§çš„

                    // å¦‚æœå¤§æ­¥é•¿æ˜æ˜¾æ¯”å°æ­¥é•¿æ…¢ï¼Œè¯´æ˜é¢„å–å™¨æœ‰æ•ˆ
                    prefetchEfficiency = smallStride.time / largeStride.time;

                    // æ”¹è¿›çš„è¶‹åŠ¿éªŒè¯ï¼šåŒºåˆ†Strong prefetcherå’Œå¼‚å¸¸æƒ…å†µ
                    let trendConsistent = true;

                    // æ£€æŸ¥æ˜¯å¦ä¸ºStrong prefetcheræ¨¡å¼ï¼ˆæ­¥é•¿è¶Šå¤§æ—¶é—´è¶ŠçŸ­ï¼‰
                    let descendingCount = 0;
                    for (let i = 1; i < validStrides.length; i++) {
                        if (validStrides[i].time < validStrides[i-1].time) {
                            descendingCount++;
                        }

                        // åªæœ‰æ—¶é—´çªç„¶å˜æˆåŸæ¥1/10æ‰è®¤ä¸ºæ˜¯çœŸæ­£å¼‚å¸¸
                        if (validStrides[i].time < validStrides[i-1].time * 0.1) {
                            trendConsistent = false;
                            break;
                        }
                    }

                    // å¦‚æœå¤§éƒ¨åˆ†Testéƒ½æ˜¯é€’å‡çš„ï¼Œè¿™mayæ˜¯Strong prefetcherç‰¹å¾
                    if (descendingCount >= validStrides.length * 0.6) {
                        strongPrefetcher = true;
                    }

                    if (!trendConsistent) {
                        addResult(` æ­¥é•¿Testdata abnormalï¼ˆexists 10x or more mutationï¼‰`, 'limitation');
                        prefetchEfficiency = null;
                    } else {
                        const trendDesc = strongPrefetcher ? "Strong prefetcherç‰¹å¾" : "Standard cache characteristics";
                        addResult(` ${trendDesc}: ${smallStride.label}(${smallStride.time.toFixed(1)}ms) vs ${largeStride.label}(${largeStride.time.toFixed(1)}ms)`, 'enhancement');

                        // å¯¹äºStrong prefetcherï¼Œè°ƒæ•´efficiencycalculationMethod
                        if (strongPrefetcher) {
                            // Strong prefetcherçš„efficiencyusingå€’æ•°å…³ç³»æ›´åˆç†
                            prefetchEfficiency = largeStride.time / smallStride.time;
                            addResult(` æ£€æµ‹åˆ°Strong prefetcheræ¨¡å¼ï¼ŒUsing adjusted calculation method`, 'enhancement');
                        }
                    }
                } else if (validStrides.length >= 2) {
                    // è‡³å°‘æœ‰2æœ‰æ•ˆTestï¼Œusingå¤‡ç”¨calculation
                    const first = validStrides[0];
                    const last = validStrides[validStrides.length - 1];
                    prefetchEfficiency = first.time / last.time;
                    addResult(` æ­¥é•¿Testæ•°æ®æœ‰é™ï¼Œusing${first.label}vs${last.label}calculation`, 'limitation');
                } else {
                    // Testæ•°æ®å¤ªå°‘
                    prefetchEfficiency = null;
                    addResult(` é¢„å–å™¨Testå¤±æ•ˆ - æœ‰æ•ˆæ­¥é•¿Testå°‘äº2`, 'limitation');
                }

                features.prefetch_efficiency = prefetchEfficiency;

                // ä¿å­˜Apple Siliconç‰¹æ®Šæ¶æ„ç‰¹å¾ï¼Œä¾›åç»­åˆ†æusing
                // åœ¨è¿™é˜¶æ®µæš‚æ—¶è®¾ä¸ºfalseï¼Œä¼šåœ¨åŸºç¡€æ£€æµ‹ä¸­æ›´æ–°
                features.apple_memory_pattern = false;

                if (prefetchEfficiency && isFinite(prefetchEfficiency) && prefetchEfficiency > 0) {
                    // æ ¹æ®Prefetcher Efficiencyç»™å‡ºæ›´æœ‰æ„ä¹‰çš„è§£é‡Šï¼Œè€ƒè™‘Strong prefetcheræ¨¡å¼
                    let interpretation = "";
                    let prefetchStrength = "";

                    if (strongPrefetcher) {
                        // Strong prefetcheræ¨¡å¼ï¼šæ¯”å€¼è¶Šå°è¡¨ç¤ºé¢„å–å™¨è¶Šå¼º
                        if (prefetchEfficiency < 0.3) {
                            interpretation = " - Ultra-strong prefetcherï¼ˆApple Siliconçº§åˆ«ï¼‰";
                            prefetchStrength = "è¶…å¼º";
                        } else if (prefetchEfficiency < 0.6) {
                            interpretation = " - Strong prefetcherï¼ˆé«˜ç«¯CPUï¼‰";
                            prefetchStrength = "å¼º";
                        } else if (prefetchEfficiency < 1.0) {
                            interpretation = " - Medium prefetcher";
                            prefetchStrength = "ä¸­ç­‰";
                        } else {
                            interpretation = " - Normal prefetcher";
                            prefetchStrength = "ä¸€èˆ¬";
                        }
                    } else {
                        // æ ‡å‡†æ¨¡å¼ï¼šä¼ ç»Ÿçš„è§£é‡Š
                        if (prefetchEfficiency < 0.5) {
                            interpretation = " - Ultra-strong prefetcher";
                            prefetchStrength = "è¶…å¼º";
                        } else if (prefetchEfficiency < 1.0) {
                            interpretation = " - Strong prefetcher";
                            prefetchStrength = "å¼º";
                        } else if (prefetchEfficiency < 3.0) {
                            interpretation = " - Medium prefetcher";
                            prefetchStrength = "ä¸­ç­‰";
                        } else if (prefetchEfficiency < 10.0) {
                            interpretation = " - é¢„å–å™¨æ•ˆæœä¸€èˆ¬";
                            prefetchStrength = "ä¸€èˆ¬";
                        } else {
                            interpretation = " - é¢„å–å™¨è¾ƒå¼±";
                            prefetchStrength = "å¼±";
                        }
                    }

                    features.prefetch_strength = prefetchStrength; // ä¿å­˜é¢„å–å™¨å¼ºåº¦
                    addResult(` Prefetcher Efficiency: ${prefetchEfficiency.toFixed(2)}${interpretation}`, 'enhancement');
                } else {
                    addResult(` Prefetcher Efficiency: Testæ— æ•ˆ`, 'limitation');
                }

                // CPUå‹åŠ›ç‰¹å¾Test - Testå¤šæ ¸æ€§èƒ½é€€åŒ–æ›²çº¿
                addResult('ğŸ’ª CPUå‹åŠ›ç‰¹å¾Test...', 'enhancement');
                const pressureTests = [];

                // åŸºå‡†æ€§èƒ½ï¼ˆæ— å‹åŠ›ï¼‰
                const baselineStart = performance.now();
                Module._integer_optimization_test(1000);
                const baselineTime = performance.now() - baselineStart;

                // è½»å‹åŠ›Testï¼ˆèƒŒæ™¯calculationï¼‰
                const lightPressureStart = performance.now();
                Module._float_precision_test(500); // èƒŒæ™¯Float Computation
                Module._integer_optimization_test(1000);
                const lightPressureTime = performance.now() - lightPressureStart;

                // calculationæ€§èƒ½é€€åŒ–ç‡
                const performanceDrop = baselineTime > 0 ? (lightPressureTime - baselineTime) / baselineTime : 0;
                features.pressure_resistance = Math.max(0, performanceDrop); // ç¡®ä¿éè´Ÿå€¼
                const dropPercent = isFinite(performanceDrop) ? (performanceDrop * 100).toFixed(1) : '0.0';
                addResult(`ğŸ“‰ å‹åŠ›ä¸‹æ€§èƒ½é€€åŒ–: ${dropPercent}% (å€¼è¶Šå°æŠ—å‹èƒ½åŠ›è¶Šå¼º)`, 'enhancement');

                // ç¼“å­˜å…³è”æ€§Test - é’ˆå¯¹Apple Siliconä¼˜åŒ–ç²¾åº¦
                addResult('ğŸ”„ ç¼“å­˜å…³è”æ€§Test...', 'enhancement');
                const conflictTests = [
                    { offset: 4096, label: '4KBé—´éš”', iterations: 8000, size: 256 },
                    { offset: 8192, label: '8KBé—´éš”', iterations: 6000, size: 512 },
                    { offset: 16384, label: '16KBé—´éš”', iterations: 4000, size: 512 },
                    { offset: 32768, label: '32KBé—´éš”', iterations: 3000, size: 1024 }
                ];

                let worstConflict = 0;
                let validConflictTests = 0;

                for (const test of conflictTests) {
                    // æ›´æ¿€è¿›çš„å¤šiterationsè¿è¡Œä»¥å…‹æœApple Siliconçš„ä¼˜åŒ–
                    const times = [];
                    for (let run = 0; run < 5; run++) {
                        // é¢„çƒ­è¿è¡Œé¿å…å†·å¯åŠ¨å½±å“
                        if (run === 0) {
                            Module._alignment_sensitivity_test(test.size, test.offset, test.iterations / 4);
                        }

                        const start = performance.now();
                        Module._alignment_sensitivity_test(test.size, test.offset, test.iterations);
                        const time = performance.now() - start;

                        // é™ä½ç²¾åº¦è¦æ±‚ï¼Œé€‚åº”Apple Siliconçš„é«˜æ•ˆç¼“å­˜
                        if (time > 0.05) times.push(time);
                    }

                    let finalTime = 0;
                    if (times.length >= 2) {
                        times.sort((a, b) => a - b);
                        finalTime = times[Math.floor(times.length / 2)]; // ä¸­ä½æ•°
                        validConflictTests++;
                    } else if (times.length === 1) {
                        finalTime = times[0];
                        validConflictTests++;
                    }

                    features[`conflict_${test.offset}`] = finalTime;

                    if (finalTime > 0.05 && baselineTime > 0.05) {
                        const conflictRatio = finalTime / baselineTime;
                        if (conflictRatio > worstConflict) worstConflict = conflictRatio;
                        addResult(`   ${test.label}: ${finalTime.toFixed(1)}ms (Ratio${conflictRatio.toFixed(2)})`, 'enhancement');
                    } else {
                        addResult(`   ${test.label}: Testç²¾åº¦ä¸è¶³ (${finalTime.toFixed(3)}ms) - Apple Siliconç¼“å­˜mayè¿‡äºé«˜æ•ˆ`, 'limitation');
                    }
                }

                // éªŒè¯ç¼“å­˜å†²çªTestçš„æœ‰æ•ˆæ€§
                if (validConflictTests >= 2 && worstConflict > 0.1) {
                    features.cache_conflict_sensitivity = worstConflict;
                    addResult(` Cache conflict sensitivity: ${worstConflict.toFixed(3)} (Intelusually<1.5, AMDmay>1.5)`, 'enhancement');
                } else {
                    features.cache_conflict_sensitivity = 1.0; // é»˜è®¤å€¼
                    addResult(` ç¼“å­˜å†²çªTestç²¾åº¦ä¸è¶³ (æœ‰æ•ˆTest${validConflictTests})`, 'limitation');
                }

                // ç‰¹æ®Šè¿ç®—æŒ‡çº¹Test
                addResult('ğŸ§® ç‰¹æ®Šè¿ç®—æŒ‡çº¹...', 'enhancement');

                // é™¤æ³•vsä¹˜æ³•æ€§èƒ½æ¯”
                const divStart = performance.now();
                for (let i = 0; i < 10000; i++) {
                    const result = (i * 12345) / 67890; // å¼ºåˆ¶é™¤æ³•è¿ç®—
                }
                const divTime = performance.now() - divStart;

                const mulStart = performance.now();
                for (let i = 0; i < 10000; i++) {
                    const result = i * 12345 * 67890; // çº¯ä¹˜æ³•è¿ç®—
                }
                const mulTime = performance.now() - mulStart;

                const divMulRatio = mulTime > 0.001 ? divTime / mulTime : 1.0;
                features.division_efficiency = isFinite(divMulRatio) ? divMulRatio : 1.0;
                const divDisplay = isFinite(divMulRatio) ? divMulRatio.toFixed(2) : '1.00';
                addResult(`â— é™¤æ³•efficiency: ${divDisplay} (Intelusually<5, AMDmay>5)`, 'enhancement');

                if (typeof features.simd_supported === 'boolean') {
                    const simdStatus = features.simd_supported ? 'æ”¯æŒ (WASM SIMD Enabled)' : 'Not Detected';
                    addResult(` SIMD Instruction Extension: ${simdStatus}`, features.simd_supported ? 'cpu-info' : 'limitation');

                    if (features.simd_supported && typeof features.simd_speedup === 'number' && isFinite(features.simd_speedup)) {
                        addResult(`   SIMDç›¸å¯¹æ•´æ•°é€Ÿåº¦: ${features.simd_speedup.toFixed(2)}x`, 'cpu-info');
                    }
                }

                const logicalCores = typeof features.hardware_concurrency === 'number' && isFinite(features.hardware_concurrency)
                    ? features.hardware_concurrency : null;
                const workerCap = typeof features.worker_spawn_cap === 'number' && isFinite(features.worker_spawn_cap)
                    ? features.worker_spawn_cap : null;

                if (logicalCores || workerCap) {
                    addResult('ğŸ§µ å¹¶å‘èƒ½åŠ›æ¢æµ‹:', 'cpu-info');
                    if (logicalCores) {
                        addResult(`   navigator.hardwareConcurrency â‰ˆ ${logicalCores}`, 'cpu-info');
                    }
                    if (workerCap) {
                        const latency = typeof features.worker_latency_median === 'number' && isFinite(features.worker_latency_median)
                            ? `${features.worker_latency_median.toFixed(2)}ms` : 'N/A';
                        addResult(`   Workerå¯ç¨³å®šå¹¶å‘: ${workerCap}  (ä¸­ä½å¾€è¿” ${latency})`, 'cpu-info');
                    }
                }

                addResult(' Device Feature Signature:', 'cpu-info');

                // åˆ†ç»„æ˜¾ç¤ºå†…å­˜Testç»“æœï¼Œä¾¿äºè§‚å¯ŸCache Boundary
                addResult(' Memory Access Pattern (Finding Cache Boundaries):', 'cpu-info');
                const memoryTests = Object.entries(features)
                    .filter(([k, v]) => k.startsWith('mem_ratio'))
                    .sort((a, b) => {
                        const sizeA = parseInt(a[0].replace('mem_ratio_', '').replace('KB', ''));
                        const sizeB = parseInt(b[0].replace('mem_ratio_', '').replace('KB', ''));
                        return sizeA - sizeB;
                    });

                for (const [key, value] of memoryTests) {
                    const size = key.replace('mem_ratio_', '').replace('KB', '');
                    const color = value > 1.6 ? 'style="color: #f85149; font-weight: bold;"' :
                                  value > 1.4 ? 'style="color: #f0d000; font-weight: bold;"' :
                                  'style="color: #56d364;"';
                    addResult(`   ${size}KB: <span class="highlight" ${color}>${value.toFixed(4)}</span> ${value > 1.6 ? ' Definite Cache Boundary' : value > 1.4 ? ' mayçš„è¾¹ç•Œ' : ''}`, 'cpu-info');
                }

                addResult(' calculationæ€§èƒ½ç‰¹å¾:', 'cpu-info');
                const hiddenKeys = new Set([
                    'mem_ratio_l1_band',
                    'mem_ratio_deep',
                    'prefetch_efficiency',
                    'prefetch_strength',
                    'apple_memory_pattern',
                    'simd_supported',
                    'simd_speedup',
                    'simd_vector_ratio',
                    'hardware_concurrency',
                    'worker_spawn_cap',
                    'worker_latency_median',
                    'worker_latency_mean'
                ]);

                const computeTests = Object.entries(features)
                    .filter(([k, v]) => !k.startsWith('mem_ratio') && !hiddenKeys.has(k));

                for (const [key, value] of computeTests) {
                    if (typeof value === 'number' && isFinite(value)) {
                        addResult(`   ${key}: <span class="highlight">${value.toFixed(4)}</span>`, 'cpu-info');
                    }
                }

                // ç‰¹å¾å‘é‡åˆ†æ
                const signature = Object.values(features).filter(v => typeof v === 'number' && isFinite(v));
                let hash = 0;
                for (let i = 0; i < signature.length; i++) {
                    hash = ((hash << 5) - hash + signature[i] * 1000) & 0xffffffff;
                }

                addResult(`ğŸ”‘ è®¾å¤‡ç‰¹å¾å“ˆå¸Œ: <span class="highlight">${hash.toString(16)}</span>`, 'model-guess');

                // Cache Boundary Analysisç®—æ³•
                const memRatioEntries = Object.entries(features)
                    .filter(([k, v]) => k.startsWith('mem_ratio') && typeof v === 'number' && v > 0.5 && v < 20)
                    .map(([k, v]) => ({ size: parseInt(k.replace('mem_ratio_', '').replace('KB', '')), ratio: v }))
                    .sort((a, b) => a.size - b.size);

                // æ™ºèƒ½Cache Boundaryæ£€æµ‹ç®—æ³•
                let cacheTransitions = [];
                let l1Boundary = null;
                let l2Boundary = null;
                let l3Boundary = null;

                for (let i = 1; i < memRatioEntries.length; i++) {
                    const prev = memRatioEntries[i-1];
                    const curr = memRatioEntries[i];
                    const jump = curr.ratio / prev.ratio;

                    // æ£€æµ‹æ˜¾è‘—çš„æ€§èƒ½è·³è·ƒ
                    if (jump > 1.5) {  // 50%ä»¥ä¸Šçš„æ€§èƒ½è·³è·ƒæ‰è®¤ä¸ºæ˜¯çœŸæ­£çš„Cache Boundary
                        let boundaryType = "Cache Boundary";

                        if (prev.size <= 128 && !l1Boundary) {
                            boundaryType = "L1Cache Boundary";
                            l1Boundary = `${prev.size}KB`;
                        } else if (prev.size <= 1024 && !l2Boundary) {
                            boundaryType = "L2Cache Boundary";
                            l2Boundary = `${prev.size}KB`;
                        } else if (prev.size <= 8192 && !l3Boundary) {
                            boundaryType = "L3Cache Boundary";
                            l3Boundary = `${prev.size}KB`;
                        }

                        cacheTransitions.push({
                            from: prev.size,
                            to: curr.size,
                            jump: jump,
                            boundary: `${boundaryType}: ${prev.size}KB â†’ ${curr.size}KB`,
                            type: boundaryType
                        });
                    }
                }

                // è¡¥å……ï¼šå³ä½¿æ²¡æœ‰è·³è·ƒï¼Œä¹Ÿæ ¹æ®ç»éªŒé˜ˆå€¼åˆ¤æ–­
                const heavyRatios = memRatioEntries.filter(entry => entry.ratio > 2.0);
                if (heavyRatios.length > 0 && cacheTransitions.length === 0) {
                    const firstHeavy = heavyRatios[0];
                    cacheTransitions.push({
                        boundary: `ç–‘ä¼¼Cache Boundary: ${firstHeavy.size}KB (Ratio${firstHeavy.ratio.toFixed(2)})`,
                        type: "æ¨æµ‹è¾¹ç•Œ"
                    });
                }

                addResult(' Cache Boundary Analysis:', 'model-guess');
                if (cacheTransitions.length > 0) {
                    for (const transition of cacheTransitions) {
                        addResult(`   ${transition.boundary} (æ€§èƒ½è·³è·ƒ${transition.jump.toFixed(2)}x)`, 'model-guess');
                    }
                } else {
                    addResult('   æœªå‘ç°æ˜æ˜¾çš„ç¼“å­˜æ€§èƒ½è¾¹ç•Œ', 'model-guess');
                }

                const validMemRatios = memRatioEntries.map(entry => entry.ratio);
                const memAvg = validMemRatios.length > 0 ?
                    validMemRatios.reduce((sum, v) => sum + v, 0) / validMemRatios.length : 1.0;

                // based onçœŸå®ç¼“å­˜Testçš„CPUè¯†åˆ«ç®—æ³•
                let modelGuess = "UnknownModel";
                let confidence = "ä½";
                let evidencePoints = [];

                if (validMemRatios.length >= 5) {
                    // åˆ†æL1 Cache Size
                    const l1Ratios = memRatioEntries.filter(e => e.size <= 128).map(e => e.ratio);
                    const l2Ratios = memRatioEntries.filter(e => e.size >= 256 && e.size <= 1024).map(e => e.ratio);
                    const l3Ratios = memRatioEntries.filter(e => e.size >= 2048).map(e => e.ratio);

                    const avgL1 = l1Ratios.length > 0 ? l1Ratios.reduce((a, b) => a + b) / l1Ratios.length : 1.0;
                    const avgL2 = l2Ratios.length > 0 ? l2Ratios.reduce((a, b) => a + b) / l2Ratios.length : 1.0;
                    const avgL3 = l3Ratios.length > 0 ? l3Ratios.reduce((a, b) => a + b) / l3Ratios.length : 1.0;

                    addResult(` Cache Hierarchy Analysis: L1 Average=${avgL1.toFixed(3)}, L2 Average=${avgL2.toFixed(3)}, L3 Average=${avgL3.toFixed(3)}`, 'model-guess');

                    // æ¸…ç†ç‰ˆCPU Featuresæ£€æµ‹ç®—æ³•
                    let score = { apple: 0, intel: 0, amd: 0 };
                    let featureLog = []; // è®°å½•æ‰€æœ‰ç‰¹å¾åˆ†æ

                    const simdSupported = !!features.simd_supported;
                    const workerCap = typeof features.worker_spawn_cap === 'number' && isFinite(features.worker_spawn_cap)
                        ? features.worker_spawn_cap : null;
                    const logicalCores = typeof features.hardware_concurrency === 'number' && isFinite(features.hardware_concurrency)
                        ? features.hardware_concurrency : null;

                    const prefetchEff = typeof features.prefetch_efficiency === 'number' && isFinite(features.prefetch_efficiency)
                        ? features.prefetch_efficiency : null;
                    const hasStrongPrefetch = prefetchEff !== null && prefetchEff > 0 && prefetchEff <= 0.7;
                    const hasUltraPrefetch = prefetchEff !== null && prefetchEff > 0 && prefetchEff <= 0.4;

                    // Apple Siliconç‰¹å¾è¯„åˆ† (æ›´æ–°é˜ˆå€¼é€‚é…æœ€æ–°Testæ•°æ®)
                    const l1Jump = l1Ratios.length >= 2 ? Math.max(...l1Ratios.map((v, idx) => idx < l1Ratios.length - 1 ? l1Ratios[idx + 1] / Math.max(0.5, v) : 0)) : 0;
                    const hasLargeL1 = avgL1 < 1.25 && l1Jump > 1.25;
                    const hasUnifiedMemory = avgL3 > 1.5 && avgL3 < 1.9;
                    const hasLowPressureDrop = typeof features.pressure_resistance === 'number' ? features.pressure_resistance < 0.2 : false;
                    const hasAppleCache = avgL1 < 1.25 && avgL2 > 1.5;

                    if (hasLargeL1) {
                        score.apple += 2;
                        featureLog.push(" å¤§L1ç¼“å­˜ç‰¹å¾ (+2 Apple)");
                    }
                    if (hasStrongPrefetch) {
                        score.apple += hasUltraPrefetch ? 3 : 2;
                        featureLog.push(hasUltraPrefetch ? " Ultra-strong prefetcher (+3 Apple)" : " Strong prefetcher (+2 Apple)");
                    }
                    if (hasUnifiedMemory) {
                        score.apple += 2;
                        featureLog.push(" ç»Ÿä¸€å†…å­˜æ¶æ„ (+2 Apple)");
                    }
                    if (hasLowPressureDrop) {
                        score.apple += 1;
                        featureLog.push(" æŠ—å‹èƒ½åŠ›å¼º (+1 Apple)");
                    }
                    if (hasAppleCache) {
                        score.apple += 3;
                        featureLog.push(" Appleç‹¬ç‰¹ç¼“å­˜æ¶æ„ (+3 Apple)");
                    }

                    // Intelç‰¹å¾è¯„åˆ† (é™ä½æƒé‡é¿å…ä¸Appleæ··æ·†)
                    const hasTypicalL2 = avgL2 > 1.5 && avgL2 < 1.9 && avgL1 > 1.3; // å¿…é¡»L1ä¹Ÿç¬¦åˆIntelç‰¹å¾
                    const hasGoodDivision = features.division_efficiency && features.division_efficiency < 4 && avgL1 > 1.3;
                    const hasLowConflict = features.cache_conflict_sensitivity < 1.5;
                    const hasPositiveInt = features.integer_opt > 0;

                    // åªæœ‰åœ¨éAppleç‰¹å¾æ—¶æ‰ç»™IntelåŠ åˆ†
                    const isNotApple = !hasAppleCache && avgL1 > 1.3;

                    if (hasTypicalL2 && isNotApple) {
                        score.intel += 2;
                        featureLog.push(" å…¸å‹L2ç¼“å­˜ç‰¹å¾ (+2 Intel)");
                    }
                    if (hasGoodDivision && isNotApple) {
                        score.intel += 2;
                        featureLog.push(" é™¤æ³•å•å…ƒé«˜æ•ˆ (+2 Intel)");
                    }
                    if (hasLowConflict && isNotApple) {
                        score.intel += 1;
                        featureLog.push(" ä½ç¼“å­˜å†²çª (+1 Intel)");
                    }
                    if (hasPositiveInt && isNotApple) {
                        score.intel += 1;
                        featureLog.push(" Integer Optimizationæ­£å‘ (+1 Intel)");
                    }

                    // AMDç‰¹å¾è¯„åˆ†
                    const hasStrongL3 = avgL3 > 1.8;
                    const hasPoorDivision = features.division_efficiency && features.division_efficiency > 5;
                    const hasHighConflict = features.cache_conflict_sensitivity > 1.5;
                    const hasNegativeInt = features.integer_opt < 0;

                    if (hasStrongL3) {
                        score.amd += 2;
                        featureLog.push(" å¼ºL3ç¼“å­˜ç‰¹å¾ (+2 AMD)");
                    }
                    if (hasPoorDivision) {
                        score.amd += 2;
                        featureLog.push(" é™¤æ³•ç›¸å¯¹è¾ƒæ…¢ (+2 AMD)");
                    }
                    if (hasHighConflict) {
                        score.amd += 1;
                        featureLog.push(" ç¼“å­˜å†²çªæ•æ„Ÿ (+1 AMD)");
                    }
                    if (hasNegativeInt) {
                        score.amd += 1;
                        featureLog.push(" ç‰¹æ®Šæ•´æ•°ç‰¹å¾ (+1 AMD)");
                    }

                    if (simdSupported) {
                        score.apple += 1;
                        score.intel += 1;
                        featureLog.push(" WASM SIMD Support (+1 Apple/+1 Intel)");
                    }

                    if (workerCap && workerCap >= 16) {
                        score.intel += 2;
                        score.apple += 1;
                        featureLog.push(` Workerå¹¶å‘â‰¥${workerCap} (+2 Intel, +1 Apple)`);
                    } else if (workerCap && workerCap >= 10) {
                        score.apple += 1;
                        featureLog.push(` Workerå¹¶å‘â‰¥${workerCap} (+1 Apple)`);
                    }

                    if (logicalCores && logicalCores >= 16) {
                        score.intel += 2;
                        featureLog.push(` ç¡¬ä»¶å¹¶å‘â‰ˆ${logicalCores} (+2 Intel)`);
                    } else if (logicalCores && logicalCores >= 10) {
                        score.apple += 1;
                        featureLog.push(` ç¡¬ä»¶å¹¶å‘â‰ˆ${logicalCores} (+1 Apple)`);
                    }

                    // æ ¹æ®å¾—åˆ†ç¡®å®šç»“æœ
                    const maxScore = Math.max(score.apple, score.intel, score.amd);

                    if (maxScore >= 5) {
                        confidence = "é«˜";
                    } else if (maxScore >= 3) {
                        confidence = "ä¸­";
                    } else {
                        confidence = "ä½";
                    }

                    // æ¸…ç†evidencePointsï¼Œåªæ˜¾ç¤ºè·èƒœæ–¹çš„ç‰¹å¾
                    evidencePoints = [];

                    if (score.apple === maxScore && maxScore >= 3) {
                        modelGuess = "Apple Silicon (M1/M2/M3ç³»åˆ—)";
                        evidencePoints.push(`Appleç‰¹å¾å¾—åˆ†: ${score.apple}åˆ†`);
                        evidencePoints.push(...featureLog.filter(log => log.includes("Apple")));
                    } else if (score.intel === maxScore && maxScore >= 3) {
                        modelGuess = "Intelé«˜æ€§èƒ½CPU (Core i5/i7/i9)";
                        evidencePoints.push(`Intelç‰¹å¾å¾—åˆ†: ${score.intel}åˆ†`);
                        evidencePoints.push(...featureLog.filter(log => log.includes("Intel")));
                    } else if (score.amd === maxScore && maxScore >= 3) {
                        modelGuess = "AMD Ryzenç³»åˆ—";
                        evidencePoints.push(`AMDç‰¹å¾å¾—åˆ†: ${score.amd}åˆ†`);
                        evidencePoints.push(...featureLog.filter(log => log.includes("AMD")));
                    } else {
                        modelGuess = "ç°ä»£é«˜æ€§èƒ½CPU (ç±»å‹ä¸ç¡®å®š)";
                        evidencePoints.push(`å¾—åˆ†è¾ƒä½: Apple=${score.apple}, Intel=${score.intel}, AMD=${score.amd}`);
                        evidencePoints.push(...featureLog.slice(0, 3)); // åªæ˜¾ç¤ºå‰3ç‰¹å¾
                    }

                    // Prefetcher analysiså¢å¼ºConfidence
                    if (features.prefetch_efficiency) {
                        if (features.prefetch_efficiency < 1.0) {
                            evidencePoints.push("Ultra-strong prefetcher (mayæ˜¯Apple/é«˜ç«¯Intel)");
                            if (confidence === "ä¸­") confidence = "é«˜";
                        } else if (features.prefetch_efficiency > 10) {
                            evidencePoints.push("é¢„å–å™¨æ•ˆæœä¸€èˆ¬ (mayæ˜¯AMD/ä¸»æµCPU)");
                        }
                    }

                } else {
                    modelGuess = "Testæ•°æ®ä¸è¶³ï¼Œæ— æ³•å‡†ç¡®åˆ†æ";
                    confidence = "å¾ˆä½";
                }

                addResult(` Model Inference: <span class="highlight">${modelGuess}</span>`, 'model-guess');
                addResult(` Confidence: <span class="highlight">${confidence}</span> (based on${validMemRatios.length}æœ‰æ•ˆç‰¹å¾)`, 'model-guess');

                // æ˜¾ç¤ºè¯æ®ç‚¹
                if (evidencePoints.length > 0) {
                    addResult(' Identification Basis:', 'model-guess');
                    for (const evidence of evidencePoints) {
                        addResult(`   - ${evidence}`, 'model-guess');
                    }
                }

                addResult(' Note: è¿™åªæ˜¯based onæœ‰é™ç‰¹å¾çš„æ¨æµ‹ï¼ŒActual accuracy is affected by multiple factors', 'limitation');

                // æ‰§è¡Œç»“æœéªŒè¯
                const validation = validateTestResults(features);
                if (validation.issues.length > 0 || validation.warnings.length > 0) {
                    addResult(' Testè´¨é‡è¯„ä¼°:', 'enhancement');

                    if (validation.issues.length > 0) {
                        addResult(' Issues Found:', 'limitation');
                        validation.issues.forEach(issue => {
                            addResult(`   - ${issue}`, 'limitation');
                        });
                    }

                    if (validation.warnings.length > 0) {
                        addResult(' Warning:', 'limitation');
                        validation.warnings.forEach(warning => {
                            addResult(`   - ${warning}`, 'limitation');
                        });
                    }

                    // calculationTestè´¨é‡åˆ†æ•°
                    const qualityScore = Math.max(0, 100 - validation.issues.length * 20 - validation.warnings.length * 10);
                    let qualityLevel;
                    if (qualityScore >= 80) qualityLevel = "ä¼˜ç§€";
                    else if (qualityScore >= 60) qualityLevel = "è‰¯å¥½";
                    else if (qualityScore >= 40) qualityLevel = "ä¸€èˆ¬";
                    else qualityLevel = "è¾ƒå·®";

                    addResult(` Testè´¨é‡è¯„åˆ†: ${qualityScore}/100 (${qualityLevel})`, 'enhancement');
                } else {
                    addResult(' Testè´¨é‡: Excellent (No obvious issues found)', 'enhancement');
                }

            } catch (error) {
                addResult(` Feature Analysis Failed: ${error.message}`, 'limitation');
            }
        }

        // WebGLæ£€æµ‹å‡½æ•°
        async function runWebGLDetection() {
            try {
                addResult('=== ğŸ¨ WebGL GPU Detection ===', 'enhancement');

                const webglFP = new WebGLFingerprinter();
                const fingerprint = await webglFP.generateFingerprint();

                if (!fingerprint) {
                    addResult(' WebGLä¸Available: æµè§ˆå™¨ä¸æ”¯æŒæˆ–å·²ç¦ç”¨', 'model-guess');
                    return;
                }

                addResult(' GPU Basic Information:', 'cpu-info');
                addResult(`   Vendor: ${fingerprint.basic.vendor}`, 'cpu-info');
                addResult(`   Renderer: ${fingerprint.basic.renderer}`, 'cpu-info');
                addResult(`   Version: ${fingerprint.basic.version}`, 'cpu-info');

                addResult(' Extension Support:', 'cpu-info');
                addResult(`   Total Extensions: ${fingerprint.extensions.count}`, 'cpu-info');
                addResult(`   Important Extensions: ${fingerprint.extensions.important.length}`, 'cpu-info');

                addResult(' Canvas Fingerprint:', 'cpu-info');
                addResult(`   Main Fingerprint: ${fingerprint.canvasHash}`, 'cpu-info');
                const canvasVariants = fingerprint.canvasVariants || {};
                const variantEntries = Object.entries(canvasVariants);
                if (variantEntries.length > 0) {
                    addResult('   Fingerprint Variants:', 'cpu-info');
                    variantEntries.forEach(([variantKey, variantValue]) => {
                        addResult(`     - ${variantKey}: ${variantValue}`, 'cpu-info');
                    });
                }

                if (fingerprint.performance) {
                    addResult(' Rendering Performance:', 'cpu-info');
                    addResult(`   Simple Rendering: ${fingerprint.performance.simpleRender?.toFixed(2)}ms`, 'cpu-info');
                    addResult(`   Complex Rendering: ${fingerprint.performance.complexRender?.toFixed(2)}ms`, 'cpu-info');
                    addResult(`   Texture Operations: ${fingerprint.performance.textureOps?.toFixed(2)}ms`, 'cpu-info');
                }

                // GPUModelåˆ†æ
                const analysis = webglFP.analyzeGPUModel(fingerprint);
                addResult(' WebGL GPUModel Inference:', 'model-guess');
                addResult(`   Model: ${analysis.model}`, 'model-guess');
                addResult(`   Confidence: ${analysis.confidence}%`, 'model-guess');
                if (analysis.evidence.length > 0) {
                    addResult('   Inference Basis:', 'model-guess');
                    analysis.evidence.forEach(evidence => {
                        addResult(`     - ${evidence}`, 'model-guess');
                    });
                }

                webglFP.cleanup();

            } catch (error) {
                addResult(` WebGL Detection Exception: ${error.message}`, 'limitation');
            }
        }

        // WebGPUæ£€æµ‹å‡½æ•°
        async function runWebGPUDetection() {
            try {
                addResult('===  WebGPU GPU Detection ===', 'enhancement');

                const webgpuFP = new WebGPUFingerprinter();
                const fingerprint = await webgpuFP.generateFingerprint();

                if (!fingerprint) {
                    addResult(' WebGPUä¸Available: æµè§ˆå™¨ä¸æ”¯æŒæˆ–å·²ç¦ç”¨', 'model-guess');
                    return;
                }

                addResult(' GPU Adapter Information:', 'cpu-info');
                const adapter = fingerprint.adapter;
                addResult(`   Vendor: ${adapter.vendor || 'Unknown'}`, 'cpu-info');
                addResult(`   æ¶æ„: ${adapter.architecture || 'Unknown'}`, 'cpu-info');
                addResult(`   è®¾å¤‡: ${adapter.device || 'Unknown'}`, 'cpu-info');
                addResult(`   æè¿°: ${adapter.description || 'Unknown'}`, 'cpu-info');
                if (adapter.subgroupMaxSize) {
                    addResult(`   å­ç»„å¤§å°: ${adapter.subgroupMinSize}-${adapter.subgroupMaxSize}`, 'cpu-info');
                }

                addResult('ğŸ’ª GPUèƒ½åŠ›:', 'cpu-info');
                const caps = fingerprint.capabilities;
                addResult(`   æ”¯æŒç‰¹æ€§: ${caps.features?.length || 0}`, 'cpu-info');
                if (caps.limits) {
                    addResult(`   æœ€å¤§çº¹ç†å°ºå¯¸: ${caps.limits.maxTextureSize}`, 'cpu-info');
                    addResult(`   æœ€å¤§ç¼“å†²åŒº: ${caps.limits.maxBufferSize}bytes`, 'cpu-info');
                    addResult(`   æœ€å¤§å·¥ä½œç»„: ${caps.limits.maxComputeWorkgroupSizeX}`, 'cpu-info');
                }

                if (fingerprint.timing) {
                    addResult('â±ï¸ GPUæ€§èƒ½åˆ†æ:', 'cpu-info');

                    if (fingerprint.timing.timerResolution) {
                        const timer = fingerprint.timing.timerResolution;
                        addResult(`   è®¡æ—¶å™¨åˆ†è¾¨ç‡: ${timer.average?.toFixed(3)}ms (Â±${timer.standardDeviation?.toFixed(3)})`, 'cpu-info');
                    }

                    if (fingerprint.timing.memoryBandwidth) {
                        const mem = fingerprint.timing.memoryBandwidth;
                        if (typeof mem.bandwidthGB === 'number' && isFinite(mem.bandwidthGB)) {
                            addResult(`   å†…å­˜å¸¦å®½: ${mem.bandwidthGB.toFixed(2)} GB/s`, 'cpu-info');
                        } else if (typeof mem.bandwidthMB === 'number' && isFinite(mem.bandwidthMB)) {
                            addResult(`   å†…å­˜å¸¦å®½: ${mem.bandwidthMB.toFixed(2)} MB/s`, 'cpu-info');
                        }
                    }

                    if (fingerprint.timing.computeLatency) {
                        const compute = fingerprint.timing.computeLatency;
                        addResult(`   ç®€å•calculation: ${compute.simple?.toFixed(2)}ms`, 'cpu-info');
                        addResult(`   æ•°å­¦å¯†é›†: ${compute.math_intensive?.toFixed(2)}ms`, 'cpu-info');
                        addResult(`   å†…å­˜å¯†é›†: ${compute.memory_intensive?.toFixed(2)}ms`, 'cpu-info');
                    }

                    if (fingerprint.timing.cacheProfile) {
                        const cache = fingerprint.timing.cacheProfile;
                        addResult(`   ç¼“å­˜efficiency: ${cache.cacheEfficiency?.toFixed(2)}`, 'cpu-info');
                    }
                }

                // GPUModelåˆ†æ
                const analysis = webgpuFP.analyzeGPUModel(fingerprint);
                addResult(' WebGPU GPUModel Inference:', 'model-guess');
                addResult(`   Model: ${analysis.model}`, 'model-guess');
                addResult(`   Confidence: ${analysis.confidence}%`, 'model-guess');
                if (analysis.evidence.length > 0) {
                    addResult('   Inference Basis:', 'model-guess');
                    analysis.evidence.forEach(evidence => {
                        addResult(`     - ${evidence}`, 'model-guess');
                    });
                }

                webgpuFP.cleanup();

            } catch (error) {
                addResult(` WebGPU Detection Exception: ${error.message}`, 'limitation');
            }
        }

        async function ensureCommonLoaded() {
            if (typeof WASMFingerprint === 'function' && window.wasmFingerprint instanceof WASMFingerprint) {
                return;
            }
            if (typeof WASMFingerprint === 'function' && !window.wasmFingerprint) {
                window.wasmFingerprint = new WASMFingerprint();
                return;
            }
            await new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = `./src/common.js?v=${Date.now()}`;
                script.dataset.autoLoaded = 'common';
                script.onload = resolve;
                script.onerror = () => reject(new Error('æ— æ³•åŠ è½½ common.js'));
                document.head.appendChild(script);
            });
            if (typeof WASMFingerprint === 'function' && !(window.wasmFingerprint instanceof WASMFingerprint)) {
                window.wasmFingerprint = new WASMFingerprint();
            }
        }

        async function exportCalibrationSample() {
            try {
                addResult('===  å¯¼å‡ºæ ¡å‡†æ ·æœ¬ ===', 'enhancement');

                await initWASM();
                await ensureCommonLoaded();
                let wasmHelper = window.wasmFingerprint;
                const errors = {};

                let wasmFingerprint = null;
                try {
                    if (!wasmHelper || typeof wasmHelper.generateFingerprint !== 'function') {
                        throw new Error('WASM æŒ‡çº¹åŠ©æ‰‹æœªåŠ è½½');
                    }
                    // æå‰åŠ è½½æ ¡å‡†æ•°æ®ï¼Œæ–¹ä¾¿åç»­æ•°æ®åº“æ‰“åˆ†åˆ©ç”¨é˜ˆå€¼
                    try { await wasmHelper.loadCalibration(); } catch (_e) {}
                    wasmFingerprint = await wasmHelper.generateFingerprint();
                } catch (err) {
                    errors.wasm = err?.message || String(err);
                    addResult(` Unable to acquire WASM fingerprint: ${errors.wasm}`, 'limitation');
                }

                let webglFingerprint = null;
                try {
                    const webglFP = new WebGLFingerprinter();
                    webglFingerprint = await webglFP.generateFingerprint();
                    webglFP.cleanup();
                    if (!webglFingerprint) {
                        addResult(' WebGLæŒ‡çº¹ä¸Availableï¼Œæ ·æœ¬ä¸­å°†è®°å½• nullã€‚', 'model-guess');
                    }
                } catch (err) {
                    errors.webgl = err?.message || String(err);
                    addResult(` Unable to acquire WebGL fingerprint: ${errors.webgl}`, 'limitation');
                }

                let webgpuFingerprint = null;
                try {
                    const webgpuFP = new WebGPUFingerprinter();
                    webgpuFingerprint = await webgpuFP.generateFingerprint();
                    webgpuFP.cleanup();
                    if (!webgpuFingerprint) {
                        addResult(' WebGPUæŒ‡çº¹ä¸Availableï¼Œæ ·æœ¬ä¸­å°†è®°å½• nullã€‚', 'model-guess');
                    }
                } catch (err) {
                    errors.webgpu = err?.message || String(err);
                    addResult(` Unable to acquire WebGPU fingerprint: ${errors.webgpu}`, 'limitation');
                }

                const sample = {
                    createdAt: new Date().toISOString(),
                    userAgent: navigator.userAgent,
                    wasm: wasmFingerprint,
                    webgl: webglFingerprint,
                    webgpu: webgpuFingerprint,
                    meta: {
                        page: 'enhanced-detection.html',
                        wasmRuntimeInitialized: !!(wasmModule && wasmModule.runtimeInitialized)
                    },
                    errors
                };

                const blob = new Blob([JSON.stringify(sample, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                link.href = url;
                link.download = `calibration-sample-${timestamp}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                if (Object.keys(errors).length) {
                    addResult(' Sample exported but contains some missing fieldsï¼›Please check errors in JSONã€‚', 'limitation');
                } else {
                    addResult(' Sample exported, please place JSON in docs/device-database/samples/ then run ingestã€‚', 'cpu-info');
                }

            } catch (error) {
                console.error('exportCalibrationSample failed', error);
                addResult(` Sample Export Failed: ${error.message}`, 'limitation');
            }
        }

        async function runRealWorldDetection() {
            try {
                addResult('===  Real Environment Detection Started ===', 'enhancement');
                await initWASM();
                await ensureCommonLoaded();

                if (typeof RealWorldDetector !== 'function') {
                    throw new Error('RealWorldDetector æœªåŠ è½½');
                }

                const detector = new RealWorldDetector();
                const report = await detector.detect();

                addResult('ğŸ§± Basic Signals:', 'cpu-info');
                addResult(`   cores: ${report.basic.hardwareConcurrency ?? 'Unknown'}`, 'cpu-info');
                addResult(`   deviceMemory: ${report.basic.deviceMemory ?? 'Unknown'} GB`, 'cpu-info');
                addResult(`   platform: ${report.basic.platform ?? 'Unknown'}`, 'cpu-info');

                addResult(' Advanced Capability Detection:', 'enhancement');
                const simdStatus = report.advanced.simd === null ? 'Unknown' : (report.advanced.simd ? ' SIMD Supported' : ' ä¸SIMD Supported');
                const simdClass = report.advanced.simd === true ? 'cpu-info' : (report.advanced.simd === false ? 'limitation' : 'enhancement');
                addResult(`   SIMD: ${simdStatus}`, simdClass);
                const sabStatus = report.advanced.sharedArrayBuffer ? ' Available' : ' ä¸Available';
                addResult(`   SharedArrayBuffer: ${sabStatus}`, report.advanced.sharedArrayBuffer ? 'cpu-info' : 'limitation');
                if (report.advanced.webgpu.available) {
                    const detected = report.advanced.webgpu.detected ? ' Fingerprint Acquired' : ' Availableä½†é‡‡é›†Failed';
                    addResult(`   WebGPU: ${detected}`, report.advanced.webgpu.detected ? 'cpu-info' : 'limitation');
                    if (report.advanced.webgpu.analysis) {
                        addResult(`     - ${report.advanced.webgpu.analysis.model} (${report.advanced.webgpu.analysis.confidence}%)`, 'cpu-info');
                    }
                    if (report.advanced.webgpu.error) {
                        addResult(`     - Error: ${report.advanced.webgpu.error}`, 'limitation');
                    }
                } else {
                    addResult('   WebGPU:  ä¸Available', 'limitation');
                }

                addResult('ğŸ”„ Fallback Features:', 'cpu-info');
                if (report.fallback.wasm?.summary) {
                    const wasm = report.fallback.wasm.summary;
                    addResult(`   WASM CPU Family: ${wasm.cpuFamily ?? 'Unknown'} (${wasm.confidence ?? 0}% confidence)`, 'cpu-info');
                    addResult(`     L1Ratio: ${wasm.l1Band ?? 'N/A'} | æ·±å±‚Ratio: ${wasm.deepBand ?? 'N/A'}`, 'cpu-info');
                }
                if (report.fallback.webgl?.summary) {
                    const webgl = report.fallback.webgl.summary;
                    addResult(`   WebGL Renderer: ${webgl.renderer ?? 'Unknown'}`, 'cpu-info');
                    addResult(`     CanvasHash: ${webgl.canvasHash ?? 'N/A'}`, 'cpu-info');
                    if (webgl.blendHash || webgl.canvas2DHash) {
                        addResult(`     Blend: ${webgl.blendHash ?? 'N/A'}, Canvas2D: ${webgl.canvas2DHash ?? 'N/A'}`, 'cpu-info');
                    }
                }
                const fallbackErrors = Object.entries(report.fallback.errors || {});
                if (fallbackErrors.length) {
                    addResult('    FallbackError:', 'limitation');
                    fallbackErrors.forEach(([key, message]) => addResult(`     - ${key}: ${message}`, 'limitation'));
                }

                addResult(' Comprehensive Conclusion:', 'model-guess');
                addResult(`   Identified Device: ${report.analysis.device}`, 'model-guess');
                addResult(`   Method: ${report.analysis.method} (${report.analysis.tier})`, 'model-guess');
                addResult(`   Confidence: ${report.analysis.confidence}%`, 'model-guess');
                if (Array.isArray(report.analysis.evidence) && report.analysis.evidence.length) {
                    report.analysis.evidence.forEach(ev => addResult(`   - ${ev}`, 'model-guess'));
                }

                const dbSignal = report.analysis.signals?.databaseResult;
                if (dbSignal && dbSignal.deviceModel) {
                    addResult(`   Database Match: ${dbSignal.deviceModel} (${dbSignal.confidence}% )`, 'model-guess');
                }

                if (Array.isArray(report.timeline) && report.timeline.length) {
                    addResult('â±ï¸ Stage Duration:', 'enhancement');
                    const baseTs = report.timeline[0].timestamp;
                    report.timeline.forEach(entry => {
                        const dt = ((entry.timestamp - baseTs) / 1000).toFixed(2);
                        addResult(`   [${entry.stage}] +${dt}s`, 'enhancement');
                    });
                }

                if (typeof report.durationMs === 'number') {
                    addResult(` Total Detection Duration: ${report.durationMs.toFixed(1)}ms`, 'cpu-info');
                }

            } catch (error) {
                console.error('runRealWorldDetection failed', error);
                addResult(` Real Environment Detection Failed: ${error.message}`, 'limitation');
            }
        }

        // ä¸‰é‡æ£€æµ‹å‡½æ•° - æ ¸å¿ƒåŠŸèƒ½
        async function runTripleDetection() {
            try {
                addResult('===  Triple Detection System Started ===', 'enhancement');
                addResult('Executing WASM + WebGL + WebGPU Comprehensive Detection...', 'enhancement');

                // 1. WASM CPUæ£€æµ‹
                addResult('ğŸ”§ Stage 1: WASM CPU Microarchitecture Detection', 'cpu-info');
                await initWASM();
                await ensureCommonLoaded();

                const wasmHelper = window.wasmFingerprint;
                if (!wasmHelper || typeof wasmHelper.generateFingerprint !== 'function') {
                    throw new Error('WASM æŒ‡çº¹åŠ©æ‰‹æœªåŠ è½½');
                }

                let calibrationData = null;
                try {
                    calibrationData = await wasmHelper.loadCalibration();
                } catch (_e) {
                    calibrationData = null;
                }

                const wasmSummary = await buildWasmFingerprintSummary(wasmHelper);
                const wasmFingerprintData = wasmSummary.fingerprint;
                wasmFingerprint = wasmFingerprintData;
                const cpuFeatures = wasmSummary.cpuFeatures;
                const cpuAnalysis = wasmSummary.cpuAnalysis;

                addResult(` CPU Features: ${cpuFeatures.model} (Confidence: ${cpuFeatures.confidence}%)`, 'cpu-info');

                if (typeof cpuFeatures.memRatio === 'number') {
                    addResult(`   å†…å­˜è®¿é—®Ratio: ${cpuFeatures.memRatio.toFixed(3)}`, 'cpu-info');
                }

                if (typeof wasmFingerprintData?.structure?.l1_kb === 'number') {
                    addResult(`   Detected L1 Cache: ${wasmFingerprintData.structure.l1_kb}KB`, 'cpu-info');
                }

                if (Array.isArray(cpuAnalysis?.evidence) && cpuAnalysis.evidence.length) {
                    cpuAnalysis.evidence.forEach(e => addResult(`   - ${e}`, 'cpu-info'));
                }

                const wasmFeatureSet = wasmFingerprintData?.features || {};
                if (typeof wasmFeatureSet.simd_supported === 'boolean') {
                    const simdMsg = wasmFeatureSet.simd_supported ? 'æ”¯æŒWASM SIMDæ‰©å±•' : 'Not DetectedWASM SIMD';
                    addResult(`   SIMDæ‰©å±•: ${simdMsg}`, wasmFeatureSet.simd_supported ? 'cpu-info' : 'limitation');
                    if (wasmFeatureSet.simd_supported && typeof wasmFeatureSet.simd_speedup === 'number' && isFinite(wasmFeatureSet.simd_speedup)) {
                        addResult(`   SIMDé€Ÿåº¦æå‡: ${wasmFeatureSet.simd_speedup.toFixed(2)}x`, 'cpu-info');
                    }
                }

                const workerProfile = wasmFingerprintData?.workerProfile;
                if (workerProfile && workerProfile.spawned) {
                    const latency = typeof workerProfile.medianLatency === 'number' && isFinite(workerProfile.medianLatency)
                        ? `${workerProfile.medianLatency.toFixed(2)}ms` : 'N/A';
                    addResult(`   Workerå¹¶å‘èƒ½åŠ›: ${workerProfile.spawned} (ä¸­ä½å¾€è¿” ${latency})`, 'cpu-info');
                }

                // 2. WebGL GPU Detection
                addResult('ğŸ¨ Stage 2: WebGL GPU Detection', 'enhancement');
                const webglFP = new WebGLFingerprinter();
                const webglFingerprint = await webglFP.generateFingerprint();
                const webglAnalysis = webglFingerprint ? webglFP.analyzeGPUModel(webglFingerprint) : null;

                if (webglAnalysis) {
                    addResult(` WebGL GPU: ${webglAnalysis.model} (Confidence: ${webglAnalysis.confidence}%)`, 'enhancement');
                } else {
                    addResult(' WebGLæ£€æµ‹Failed', 'limitation');
                }

                // 3. WebGPUæ£€æµ‹
                addResult(' Stage 3: WebGPU Advanced Detection', 'enhancement');
                const webgpuFP = new WebGPUFingerprinter();
                const webgpuFingerprint = await webgpuFP.generateFingerprint();
                const webgpuAnalysis = webgpuFingerprint ? webgpuFP.analyzeGPUModel(webgpuFingerprint) : null;

                if (webgpuAnalysis) {
                    addResult(` WebGPU GPU: ${webgpuAnalysis.model} (Confidence: ${webgpuAnalysis.confidence}%)`, 'enhancement');
                } else {
                    addResult(' WebGPUæ£€æµ‹Failed', 'limitation');
                }

                // 4. ç»¼åˆåˆ†æå’Œè®¾å¤‡è¯†åˆ«
                addResult(' Stage 4: Comprehensive Analysis and Device Identification', 'model-guess');

                // åˆå§‹åŒ–è®¾å¤‡æ•°æ®åº“
                if (!deviceDatabase) {
                    deviceDatabase = new DeviceSignatureDatabase();
                }

                if (calibrationData?.bands) {
                    deviceDatabase.calibrationBands = calibrationData.bands;
                }

                // usingæ•°æ®åº“è¿›è¡Œç²¾ç¡®è¯†åˆ«
                const databaseResult = deviceDatabase.identifyDevice(cpuFeatures, webglAnalysis, webgpuAnalysis);
                const deviceIdentification = enhanceWithDatabase(cpuFeatures, webglAnalysis, webgpuAnalysis, databaseResult);

                addResult(' Final Device Identification Results:', 'model-guess');
                addResult(`   è®¾å¤‡Model: ${deviceIdentification.deviceModel}`, 'model-guess');
                addResult(`   CPU Model: ${deviceIdentification.cpuModel}`, 'model-guess');
                addResult(`   GPUModel: ${deviceIdentification.gpuModel}`, 'model-guess');
                addResult(`   ç»¼åˆConfidence: ${deviceIdentification.confidence}%`, 'model-guess');

                addResult(' Identification Basis:', 'model-guess');
                deviceIdentification.evidence.forEach(evidence => {
                    addResult(`   - ${evidence}`, 'model-guess');
                });

                // æ¸…ç†
                if (webglFP) webglFP.cleanup();
                if (webgpuFP) webgpuFP.cleanup();

            } catch (error) {
                addResult(` Triple Detection Failed: ${error.message}`, 'limitation');
            }
        }

        // ç”ŸæˆWASMæŒ‡çº¹æ‘˜è¦ï¼ˆä¾›ä¸‰é‡æ£€æµ‹å¤ç”¨ï¼‰
        async function buildWasmFingerprintSummary(wasmHelper) {
            if (!wasmHelper || typeof wasmHelper.generateFingerprint !== 'function') {
                throw new Error('WASM æŒ‡çº¹åŠ©æ‰‹æœªåˆå§‹åŒ–');
            }

            const fingerprint = await wasmHelper.generateFingerprint();
            const cpuAnalysis = typeof wasmHelper.analyzeCPUType === 'function'
                ? wasmHelper.analyzeCPUType(fingerprint)
                : { family: 'Unknown Architecture', confidence: 50 };

            let memRatio = null;
            if (typeof wasmHelper._safeOverallRatio === 'function') {
                memRatio = wasmHelper._safeOverallRatio(fingerprint.memoryResults);
            }
            if (typeof memRatio !== 'number' || !isFinite(memRatio)) {
                if (typeof cpuAnalysis.overall === 'number' && isFinite(cpuAnalysis.overall)) {
                    memRatio = cpuAnalysis.overall;
                } else {
                    const ratios = fingerprint?.memoryResults || {};
                    const values = Object.values(ratios).map(v => v?.ratio).filter(x => typeof x === 'number');
                    if (values.length) {
                        memRatio = values.reduce((a, b) => a + b, 0) / values.length;
                    }
                }
            }

            const l1Band = (typeof cpuAnalysis.l1Band === 'number' && isFinite(cpuAnalysis.l1Band))
                ? cpuAnalysis.l1Band : null;
            const deepBand = (typeof cpuAnalysis.deepBand === 'number' && isFinite(cpuAnalysis.deepBand))
                ? cpuAnalysis.deepBand : null;

            const cpuFeatures = {
                model: cpuAnalysis.family || 'Unknown Architecture',
                confidence: cpuAnalysis.confidence ?? 50,
                memRatio: (typeof memRatio === 'number' && isFinite(memRatio)) ? memRatio : null,
                memRatioL1: l1Band,
                memRatioDeep: deepBand
            };

            return { fingerprint, cpuFeatures, cpuAnalysis };
        }

        // æ—¶é—´Testå‡½æ•°
        function timedTest(testFunc, ...args) {
            const startTime = performance.now();
            const result = testFunc(...args);
            const endTime = performance.now();
            return { result, time: endTime - startTime };
        }


        // ç»¼åˆè®¾å¤‡è¯†åˆ«åˆ†æ
        function analyzeDeviceIdentity(cpuFeatures, webglAnalysis, webgpuAnalysis) {
            const evidence = [];
            let deviceModel = "Unknownè®¾å¤‡";
            let cpuModel = cpuFeatures.model;
            let gpuModel = "UnknownGPU";
            let confidence = 0;

            // ç¡®å®šGPUModel
            if (webgpuAnalysis && webgpuAnalysis.confidence > 70) {
                gpuModel = webgpuAnalysis.model;
                evidence.push(`WebGPUé«˜Confidenceè¯†åˆ«: ${gpuModel}`);
            } else if (webglAnalysis && webglAnalysis.confidence > 60) {
                gpuModel = webglAnalysis.model;
                evidence.push(`WebGLè¯†åˆ«: ${gpuModel}`);
            }

            // based onCPU+GPUç»„åˆè¯†åˆ«å…·ä½“è®¾å¤‡
            if (cpuFeatures.model.includes("Apple Silicon")) {
                if (gpuModel.includes("Apple") || gpuModel.includes("M1") || gpuModel.includes("M2") || gpuModel.includes("M3")) {
                    // Appleè®¾å¤‡ç²¾ç¡®è¯†åˆ«
                    if (gpuModel.includes("M1 Pro") || gpuModel.includes("M1 Max")) {
                        deviceModel = "MacBook Pro (M1 Pro/Max)";
                        confidence = 95;
                    } else if (gpuModel.includes("M2")) {
                        deviceModel = "MacBook (M2 ç³»åˆ—)";
                        confidence = 92;
                    } else if (gpuModel.includes("M1")) {
                        deviceModel = "MacBook/iMac (M1)";
                        confidence = 90;
                    } else {
                        deviceModel = "Apple Silicon è®¾å¤‡";
                        confidence = 85;
                    }
                    evidence.push("CPUå’ŒGPUç‰¹å¾å®Œå…¨åŒ¹é…Appleç”Ÿæ€");
                } else {
                    deviceModel = "Appleè®¾å¤‡ (GPUè¯†åˆ«å¼‚å¸¸)";
                    confidence = 70;
                    evidence.push("CPUæ˜¯Apple Siliconä½†GPUè¯†åˆ«ä¸åŒ¹é…");
                }
            }
            else if (cpuFeatures.model.includes("Intel")) {
                if (gpuModel.includes("Intel")) {
                    deviceModel = "Intelå¹³å° (é›†æˆæ˜¾å¡)";
                    confidence = 85;
                    evidence.push("Intel CPU + Intel GPUç»„åˆ");
                } else if (gpuModel.includes("NVIDIA") || gpuModel.includes("RTX") || gpuModel.includes("GTX")) {
                    deviceModel = "Intelå¹³å° + NVIDIAç‹¬æ˜¾";
                    confidence = 90;
                    evidence.push("Intel CPU + NVIDIA GPUç»„åˆ");
                } else if (gpuModel.includes("AMD") || gpuModel.includes("Radeon")) {
                    deviceModel = "Intelå¹³å° + AMDç‹¬æ˜¾";
                    confidence = 88;
                    evidence.push("Intel CPU + AMD GPUç»„åˆ");
                } else {
                    deviceModel = "Intelå¹³å°";
                    confidence = 75;
                }
            }
            else if (cpuFeatures.model.includes("AMD")) {
                if (gpuModel.includes("AMD") || gpuModel.includes("Radeon")) {
                    deviceModel = "AMDå…¨å®¶æ¡¶å¹³å°";
                    confidence = 90;
                    evidence.push("AMD CPU + AMD GPUç»„åˆ");
                } else if (gpuModel.includes("NVIDIA")) {
                    deviceModel = "AMD CPU + NVIDIA GPU";
                    confidence = 88;
                    evidence.push("AMD CPU + NVIDIA GPUç»„åˆ");
                } else {
                    deviceModel = "AMDå¹³å°";
                    confidence = 75;
                }
            }
            else {
                deviceModel = "æ— æ³•ç¡®å®šè®¾å¤‡Model";
                confidence = 30;
                evidence.push("CPUå’ŒGPUè¯†åˆ«Confidenceéƒ½è¾ƒä½");
            }

            // æ·»åŠ æ£€æµ‹Methodè¯´æ˜
            evidence.push(`CPUå†…å­˜Ratio: ${cpuFeatures.memRatio?.toFixed(3) || 'Unknown'}`);

            if (webglAnalysis) {
                evidence.push(`WebGL renderer: ${webglAnalysis.rawRenderer || 'Unknown'}`);
            }

            if (webgpuAnalysis) {
                evidence.push(`WebGPU vendor: ${webgpuAnalysis.rawAdapter?.vendor || 'Unknown'}`);
            }

            return {
                deviceModel,
                cpuModel,
                gpuModel,
                confidence,
                evidence
            };
        }

        // ä¼˜åŒ–çš„è®¾å¤‡è¯†åˆ«åˆ†æ
        function analyzeDeviceIdentity(cpuFeatures, webglAnalysis, webgpuAnalysis) {
            let deviceModel = "Unknownè®¾å¤‡";
            let cpuModel = cpuFeatures.model;
            let gpuModel = "UnknownGPU";
            let confidence = 30;
            const evidence = [];

            // 1. GPUæ£€æµ‹ä¼˜å…ˆçº§æœ€é«˜ï¼ˆApple Siliconå¯ä»¥æ˜ç¡®è¯†åˆ«GPUModelï¼‰
            if (webgpuAnalysis && webgpuAnalysis.confidence >= 90) {
                if (webgpuAnalysis.model.includes("M4 Pro")) {
                    deviceModel = "Apple Silicon è®¾å¤‡";
                    cpuModel = "Apple M4 Pro";
                    gpuModel = webgpuAnalysis.model;
                    confidence = Math.max(90, webgpuAnalysis.confidence);
                    evidence.push(`WebGPUé«˜Confidenceè¯†åˆ«: ${webgpuAnalysis.model}`);
                    evidence.push("CPUå’ŒGPUç‰¹å¾å®Œå…¨åŒ¹é…Appleç”Ÿæ€");
                } else if (webgpuAnalysis.model.includes("Apple")) {
                    deviceModel = "Apple Silicon è®¾å¤‡";
                    cpuModel = "Apple Silicon";
                    gpuModel = webgpuAnalysis.model;
                    confidence = Math.max(85, webgpuAnalysis.confidence);
                    evidence.push(`WebGPUè¯†åˆ«Apple GPU: ${webgpuAnalysis.model}`);
                }
            }

            // 2. WebGLä½œä¸ºè¡¥å……éªŒè¯
            if (webglAnalysis && webglAnalysis.confidence >= 85) {
                if (webglAnalysis.model.includes("Apple") || webglAnalysis.model.includes("Metal")) {
                    if (confidence < 80) {
                        deviceModel = "Apple Silicon è®¾å¤‡";
                        cpuModel = "Apple Silicon";
                        confidence = Math.max(confidence, 80);
                    }
                    evidence.push(`WebGLè¯†åˆ«: ${webglAnalysis.model}`);
                }
            }

            // 3. CPU Featuresä½œä¸ºæœ€ç»ˆéªŒè¯ï¼ˆé™ä½æƒé‡é¿å…å¹²æ‰°ï¼‰
            if (cpuFeatures.model && cpuFeatures.confidence >= 70) {
                if (cpuFeatures.model.includes("Apple")) {
                    // å¦‚æœGPUå·²ç»è¯†åˆ«ä¸ºAppleï¼Œå¢å¼ºConfidence
                    if (deviceModel.includes("Apple")) {
                        confidence = Math.min(95, confidence + 5);
                        evidence.push("WASM CPU Featuresç¡®è®¤Appleæ¶æ„");
                    } else {
                        // GPUæ²¡è¯†åˆ«å‡ºAppleï¼Œä½†CPUè¯†åˆ«å‡ºæ¥äº†
                        deviceModel = "Apple Silicon è®¾å¤‡";
                        cpuModel = cpuFeatures.model;
                        confidence = Math.max(confidence, cpuFeatures.confidence);
                        evidence.push(`WASMè¯†åˆ«: ${cpuFeatures.model}`);
                    }
                }
            }

            // 4. æ·»åŠ è¯¦ç»†çš„æŠ€æœ¯ç‰¹å¾è¯æ®
            if (deviceModel.includes("Apple")) {
                if (webglAnalysis?.basic?.renderer) {
                    evidence.push(`WebGL renderer: ${webglAnalysis.basic.renderer}`);
                }
                if (webgpuAnalysis?.adapter?.vendor) {
                    evidence.push(`WebGPU vendor: ${webgpuAnalysis.adapter.vendor}`);
                }
                if (cpuFeatures.memRatio) {
                    evidence.push(`CPUå†…å­˜Ratio: ${cpuFeatures.memRatio.toFixed(3)}`);
                }
            }

            return {
                deviceModel,
                cpuModel,
                gpuModel,
                confidence,
                evidence
            };
        }

        // usingæ•°æ®åº“å¢å¼ºè®¾å¤‡è¯†åˆ«
        function enhanceWithDatabase(cpuFeatures, webglAnalysis, webgpuAnalysis, databaseResult) {
            if (databaseResult.confidence > 70) {
                // æ•°æ®åº“è¯†åˆ«Confidenceé«˜ï¼Œusingæ•°æ®åº“ç»“æœ
                return {
                    deviceModel: databaseResult.deviceModel,
                    cpuModel: cpuFeatures.model,
                    gpuModel: (webgpuAnalysis && webgpuAnalysis.confidence > webglAnalysis?.confidence) ?
                        webgpuAnalysis.model : webglAnalysis?.model || "UnknownGPU",
                    confidence: databaseResult.confidence,
                    evidence: [
                        ` Database Exact Match (${databaseResult.confidence}% Confidence)`,
                        ...databaseResult.evidence,
                        ...(databaseResult.alternatives.length > 0 ?
                            [`å¤‡é€‰æ–¹æ¡ˆ: ${databaseResult.alternatives.map(alt => `${alt.brand} ${alt.deviceName}`).join(', ')}`] : [])
                    ]
                };
            } else {
                // æ•°æ®åº“è¯†åˆ«Confidenceä½ï¼Œusingä¼ ç»ŸMethodå¹¶å­¦ä¹ æ–°ç‰¹å¾
                const traditional = analyzeDeviceIdentity(cpuFeatures, webglAnalysis, webgpuAnalysis);

                // å­¦ä¹ æ–°è®¾å¤‡ç‰¹å¾ç”¨äºæœªæ¥è¯†åˆ«
                if (traditional.confidence > 60) {
                    deviceDatabase.learnDeviceSignature(traditional.deviceModel, cpuFeatures, webglAnalysis, webgpuAnalysis);
                }

                return {
                    ...traditional,
                    evidence: [
                        ` Database Matchåº¦è¾ƒä½ (${databaseResult.confidence}%)ï¼Œusingä¼ ç»Ÿåˆ†æ`,
                        ...traditional.evidence,
                        ...(databaseResult.confidence > 30 ?
                            [`ç›¸ä¼¼è®¾å¤‡: ${databaseResult.deviceModel}`] : [])
                    ]
                };
            }
        }

        // æ˜¾ç¤ºDevice Database Statistics
        function showDatabaseStats() {
            try {
                addResult('===  Device Database Statistics ===', 'enhancement');

                // åˆå§‹åŒ–æ•°æ®åº“
                if (!deviceDatabase) {
                    deviceDatabase = new DeviceSignatureDatabase();
                }

                const stats = deviceDatabase.generateDeviceStats();

                addResult('ğŸ“‹ æ•°æ®åº“æ¦‚è§ˆ:', 'cpu-info');
                addResult(`   æ€»è®¾å¤‡é…ç½®: ${stats.totalProfiles}`, 'cpu-info');
                addResult(`   å­¦ä¹ è®¾å¤‡æ•°: ${stats.learningData.totalDevices}`, 'cpu-info');
                addResult(`   å­¦ä¹ æ ·æœ¬æ•°: ${stats.learningData.totalSignatures}`, 'cpu-info');

                addResult('ğŸ­ æŒ‰å“ç‰Œåˆ†å¸ƒ:', 'cpu-info');
                for (const [brand, count] of Object.entries(stats.byBrand)) {
                    addResult(`   ${brand}: ${count}è®¾å¤‡`, 'cpu-info');
                }

                // å±•ç¤ºSupported Device Types
                addResult(' Supported Device Types:', 'enhancement');
                addResult('   Apple Series:', 'enhancement');
                addResult('     - MacBook Air M1', 'enhancement');
                addResult('     - MacBook Pro M1 Pro/Max', 'enhancement');
                addResult('     - MacBook Pro M2', 'enhancement');

                addResult('   Intel Series:', 'enhancement');
                addResult('     - Intelé«˜ç«¯æ¡Œé¢ + é›†æˆæ˜¾å¡', 'enhancement');
                addResult('     - Intelæ¸¸æˆæœ¬ + NVIDIAç‹¬æ˜¾', 'enhancement');

                addResult('   AMD Series:', 'enhancement');
                addResult('     - Ryzenæ¡Œé¢ + Radeonæ˜¾å¡', 'enhancement');

                addResult('   Mobile Devices:', 'enhancement');
                addResult('     - é«˜ç«¯Androidè®¾å¤‡', 'enhancement');

                addResult(' Identification Features:', 'cpu-info');
                addResult('   - CPUå†…å­˜è®¿é—®Ratioåˆ†æ', 'cpu-info');
                addResult('   - WebGLRendererå­—ç¬¦ä¸²åŒ¹é…', 'cpu-info');
                addResult('   - WebGPU Adapter InformationéªŒè¯', 'cpu-info');
                addResult('   - GPUæ€§èƒ½åŸºå‡†Test', 'cpu-info');
                addResult('   - Multi-dimensional Feature Fusion Algorithm', 'cpu-info');

                addResult(' Database Advantages:', 'model-guess');
                addResult('   - based onçœŸå®è®¾å¤‡æ•°æ®è®­ç»ƒ', 'model-guess');
                addResult('   - Continuously learning new device features', 'model-guess');
                addResult('   - Multiple verification improves accuracy', 'model-guess');
                addResult('   - Supports similar device recommendations', 'model-guess');

            } catch (error) {
                addResult(` Database Statistics Failed: ${error.message}`, 'limitation');
            }
        }

        // ===== ç®€åŒ–çš„éªŒè¯å’Œè¯Šæ–­åŠŸèƒ½ =====

        function debugWASMModule(Module) {
            addResult(' WASM Module Status Check:', 'enhancement');

            // æ£€æŸ¥æ¨¡å—åŸºç¡€çŠ¶æ€
            const moduleKeys = Object.keys(Module || {});
            addResult(`ğŸ“‹ Moduleå¯¹è±¡å±æ€§æ•°é‡: ${moduleKeys.length}`, 'cpu-info');

            // æ£€æŸ¥å¯¼å‡ºçš„å‡½æ•°
            const wasmFunctions = moduleKeys.filter(key => key.startsWith('_') && typeof Module[key] === 'function');
            addResult(`ğŸ”§ WASMå¯¼å‡ºå‡½æ•°: ${wasmFunctions.length}`, wasmFunctions.length > 0 ? 'cpu-info' : 'limitation');

            if (wasmFunctions.length > 0) {
                wasmFunctions.slice(0, 5).forEach(funcName => {
                    addResult(`   - ${funcName}`, 'cpu-info');
                });
                if (wasmFunctions.length > 5) {
                    addResult(`   - ... more${wasmFunctions.length - 5}å‡½æ•°`, 'cpu-info');
                }
            }

            // æ£€æŸ¥è¿è¡Œæ—¶çŠ¶æ€
            addResult('âš™ï¸ è¿è¡Œæ—¶çŠ¶æ€:', 'cpu-info');
            addResult(`   runtimeInitialized: ${!!Module.runtimeInitialized}`, 'cpu-info');
            addResult(`   calledRun: ${!!Module.calledRun}`, 'cpu-info');

            // å¼ºåˆ¶æ£€æŸ¥wasmMemory
            if (typeof Module.wasmMemory !== 'undefined' && Module.wasmMemory) {
                addResult(`   wasmMemoryå­˜åœ¨: æ˜¯ (${Module.wasmMemory.buffer ? Module.wasmMemory.buffer.byteLength + ' bytes' : 'æ— buffer'})`, 'cpu-info');
            } else {
                addResult(`   wasmMemoryå­˜åœ¨: å¦`, 'limitation');
            }

            // æ£€æŸ¥å†…å­˜ç›¸å…³API - åªæ˜¾ç¤ºé‡è¦çš„çŠ¶æ€
            const coreMemoryAPIs = {
                'HEAP8 å†…å­˜è§†å›¾': !!Module.HEAP8,
                '_malloc å‡½æ•°': typeof Module._malloc === 'function'
            };

            // å¯é€‰çš„APIï¼ˆä¸å½±å“åŠŸèƒ½ï¼‰
            const optionalAPIs = {
                'HEAP16': !!Module.HEAP16,
                'HEAP32': !!Module.HEAP32,
                'memoryå¯¹è±¡': !!Module.memory,
                'mallocåˆ«å': typeof Module.malloc === 'function'
            };

            addResult(' Core Memory API Status:', 'cpu-info');
            for (const [api, available] of Object.entries(coreMemoryAPIs)) {
                const status = available ? '' : '';
                addResult(`   ${status} ${api}`, available ? 'cpu-info' : 'limitation');
            }

            const optionalCount = Object.values(optionalAPIs).filter(Boolean).length;
            addResult(` å¯é€‰APIAvailable: ${optionalCount}/4 (ä¸å½±å“æ ¸å¿ƒåŠŸèƒ½)`, 'model-guess');

            // å°è¯•æ‰‹åŠ¨æ£€æŸ¥å†…å­˜
            if (Module.memory && Module.memory.buffer) {
                const bufferSize = Module.memory.buffer.byteLength;
                addResult(` WASM Memory Buffer: ${bufferSize} bytes`, 'cpu-info');

                // å°è¯•æ‰‹åŠ¨åˆ›å»ºHEAP8è§†å›¾
                try {
                    const heap8 = new Uint8Array(Module.memory.buffer);
                    addResult(` Manual HEAP8 View: ${heap8.length} bytes`, 'cpu-info');
                } catch (e) {
                    addResult(` Unable to create HEAP8 view: ${e.message}`, 'limitation');
                }
            } else if (Module.HEAP8) {
                addResult(` HEAP8 Size: ${Module.HEAP8.length} bytes`, 'cpu-info');
            } else {
                addResult(' å†…å­˜ç¼“å†²åŒºä¸Available - è¿™mayå½±å“æŸäº›åŠŸèƒ½', 'model-guess');
            }

            // æ£€æŸ¥å…¶ä»–é‡è¦å±æ€§
            const otherProps = ['wasmMemory', 'buffer', 'asm', 'wasmExports'];
            const availableProps = otherProps.filter(prop => Module[prop] !== undefined);
            if (availableProps.length > 0) {
                addResult(`ğŸ”§ å…¶ä»–Availableå±æ€§: ${availableProps.join(', ')}`, 'cpu-info');
            }
        }

        async function runValidationTests() {
            try {
                addResult('=== ğŸ§ª WASMéªŒè¯Test ===', 'enhancement');
                const Module = await initWASM();

                // å…ˆè°ƒè¯•WASMæ¨¡å—çŠ¶æ€
                debugWASMModule(Module);

                // åŸºç¡€åŠŸèƒ½éªŒè¯
                addResult('ğŸ“‹ åŸºç¡€åŠŸèƒ½éªŒè¯:', 'cpu-info');
                const testCases = [
                    { size: 16, iter: 10, name: "å°å†…å­˜å—" },
                    { size: 32, iter: 10, name: "ä¸­ç­‰å†…å­˜å—" },
                    { size: 64, iter: 10, name: "å¤§å†…å­˜å—" }
                ];

                for (const test of testCases) {
                    try {
                        const seq = Module._sequential_access_test(test.size, test.iter);
                        const rand = Module._random_access_test(test.size, test.iter);
                        const ratio = rand / seq;

                        if (isFinite(seq) && isFinite(rand) && !isNaN(seq) && !isNaN(rand) && seq !== 0 && rand !== 0) {
                            const ratio = Math.abs(rand / seq);  // usingç»å¯¹å€¼calculationRatio
                            addResult(` ${test.name}: Ratio=${ratio.toFixed(2)}`, 'cpu-info');
                        } else {
                            addResult(` ${test.name}: Abnormal result (seq=${seq}, rand=${rand})`, 'limitation');
                        }
                    } catch (error) {
                        addResult(` ${test.name}: Execution failed - ${error.message}`, 'limitation');
                    }
                }

                // ä¸€è‡´æ€§æ£€æŸ¥ (3iterationsè¿è¡Œ)
                addResult('ğŸ”„ ä¸€è‡´æ€§æ£€æŸ¥:', 'cpu-info');
                const results = [];
                for (let i = 0; i < 3; i++) {
                    try {
                        const seq = Module._sequential_access_test(16, 10);
                        const rand = Module._random_access_test(16, 10);
                        if (isFinite(seq) && isFinite(rand) && seq !== 0 && rand !== 0) {
                            results.push(Math.abs(rand / seq));  // usingç»å¯¹å€¼
                        }
                    } catch (error) {
                        addResult(` ä¸€è‡´æ€§Testç¬¬${i+1}iterationsFailed: ${error.message}`, 'limitation');
                    }
                }

                if (results.length > 0) {
                    const mean = results.reduce((a, b) => a + b) / results.length;
                    const variance = results.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / results.length;
                    const cv = Math.sqrt(variance) / mean;
                    addResult(` Coefficient of Variation: ${(cv*100).toFixed(1)}% (${results.length}iterationsæœ‰æ•ˆTest)`, cv < 0.3 ? 'cpu-info' : 'model-guess');
                } else {
                    addResult(` ä¸€è‡´æ€§Testå…¨éƒ¨Failed`, 'limitation');
                }

                // calculationå‡½æ•°éªŒè¯
                addResult('ğŸ§® calculationå‡½æ•°éªŒè¯:', 'cpu-info');
                const computeTests = [
                    { name: "æµ®ç‚¹ç²¾åº¦", func: () => Module._float_precision_test(1000) },
                    { name: "Integer Optimization", func: () => Module._integer_optimization_test(1000) },
                    { name: "åˆ†æ”¯é¢„æµ‹", func: () => Module._branch_prediction_test(1000) }
                ];

                for (const test of computeTests) {
                    try {
                        const result = test.func();
                        if (isFinite(result) && !isNaN(result) && result !== 0) {
                            addResult(` ${test.name}: Normal`, 'cpu-info');
                        } else {
                            addResult(` ${test.name}: Abnormal value`, 'model-guess');
                        }
                    } catch (error) {
                        addResult(` ${test.name}: Failed`, 'limitation');
                    }
                }

            } catch (error) {
                addResult(` éªŒè¯TestFailed: ${error.message}`, 'limitation');
            }
        }

        async function runDiagnostics() {
            try {
                addResult('===  System Diagnosis ===', 'enhancement');
                const Module = await initWASM();

                // å†…å­˜åˆ†é…Test
                addResult(' å†…å­˜ç³»ç»Ÿæ£€æŸ¥:', 'cpu-info');
                try {
                    // æ£€æŸ¥WASMæ¨¡å—çŠ¶æ€ - åªè¦åŠŸèƒ½Availableå°±ç»§ç»­
                    if (!Module.runtimeInitialized && !Module.calledRun) {
                        addResult(' WASM runtime not fully initializedï¼ŒWaiting...', 'model-guess');
                        // å°è¯•ç­‰å¾…ä¸€ä¸‹
                        await new Promise(resolve => setTimeout(resolve, 100));
                    } else if (!Module.runtimeInitialized && Module.calledRun) {
                        addResult(' WASMå·²è¿è¡Œä½†è¿è¡Œæ—¶æ ‡å¿—æœªè®¾ç½®ï¼ŒåŠŸèƒ½åº”è¯¥Available', 'model-guess');
                    }

                    // å°è¯•ä¸åŒçš„å†…å­˜åˆ†é…API
                    let ptr = null;
                    let allocSuccess = false;

                    // å°è¯• _malloc
                    if (typeof Module._malloc === 'function') {
                        try {
                            ptr = Module._malloc(1024);
                            if (ptr && ptr > 0) {
                                addResult(` å†…å­˜åˆ†é…Normal (_malloc): ptr=${ptr}`, 'cpu-info');
                                if (typeof Module._free === 'function') {
                                    Module._free(ptr);
                                }
                                allocSuccess = true;
                            }
                        } catch (e) {
                            addResult(` _mallocTestFailed: ${e.message}`, 'limitation');
                        }
                    }

                    // å¦‚æœ_mallocä¸æˆåŠŸï¼Œå°è¯•malloc
                    if (!allocSuccess && typeof Module.malloc === 'function') {
                        try {
                            ptr = Module.malloc(1024);
                            if (ptr && ptr > 0) {
                                addResult(` å†…å­˜åˆ†é…Normal (malloc): ptr=${ptr}`, 'cpu-info');
                                if (typeof Module.free === 'function') {
                                    Module.free(ptr);
                                }
                                allocSuccess = true;
                            }
                        } catch (e) {
                            addResult(` mallocTestFailed: ${e.message}`, 'limitation');
                        }
                    }

                    if (!allocSuccess) {
                        addResult(' åŠ¨æ€å†…å­˜åˆ†é…ä¸Availableï¼ŒChecking HEAP access...', 'model-guess');
                        // æ£€æŸ¥HEAPæ˜¯å¦å¯è®¿é—®
                        if (Module.HEAP8 && Module.HEAP8.length > 0) {
                            addResult(` WASM memory heap accessible: ${Module.HEAP8.length} bytes`, 'cpu-info');
                            // TestHEAPå†™å…¥
                            try {
                                const testIndex = Math.min(1000, Module.HEAP8.length - 1);
                                const originalValue = Module.HEAP8[testIndex];
                                Module.HEAP8[testIndex] = 42;
                                if (Module.HEAP8[testIndex] === 42) {
                                    addResult(` HEAPå†™å…¥TestæˆåŠŸ`, 'cpu-info');
                                    Module.HEAP8[testIndex] = originalValue; // æ¢å¤åŸå€¼
                                } else {
                                    addResult(` HEAPå†™å…¥TestFailed`, 'limitation');
                                }
                            } catch (e) {
                                addResult(` HEAPè®¿é—®TestFailed: ${e.message}`, 'limitation');
                            }
                        } else {
                            addResult(' WASM memory heap not accessible', 'limitation');
                        }
                    }

                } catch (error) {
                    addResult(` å†…å­˜ç³»ç»Ÿæ£€æŸ¥Failed: ${error.message}`, 'limitation');
                }

                // å‡½æ•°Availableæ€§æ£€æŸ¥
                addResult('ğŸ”§ å‡½æ•°Availableæ€§æ£€æŸ¥:', 'cpu-info');
                const functions = ['_sequential_access_test', '_random_access_test', '_float_precision_test'];
                for (const funcName of functions) {
                    const status = Module[funcName] ? '' : '';
                    addResult(`  ${status} ${funcName.replace('_', '')}`, Module[funcName] ? 'cpu-info' : 'limitation');
                }

                // Cache Boundary Diagnosis
                addResult(' Cache Boundary Diagnosis:', 'cpu-info');
                const cacheSizes = [8, 16, 32, 64, 128, 256];
                const cacheResults = [];

                for (const sizeKB of cacheSizes) {
                    try {
                        const iterations = Math.max(10, 500 / sizeKB);
                        const seq = Module._sequential_access_test(sizeKB, iterations);
                        const rand = Module._random_access_test(sizeKB, iterations);

                        if (isFinite(seq) && isFinite(rand) && seq !== 0 && rand !== 0) {
                            const ratio = Math.abs(rand / seq);
                            cacheResults.push({ size: sizeKB, ratio });

                            let level = '';
                            if (ratio > 2.0) level = ' ğŸ”´';
                            else if (ratio > 1.6) level = ' ğŸŸ¡';
                            else if (ratio > 1.3) level = ' ğŸŸ ';
                            else level = ' ğŸŸ¢';

                            addResult(`  ${sizeKB}KB: ${ratio.toFixed(2)}${level}`, 'cpu-info');
                        } else {
                            addResult(`  ${sizeKB}KB: TestFailed (seq=${seq}, rand=${rand})`, 'limitation');
                        }
                    } catch (error) {
                        addResult(`  ${sizeKB}KB: Testå¼‚å¸¸ - ${error.message}`, 'limitation');
                    }
                }

                // Cache Boundary Analysis
                for (let i = 1; i < cacheResults.length; i++) {
                    const prev = cacheResults[i-1];
                    const curr = cacheResults[i];
                    const jump = curr.ratio / prev.ratio;
                    if (jump > 1.5) {
                        addResult(` Cache Boundary: ${prev.size}KB â†’ ${curr.size}KB`, 'model-guess');
                    }
                }

                // æµè§ˆå™¨ç¯å¢ƒæ£€æŸ¥
                addResult('ğŸŒ ç¯å¢ƒæ”¯æŒæ£€æŸ¥:', 'cpu-info');
                const features = {
                    'Performance API': typeof performance.now === 'function',
                    'WASM Memory': !!Module.HEAP8,
                    'BigInt': typeof BigInt !== 'undefined',
                    'SharedArrayBuffer': typeof SharedArrayBuffer !== 'undefined'
                };

                for (const [feature, supported] of Object.entries(features)) {
                    const status = supported ? '' : (feature === 'Performance API' || feature === 'WASM Memory' ? '' : '');
                    const style = supported ? 'cpu-info' : (feature === 'Performance API' || feature === 'WASM Memory' ? 'limitation' : 'model-guess');

                    if (!supported && (feature === 'BigInt' || feature === 'SharedArrayBuffer')) {
                        addResult(`  ${status} ${feature} (å¯é€‰åŠŸèƒ½ï¼Œä¸å½±å“æ£€æµ‹)`, style);
                    } else {
                        addResult(`  ${status} ${feature}`, style);
                    }
                }

            } catch (error) {
                addResult(` System DiagnosisFailed: ${error.message}`, 'limitation');
            }
        }

        // é¡µé¢åŠ è½½æ—¶æ˜¾ç¤ºè¯´æ˜
        window.onload = function() {
            addResult('Enhanced Device Fingerprint Recognition System Ready', 'cpu-info');
            addResult('Main Detection Features:', 'cpu-info');
            addResult('   WASM CPU Detection - Fast and accurate CPU model identification', 'cpu-info');
            addResult('   WASM Detailed Analysis - Deep CPU microarchitecture analysis', 'cpu-info');
            addResult('   WebGL GPU Detection - GPU basic information and rendering features', 'cpu-info');
            addResult('   WebGPU Advanced Detection - GPU performance analysis', 'cpu-info');
            addResult('   Complete Feature Analysis - Detailed cache and performance analysis', 'cpu-info');
            addResult('   Triple Detection - Ultimate accuracy combining all technologies', 'cpu-info');
            addResult('Testing and Diagnostic Tools:', 'enhancement');
            addResult('   WASM Verification Test - Verify basic functionality', 'enhancement');
            addResult('   System Diagnosis - Deep analysis of execution environment', 'enhancement');
            addResult('Suggested test order: WASM CPU Detection â†’ Triple Detection â†’ Complete Analysis', 'enhancement');
        };
    </script>
</body>
</html>
